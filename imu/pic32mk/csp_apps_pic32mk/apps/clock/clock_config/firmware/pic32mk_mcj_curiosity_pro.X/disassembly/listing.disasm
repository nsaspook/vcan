Disassembly Listing for clock_config_pic32mk_mcj_curiosity_pro
Generated From:
/root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/pic32mk_mcj_curiosity_pro.X/dist/pic32mk_mcj_curiosity_pro/production/pic32mk_mcj_curiosity_pro.X.production.elf
Oct 28, 2020 8:55:22 AM

---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/vec3.c  ---------------
1:                   /*___________________________________________________
2:                    |  _____                       _____ _ _       _    |
3:                    | |  __ \                     |  __ (_) |     | |   |
4:                    | | |__) |__ _ __   __ _ _   _| |__) || | ___ | |_  |
5:                    | |  ___/ _ \ '_ \ / _` | | | |  ___/ | |/ _ \| __| |
6:                    | | |  |  __/ | | | (_| | |_| | |   | | | (_) | |_  |
7:                    | |_|   \___|_| |_|\__, |\__,_|_|   |_|_|\___/ \__| |
8:                    |                   __/ |                           |
9:                    |  GNU/Linux based |___/  Multi-Rotor UAV Autopilot |
10:                   |___________________________________________________|
11:                    
12:                   3D Vectors Implementation
13:                  
14:                   Copyright (C) 2014 Tobias Simon, Integrated Communication Systems Group, TU Ilmenau
15:                  
16:                   This program is free software; you can redistribute it and/or modify
17:                   it under the terms of the GNU General Public License as published by
18:                   the Free Software Foundation; either version 2 of the License, or
19:                   (at your option) any later version.
20:                  
21:                   This program is distributed in the hope that it will be useful,
22:                   but WITHOUT ANY WARRANTY; without even the implied warranty of
23:                   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
24:                   GNU General Public License for more details. */
25:                  
26:                  
27:                  
28:                  #include <string.h>
29:                  
30:                  #include "vec3.h"
31:                  
32:                  
33:                  void vec3_init(vec3_t *vec)
34:                  {
35:                     vec->dim = 3;
00000004  00000000   NOP
36:                     vec->ve = &vec->data[0];
00000000  00000000   NOP
0000000C  00000000   NOP
37:                     memset(vec->ve, 0, sizeof(real_t) * vec->dim);
00000010  00000000   NOP
38:                  }
39:                  
40:                  
41:                  void vec3_set(vec3_t *vec, real_t x, real_t y, real_t z)
42:                  {
43:                     vec->dim = 3;
00000004  00000000   NOP
44:                     vec->ve = &vec->data[0];
00000000  00000000   NOP
0000000C  00000000   NOP
45:                     vec->x = x;
00000010  00000000   NOP
46:                     vec->y = y;
00000014  00000000   NOP
47:                     vec->z = z;
00000018  00000000   NOP
48:                  }
49:                  
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/quat.c  ---------------
1:                   /*___________________________________________________
2:                    |  _____                       _____ _ _       _    |
3:                    | |  __ \                     |  __ (_) |     | |   |
4:                    | | |__) |__ _ __   __ _ _   _| |__) || | ___ | |_  |
5:                    | |  ___/ _ \ '_ \ / _` | | | |  ___/ | |/ _ \| __| |
6:                    | | |  |  __/ | | | (_| | |_| | |   | | | (_) | |_  |
7:                    | |_|   \___|_| |_|\__, |\__,_|_|   |_|_|\___/ \__| |
8:                    |                   __/ |                           |
9:                    |  GNU/Linux based |___/  Multi-Rotor UAV Autopilot |
10:                   |___________________________________________________|
11:                    
12:                   Quaternion Implementation
13:                  
14:                   Copyright (C) 2014 Tobias Simon, Integrated Communication Systems Group, TU Ilmenau
15:                   Most of the code was borrowed from the Internet
16:                  
17:                   This program is free software; you can redistribute it and/or modify
18:                   it under the terms of the GNU General Public License as published by
19:                   the Free Software Foundation; either version 2 of the License, or
20:                   (at your option) any later version.
21:                  
22:                   This program is distributed in the hope that it will be useful,
23:                   but WITHOUT ANY WARRANTY; without even the implied warranty of
24:                   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
25:                   GNU General Public License for more details. 
26:                   https://github.com/PenguPilot/PenguPilot/tree/master/autopilot/service/util/math
27:                   */
28:                  
29:                  
30:                  #include <string.h>
31:                  #include <math.h>
32:                  //#include <util.h>
33:                  
34:                  #include "conv.h"
35:                  #include "quat.h"
36:                  
37:                  
38:                  void quat_init(quat_t *q)
39:                  {
40:                     q->dim = 4;
00000004  00000000   NOP
41:                     q->ve = &q->data[0];
00000000  00000000   NOP
0000000C  00000000   NOP
42:                     q->x = REAL(0.0);
00000010  00000000   NOP
43:                     q->y = REAL(0.0);
00000014  00000000   NOP
44:                     q->z = REAL(1.0);
00000018  00000000   NOP
45:                     q->w = REAL(0.0);
00000024  00000000   NOP
46:                  }
47:                  
48:                  
49:                  void quat_init_data(quat_t *q, real_t x, real_t y, real_t z, real_t w)
50:                  {
00000000  00000000   NOP
51:                     q->dim = 4;
00000004  00000000   NOP
00000080  00000000   NOP
52:                     q->ve = &q->data[0];
0000000C  00000000   NOP
0000007C  00000000   NOP
00000088  00000000   NOP
53:                     q->x = x;
00000010  00000000   NOP
0000008C  00000000   NOP
54:                     q->y = y;
00000014  00000000   NOP
00000090  00000000   NOP
55:                     q->z = z;
00000018  00000000   NOP
00000094  00000000   NOP
56:                     q->w = w;
0000001C  00000000   NOP
57:                  }
58:                  
59:                  
60:                  void quat_init_axis(quat_t *q, real_t x, real_t y, real_t z, real_t a)
61:                  {
00000000  00000000   NOP
0000001C  00000000   NOP
62:                     /* see: http://www.euclideanspace.com/maths/geometry/rotations
63:                             /conversions/angleToQuaternion/index.htm */
64:                     real_t a2 = a * 0.5f;
00000020  00000000   NOP
65:                     real_t s = sin(a2);
00000030  00000000   NOP
00000048  00000000   NOP
66:                     quat_init_data(q, x * s, y * s, z * s, cos(a2));
0000004C  00000000   NOP
00000078  00000000   NOP
00000098  00000000   NOP
67:                  }
0000009C  00000000   NOP
68:                  
69:                  
70:                  void quat_init_axis_v(quat_t *q, const vec3_t *v, real_t a)
71:                  {
00000000  00000000   NOP
00000008  00000000   NOP
72:                     quat_init_axis(q, v->x, v->y, v->z, a);
0000000C  00000000   NOP
73:                  }
00000024  00000000   NOP
74:                  
75:                  
76:                  void quat_normalize(quat_t *q)
77:                  {
78:                     vec_normalize(q);
00000000  00000000   NOP
79:                  }
80:                  
81:                  
82:                  void quat_rot_vec(vec3_t *vo, const vec3_t *vi, const quat_t *q)
83:                  {
84:                     /* see: https://github.com/qsnake/ase/blob/master/ase/quaternions.py */
85:                     const real_t vx = vi->x, vy = vi->y, vz = vi->z;
00000028  00000000   NOP
00000060  00000000   NOP
86:                     const real_t qw = q->w, qx = q->x, qy = q->y, qz = q->z;
00000000  00000000   NOP
87:                     const real_t qww = qw * qw, qxx = qx * qx, qyy = qy * qy, qzz = qz * qz;
0000003C  00000000   NOP
00000050  00000000   NOP
0000006C  00000000   NOP
88:                     const real_t qwx = qw * qx, qwy = qw * qy, qwz = qw * qz, qxy = qx * qy;
00000010  00000000   NOP
00000020  00000000   NOP
89:                     const real_t qxz = qx * qz, qyz = qy * qz;
00000018  00000000   NOP
90:                     vo->x = (qww + qxx - qyy - qzz) * vx + 2 * ((qxy - qwz) * vy + (qxz + qwy) * vz);
00000030  00000000   NOP
00000044  00000000   NOP
00000054  00000000   NOP
00000068  00000000   NOP
00000070  00000000   NOP
0000007C  00000000   NOP
00000088  00000000   NOP
000000A0  00000000   NOP
000000AC  00000000   NOP
91:                     vo->y = (qww - qxx + qyy - qzz) * vy + 2 * ((qxy + qwz) * vx + (qyz - qwx) * vz);
00000034  00000000   NOP
00000048  00000000   NOP
00000058  00000000   NOP
00000064  00000000   NOP
00000074  00000000   NOP
00000080  00000000   NOP
00000090  00000000   NOP
000000A4  00000000   NOP
000000B0  00000000   NOP
92:                     vo->z = (qww - qxx - qyy + qzz) * vz + 2 * ((qxz - qwy) * vx + (qyz + qwx) * vy);
00000038  00000000   NOP
0000004C  00000000   NOP
0000005C  00000000   NOP
00000078  00000000   NOP
00000084  00000000   NOP
00000098  00000000   NOP
000000A8  00000000   NOP
000000B4  00000000   NOP
93:                  }
94:                  
95:                  
96:                  void quat_conj(quat_t *q_out, const quat_t *q_in)
97:                  {
00000000  00000000   NOP
98:                     q_out->x = -q_in->x;
00000010  00000000   NOP
00000020  00000000   NOP
99:                     q_out->y = -q_in->y;
00000004  00000000   NOP
00000018  00000000   NOP
00000024  00000000   NOP
100:                    q_out->z = -q_in->z;
00000008  00000000   NOP
0000001C  00000000   NOP
00000028  00000000   NOP
101:                    q_out->w = q_in->w;
0000000C  00000000   NOP
0000002C  00000000   NOP
102:                 }
103:                 
104:                 
105:                 void quat_to_euler(euler_t *euler, const quat_t *quat)
106:                 {
00000000  00000000   NOP
00000058  00000000   NOP
107:                    const real_t x = quat->x, y = quat->y, z = quat->z, w = quat->w;
00000030  00000000   NOP
108:                    const real_t ww = w * w, xx = x * x, yy = y * y, zz = z * z;
00000040  00000000   NOP
00000050  00000000   NOP
109:                    euler->yaw = norm_angle_0_2pi(atan2f(2.f * (x * y + z * w), xx - yy - zz + ww));
0000004C  00000000   NOP
00000060  00000000   NOP
00000080  00000000   NOP
0000008C  00000000   NOP
110:                    euler->pitch = asinf(-2.f * (x * z - y * w));
00000088  00000000   NOP
00000090  00000000   NOP
111:                    euler->roll = atan2f(2.f * (y * z + x * w), -xx - yy + zz + ww);
0000005C  00000000   NOP
000000A8  00000000   NOP
000000C0  00000000   NOP
000000F8  00000000   NOP
112:                  
113:                    /* fix for new AHRS code: */
114:                    euler->pitch *= -1.0f;
000000E0  00000000   NOP
000000F0  00000000   NOP
000000FC  00000000   NOP
115:                    euler->yaw *= -1.0f;
000000E4  00000000   NOP
000000F4  00000000   NOP
00000100  00000000   NOP
116:                    if (euler->roll < 0)
000000E8  00000000   NOP
0000010C  00000000   NOP
117:                       euler->roll += M_PI;
00000104  00000000   NOP
00000154  00000000   NOP
118:                    else
119:                       euler->roll -= M_PI;
00000114  00000000   NOP
120:                 }
00000120  00000000   NOP
00000160  00000000   NOP
121:                 
122:                 
123:                 void quat_mul(quat_t *o, const quat_t *q1, const quat_t *q2)
124:                 {
125:                    /* see: http://www.euclideanspace.com/maths/algebra/
126:                            realNormedAlgebra/quaternions/code/index.htm#mul */
127:                    o->x =  q1->x * q2->w + q1->y * q2->z - q1->z * q2->y + q1->w * q2->x;
00000000  00000000   NOP
0000002C  00000000   NOP
128:                    o->y = -q1->x * q2->z + q1->y * q2->w + q1->z * q2->x + q1->w * q2->y;
00000028  00000000   NOP
0000003C  00000000   NOP
129:                    o->z =  q1->x * q2->y - q1->y * q2->x + q1->z * q2->w + q1->w * q2->z;
00000060  00000000   NOP
00000070  00000000   NOP
00000080  00000000   NOP
130:                    o->w = -q1->x * q2->x - q1->y * q2->y - q1->z * q2->z + q1->w * q2->w;
0000006C  00000000   NOP
00000078  00000000   NOP
0000008C  00000000   NOP
131:                 }
132:                 
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/main_pic32mz_ef_sk.c  -
1:                   /*******************************************************************************
2:                     Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for a project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for a project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state
16:                      machines of all modules in the system
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                   * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
22:                   *
23:                   * Subject to your compliance with these terms, you may use Microchip software
24:                   * and any derivatives exclusively with Microchip products. It is your
25:                   * responsibility to comply with third party license terms applicable to your
26:                   * use of third party software (including open source software) that may
27:                   * accompany Microchip software.
28:                   *
29:                   * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                   * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                   * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE.
33:                   *
34:                   * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                   * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                   * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                   * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                   * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                   * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                   * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  /*
45:                   * program code and info links
46:                   * 
47:                   * https://github.com/parallaxinc/Simple-Libraries/tree/master/Learn/Simple%20Libraries/Sensor/liblsm9ds1
48:                   * https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/
49:                   * https://github.com/farrellf/Balancing_Robot_Firmware/blob/a6a2d89da8498413812b75e70234a9cc3eda72fa/Main.java
50:                   * youtube video  https://youtu.be/WqQ3HZCI3nA
51:                   */
52:                  
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  // Section: Included Files
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  
59:                  #include <stddef.h>                     // Defines NULL
60:                  #include <stdbool.h>                    // Defines true
61:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
62:                  #include "definitions.h"                // SYS function prototypes
63:                  #include "imu.h"
64:                  #include "../../../../../../Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/lsm9ds1.h"
65:                  #include "../pic32mk_mcj_curiosity_pro.X/MadgwickAHRS/MadgwickAHRS.h"
66:                  #include "../pic32mk_mcj_curiosity_pro.X/MahonyAHRS/MahonyAHRS.h"
67:                  #include "display_type.h"
68:                  #include "eadog.h" 
69:                  #include "dogm-graphic.h"
70:                  #include "OledDriver.h"
71:                  #include "OledChar.h"
72:                  #include "OledGrph.h"
73:                  
74:                  #define rps	0.0174532925f  // degrees per second -> radians per second
75:                  
76:                      // User defined constants
77:                  #define DATA_EE_SIZE        (680) // Total number of 32-bit data
78:                  #define NUM_DATA_EE_PAGES   (3) // Total number of pages reserved for the operation
79:                      
80:                      // Internal constants
81:                  #define ERASE_WRITE_CYCLE_MAX           (1000) // Maximum erase cycle per page
82:                  #define NUMBER_OF_INSTRUCTIONS_IN_PAGE  (1024) // number of 32-bit word instructions per page
83:                  #define DATA_OFFSET                     (1360) // The point where address starts
84:                  #define PIC32MX_PAGE_SIZE               (NUMBER_OF_INSTRUCTIONS_IN_PAGE*4) // Total page size in bytes
85:                  
86:                  const unsigned int eedata_addr[NUM_DATA_EE_PAGES][NUMBER_OF_INSTRUCTIONS_IN_PAGE] __attribute__ ((aligned(4096)));
87:                  const uint32_t myflash[256] __attribute__((section("myflash"), address(NVM_STARTVADDRESS), space(prog)));//= {'L', 'S', 'M', '9', 'D', 'S', '1', 0x00, 0x00};
88:                  uint32_t *pmyflash = (uint32_t *) NVM_STARTPADDRESS;
89:                  uint32_t *pmyflashr = (uint32_t *) myflash;
90:                  
91:                  const char *build_date = __DATE__, *build_time = __TIME__;
92:                  char cbuffer[256] = "\r\n parallax LSM9DS1 9-axis IMU ";
93:                  const char imu_missing[] = " MISSING \r\n";
94:                  int gx, gy, gz, ax, ay, az, mx, my, mz;
95:                  
96:                  double g[] = {0.0, 0.0, 0.0}, accel[] = {0.0, 0.0, 0.0};
97:                  
98:                  // *****************************************************************************
99:                  // *****************************************************************************
100:                 // Section: Main Entry Point
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 
104:                 int main(void)
105:                 {
9D07283C  27BDFEF0   ADDIU SP, SP, -272
9D072840  AFBF00EC   SW RA, 236(SP)
9D072844  AFBE00E8   SW FP, 232(SP)
9D072848  AFB700E4   SW S7, 228(SP)
9D07284C  AFB600E0   SW S6, 224(SP)
9D072850  AFB500DC   SW S5, 220(SP)
9D072854  AFB400D8   SW S4, 216(SP)
9D072858  AFB300D4   SW S3, 212(SP)
9D07285C  AFB200D0   SW S2, 208(SP)
9D072860  AFB100CC   SW S1, 204(SP)
9D072864  AFB000C8   SW S0, 200(SP)
9D072868  F7B60100   SDC1 F22, 256(SP)
9D07286C  F7B500F8   SDC1 F21, 248(SP)
9D072870  F7B400F0   SDC1 F20, 240(SP)
106:                 	char buffer[STR_BUF_SIZE];
107:                 
108:                 	/* Initialize all modules */
109:                 	SYS_Initialize(NULL);
9D072874  0F41E021   JAL SYS_Initialize
9D072878  00002021   ADDU A0, ZERO, ZERO
110:                 
111:                 
112:                 	/* Start system tick timer */
113:                 	CORETIMER_Start();
9D07287C  0F41E1BC   JAL CORETIMER_Start
9D072880  3C12BF86   LUI S2, -16506
114:                 
115:                 	/*
116:                 	 * setup graphics display
117:                 	 */
118:                 #ifdef EDOGS
119:                 	CSB_Set();
9D072888  24020004   ADDIU V0, ZERO, 4
9D07288C  AE420238   SW V0, 568(S2)
120:                 	CORETIMER_DelayMs(500);
9D072884  240401F4   ADDIU A0, ZERO, 500
9D072890  0F41E2F3   JAL CORETIMER_DelayMs
9D072894  3C10BF80   LUI S0, -16512
121:                 	lcd_init();
9D072898  0F41DE64   JAL lcd_init
9D07289C  00000000   NOP
122:                 	OledInit();
9D0728A0  0F41E3A2   JAL OledInit
9D0728A4  00000000   NOP
123:                 	OledSetCharUpdate(0); // manual LCD screen updates for speed
9D0728A8  0F41E47A   JAL OledSetCharUpdate
9D0728AC  00002021   ADDU A0, ZERO, ZERO
124:                 #endif
125:                 
126:                 	if (OSCCONbits.CF) { // check for sysclock proper operation
9D0728B0  8E021200   LW V0, 4608(S0)
9D0728B4  30420008   ANDI V0, V0, 8
9D0728B8  5040014C   BEQL V0, ZERO, 0x9D072DEC
9D0728BC  8F878034   LW A3, -32716(GP)
127:                 		sprintf(buffer, "IMU Clock Error");
9D0728C0  3C039D07   LUI V1, -25337
9D0728C4  24626CF8   ADDIU V0, V1, 27896
9D0728C8  8C686CF8   LW T0, 27896(V1)
9D0728CC  8C470004   LW A3, 4(V0)
9D0728D0  8C430008   LW V1, 8(V0)
9D0728D4  8C42000C   LW V0, 12(V0)
9D0728E8  AFA80028   SW T0, 40(SP)
9D0728EC  AFA7002C   SW A3, 44(SP)
9D0728F0  AFA30030   SW V1, 48(SP)
128:                 		eaDogM_WriteStringAtPos(0, 0, buffer);
9D0728D8  27B10028   ADDIU S1, SP, 40
9D0728DC  02203021   ADDU A2, S1, ZERO
9D0728E0  00002021   ADDU A0, ZERO, ZERO
9D0728E4  00002821   ADDU A1, ZERO, ZERO
9D0728F4  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D0728F8  AFA20034   SW V0, 52(SP)
129:                 		sprintf(buffer, "Clock Status %04x", CLKSTAT);
9D0728FC  8E061390   LW A2, 5008(S0)
9D072900  02202021   ADDU A0, S1, ZERO
9D072904  3C059D07   LUI A1, -25337
9D072908  0F41E224   JAL _sprintf_cdfFnopsuxX
9D07290C  24A56D08   ADDIU A1, A1, 27912
130:                 		eaDogM_WriteStringAtPos(1, 0, buffer);
9D072910  24040001   ADDIU A0, ZERO, 1
9D072914  00002821   ADDU A1, ZERO, ZERO
9D072918  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D07291C  02203021   ADDU A2, S1, ZERO
131:                 		OledUpdate();
9D072920  0F41E23E   JAL OledUpdate
9D072924  00000000   NOP
132:                 		CORETIMER_DelayMs(5000);
9D072928  0F41E2F3   JAL CORETIMER_DelayMs
9D07292C  24041388   ADDIU A0, ZERO, 5000
133:                 	} else {
134:                 		sprintf(buffer, "IMU %s %s", build_date, build_time);
9D072DEC  8F868038   LW A2, -32712(GP)
9D072DF0  27B10028   ADDIU S1, SP, 40
9D072DF4  02202021   ADDU A0, S1, ZERO
9D072DF8  3C059D07   LUI A1, -25337
9D072DFC  0F41E224   JAL _sprintf_cdfFnopsuxX
9D072E00  24A56D1C   ADDIU A1, A1, 27932
135:                 		eaDogM_WriteStringAtPos(0, 0, buffer);
9D072E04  00002021   ADDU A0, ZERO, ZERO
9D072E08  00002821   ADDU A1, ZERO, ZERO
9D072E0C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072E10  02203021   ADDU A2, S1, ZERO
136:                 		sprintf(buffer, "%s", VERSION);
9D072E14  3C039D07   LUI V1, -25337
9D072E18  24626D28   ADDIU V0, V1, 27944
9D072E1C  8C6B6D28   LW T3, 27944(V1)
9D072E20  8C4A0004   LW T2, 4(V0)
9D072E24  8C490008   LW T1, 8(V0)
9D072E28  8C48000C   LW T0, 12(V0)
9D072E2C  8C470010   LW A3, 16(V0)
9D072E30  8C430014   LW V1, 20(V0)
9D072E34  94420018   LHU V0, 24(V0)
9D072E44  AFAB0028   SW T3, 40(SP)
9D072E48  AFAA002C   SW T2, 44(SP)
9D072E4C  AFA90030   SW T1, 48(SP)
9D072E50  AFA80034   SW T0, 52(SP)
9D072E54  AFA70038   SW A3, 56(SP)
9D072E58  AFA3003C   SW V1, 60(SP)
137:                 		eaDogM_WriteStringAtPos(1, 0, buffer);
9D072E38  24040001   ADDIU A0, ZERO, 1
9D072E3C  00002821   ADDU A1, ZERO, ZERO
9D072E40  02203021   ADDU A2, S1, ZERO
9D072E5C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072E60  A7A20040   SH V0, 64(SP)
138:                 		OledUpdate();
9D072E64  0F41E23E   JAL OledUpdate
9D072E68  3C108000   LUI S0, -32768
139:                 		CORETIMER_DelayMs(500);
9D072E6C  0F41E2F3   JAL CORETIMER_DelayMs
9D072E70  240401F4   ADDIU A0, ZERO, 500
9D072E74  0B41CA4D   J 0x9D072934
9D072E78  00000000   NOP
140:                 	}
141:                 	/*
142:                 	 * talk to the parallax LSM9DS1 9-axis IMU
143:                 	 */
144:                 
145:                 	UART1_Write((uint8_t *) cbuffer, strlen(cbuffer));
9D072930  3C108000   LUI S0, -32768
9D072934  0F41D8F5   JAL .LFE0, strlen
9D072938  260417C0   ADDIU A0, S0, 6080
9D07293C  00402821   ADDU A1, V0, ZERO
9D072940  0F41E0DD   JAL UART1_Write
9D072944  260417C0   ADDIU A0, S0, 6080
146:                 	if (!imu_init(1, 2, 3, 4)) {
9D072948  24040001   ADDIU A0, ZERO, 1
9D07294C  24050002   ADDIU A1, ZERO, 2
9D072950  24060003   ADDIU A2, ZERO, 3
9D072954  0F41CF75   JAL imu_init
9D072958  24070004   ADDIU A3, ZERO, 4
9D07295C  144000C2   BNE V0, ZERO, 0x9D072C68
9D072960  3C039D07   LUI V1, -25337
147:                 		// Trouble in River-City, not talking to the IMU
148:                 		UART1_Write((uint8_t *) imu_missing, strlen(imu_missing));
9D072964  3C049D08   LUI A0, -25336
9D072968  248491DC   ADDIU A0, A0, -28196
9D07296C  0F41E0DD   JAL UART1_Write
9D072970  2405000B   ADDIU A1, ZERO, 11
149:                 		sprintf(buffer, "IMU SPI init error.");
9D072974  3C039D07   LUI V1, -25337
9D072978  24626D44   ADDIU V0, V1, 27972
9D07297C  8C696D44   LW T1, 27972(V1)
9D072980  8C480004   LW T0, 4(V0)
9D072984  8C470008   LW A3, 8(V0)
9D072988  8C43000C   LW V1, 12(V0)
9D07298C  8C420010   LW V0, 16(V0)
9D07299C  AFA90028   SW T1, 40(SP)
9D0729A0  AFA8002C   SW T0, 44(SP)
9D0729A4  AFA70030   SW A3, 48(SP)
9D0729A8  AFA30034   SW V1, 52(SP)
150:                 		eaDogM_WriteStringAtPos(2, 0, buffer);
9D072990  24040002   ADDIU A0, ZERO, 2
9D072994  00002821   ADDU A1, ZERO, ZERO
9D072998  02203021   ADDU A2, S1, ZERO
9D0729AC  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D0729B0  AFA20038   SW V0, 56(SP)
151:                 		OledUpdate();
9D0729B4  0F41E23E   JAL OledUpdate
9D0729B8  00000000   NOP
9D0729BC  3C029D07   LUI V0, -25337
152:                 	} else {
153:                 		sprintf(buffer, "IMU SPI init complete.");
9D072C68  24626D58   ADDIU V0, V1, 27992
9D072C6C  8C6B6D58   LW T3, 27992(V1)
9D072C70  8C4A0004   LW T2, 4(V0)
9D072C74  8C490008   LW T1, 8(V0)
9D072C78  8C48000C   LW T0, 12(V0)
9D072C7C  8C470010   LW A3, 16(V0)
9D072C80  94430014   LHU V1, 20(V0)
9D072C84  90420016   LBU V0, 22(V0)
9D072C94  AFAB0028   SW T3, 40(SP)
9D072C98  AFAA002C   SW T2, 44(SP)
9D072C9C  AFA90030   SW T1, 48(SP)
9D072CA0  AFA80034   SW T0, 52(SP)
9D072CA4  AFA70038   SW A3, 56(SP)
9D072CA8  A7A3003C   SH V1, 60(SP)
154:                 		eaDogM_WriteStringAtPos(2, 0, buffer);
9D072C88  24040002   ADDIU A0, ZERO, 2
9D072C8C  00002821   ADDU A1, ZERO, ZERO
9D072C90  02203021   ADDU A2, S1, ZERO
9D072CAC  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072CB0  A3A2003E   SB V0, 62(SP)
155:                 		OledUpdate();
9D072CB4  0F41E23E   JAL OledUpdate
9D072CB8  00000000   NOP
156:                 		if (SWITCH_Get()) {
9D072CBC  8E420120   LW V0, 288(S2)
9D072CC0  7C420200   EXT V0, V0, 8, 1
9D072CC4  5040FF3E   BEQL V0, ZERO, 0x9D0729C0
9D072CC8  3C029D07   LUI V0, -25337
157:                 			sprintf(buffer, "IMU calibration starting.");
9D072CCC  3C039D07   LUI V1, -25337
9D072CD0  24626D70   ADDIU V0, V1, 28016
9D072CD4  8C6B6D70   LW T3, 28016(V1)
9D072CD8  8C4A0004   LW T2, 4(V0)
9D072CDC  8C490008   LW T1, 8(V0)
9D072CE0  8C48000C   LW T0, 12(V0)
9D072CE4  8C470010   LW A3, 16(V0)
9D072CE8  8C430014   LW V1, 20(V0)
9D072CEC  94420018   LHU V0, 24(V0)
9D072CFC  AFAB0028   SW T3, 40(SP)
9D072D00  AFAA002C   SW T2, 44(SP)
9D072D04  AFA90030   SW T1, 48(SP)
9D072D08  AFA80034   SW T0, 52(SP)
9D072D0C  AFA70038   SW A3, 56(SP)
9D072D10  AFA3003C   SW V1, 60(SP)
158:                 			eaDogM_WriteStringAtPos(3, 0, buffer);
9D072CF0  24040003   ADDIU A0, ZERO, 3
9D072CF4  00002821   ADDU A1, ZERO, ZERO
9D072CF8  02203021   ADDU A2, S1, ZERO
9D072D14  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072D18  A7A20040   SH V0, 64(SP)
159:                 			OledUpdate();
9D072D1C  0F41E23E   JAL OledUpdate
9D072D20  00000000   NOP
160:                 			imu_calibrateAG();
9D072D24  0F41D0FC   JAL imu_calibrateAG
9D072D28  00000000   NOP
161:                 			sprintf(buffer, "IMU AG done. Starting Mag");
9D072D2C  3C039D07   LUI V1, -25337
9D072D30  24626D8C   ADDIU V0, V1, 28044
9D072D34  8C6B6D8C   LW T3, 28044(V1)
9D072D38  8C4A0004   LW T2, 4(V0)
9D072D3C  8C490008   LW T1, 8(V0)
9D072D40  8C48000C   LW T0, 12(V0)
9D072D44  8C470010   LW A3, 16(V0)
9D072D48  8C430014   LW V1, 20(V0)
9D072D4C  94420018   LHU V0, 24(V0)
9D072D5C  AFAB0028   SW T3, 40(SP)
9D072D60  AFAA002C   SW T2, 44(SP)
9D072D64  AFA90030   SW T1, 48(SP)
9D072D68  AFA80034   SW T0, 52(SP)
9D072D6C  AFA70038   SW A3, 56(SP)
9D072D70  AFA3003C   SW V1, 60(SP)
162:                 			eaDogM_WriteStringAtPos(4, 0, buffer);
9D072D50  24040004   ADDIU A0, ZERO, 4
9D072D54  00002821   ADDU A1, ZERO, ZERO
9D072D58  02203021   ADDU A2, S1, ZERO
9D072D74  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072D78  A7A20040   SH V0, 64(SP)
163:                 			OledUpdate();
9D072D7C  0F41E23E   JAL OledUpdate
9D072D80  00000000   NOP
164:                 			//			imu_calibrateMag();
165:                 			sprintf(buffer, "IMU Mag cal done. IMU ready.");
9D072D84  3C039D07   LUI V1, -25337
9D072D88  24626DA8   ADDIU V0, V1, 28072
9D072D8C  8C6C6DA8   LW T4, 28072(V1)
9D072D90  8C4B0004   LW T3, 4(V0)
9D072D94  8C4A0008   LW T2, 8(V0)
9D072D98  8C49000C   LW T1, 12(V0)
9D072D9C  8C480010   LW T0, 16(V0)
9D072DA0  8C470014   LW A3, 20(V0)
9D072DA4  8C430018   LW V1, 24(V0)
9D072DA8  9042001C   LBU V0, 28(V0)
9D072DB8  AFAC0028   SW T4, 40(SP)
9D072DBC  AFAB002C   SW T3, 44(SP)
9D072DC0  AFAA0030   SW T2, 48(SP)
9D072DC4  AFA90034   SW T1, 52(SP)
9D072DC8  AFA80038   SW T0, 56(SP)
9D072DCC  AFA7003C   SW A3, 60(SP)
9D072DD0  AFA30040   SW V1, 64(SP)
166:                 			eaDogM_WriteStringAtPos(5, 0, buffer);
9D072DAC  24040005   ADDIU A0, ZERO, 5
9D072DB0  00002821   ADDU A1, ZERO, ZERO
9D072DB4  02203021   ADDU A2, S1, ZERO
9D072DD4  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072DD8  A3A20044   SB V0, 68(SP)
167:                 			OledUpdate();
9D072DDC  0F41E23E   JAL OledUpdate
9D072DE0  00000000   NOP
9D072DE4  0B41CA70   J 0x9D0729C0
9D072DE8  3C029D07   LUI V0, -25337
168:                 		}
169:                 	};
170:                 
171:                 	while (true) {
172:                 		dtog_Set();
9D0729EC  24140010   ADDIU S4, ZERO, 16
9D072C04  AE540038   SW S4, 56(S2)
173:                 		if (imu_gyroAvailable()) imu_readGyro(&gx, &gy, &gz);
9D072C08  0F41E3E2   JAL imu_gyroAvailable
9D072C0C  00000000   NOP
9D072C10  1040FF79   BEQ V0, ZERO, 0x9D0729F8
9D072C14  278480B4   ADDIU A0, GP, -32588
9D072C18  278580B8   ADDIU A1, GP, -32584
9D072C1C  0F41DF0A   JAL imu_readGyro
9D072C20  278680B0   ADDIU A2, GP, -32592
174:                 		if (imu_accelAvailable()) imu_readAccel(&ax, &ay, &az);
9D0729F8  0F41E3CA   JAL imu_accelAvailable
9D0729FC  00000000   NOP
9D072A00  1440008C   BNE V0, ZERO, 0x9D072C34
9D072A04  278480CC   ADDIU A0, GP, -32564
9D072C24  0F41E3CA   JAL imu_accelAvailable
9D072C28  00000000   NOP
9D072C2C  1040FF76   BEQ V0, ZERO, 0x9D072A08
9D072C30  278480CC   ADDIU A0, GP, -32564
9D072C34  278580C4   ADDIU A1, GP, -32572
9D072C38  0F41DED4   JAL imu_readAccel
9D072C3C  278680C8   ADDIU A2, GP, -32568
175:                 		if (imu_magAvailable()) imu_readMag(&mx, &my, &mz);
9D072A08  0F41E3D6   JAL imu_magAvailable
9D072A0C  00000000   NOP
9D072A10  54400090   BNEL V0, ZERO, 0x9D072C54
9D072A14  278480BC   ADDIU A0, GP, -32580
9D072C40  0F41E3D6   JAL imu_magAvailable
9D072C44  00000000   NOP
9D072C48  5040FF74   BEQL V0, ZERO, 0x9D072A1C
9D072C4C  C78080B4   LWC1 F0, -32588(GP)
9D072C50  278480BC   ADDIU A0, GP, -32580
9D072C54  278580C0   ADDIU A1, GP, -32576
9D072C58  0F41E071   JAL imu_readMag
9D072C5C  278680D0   ADDIU A2, GP, -32560
176:                 		/* Toggle LED after every 1s */
177:                 		/*
178:                 		 * GYRO data must be in radians per second
179:                 		 */
180:                 		MadgwickAHRSupdate((float) gx*rps, (float) gy*rps, (float) gz*rps, (float) ax, (float) ay, (float) az, (float) mx, (float) my, (float) mz);
9D0729C0  C4556E10   LWC1 F21, 28176(V0)
9D072A18  C78080B4   LWC1 F0, -32588(GP)
9D072A1C  46800320   CVT.S.W F12, F0
9D072A20  C78180B8   LWC1 F1, -32584(GP)
9D072A24  46800BA0   CVT.S.W F14, F1
9D072A28  C78580B0   LWC1 F5, -32592(GP)
9D072A2C  46802960   CVT.S.W F5, F5
9D072A30  46156302   MUL.S F12, F12, F21
9D072A34  46157382   MUL.S F14, F14, F21
9D072A38  46152802   MUL.S F0, F5, F21
9D072A3C  44060000   MFC1 A2, F0
9D072A40  C78180C4   LWC1 F1, -32572(GP)
9D072A44  46800920   CVT.S.W F4, F1
9D072A48  C78580C8   LWC1 F5, -32568(GP)
9D072A4C  468028E0   CVT.S.W F3, F5
9D072A50  C78080BC   LWC1 F0, -32580(GP)
9D072A54  468000A0   CVT.S.W F2, F0
9D072A58  C78580C0   LWC1 F5, -32576(GP)
9D072A5C  46802860   CVT.S.W F1, F5
9D072A60  C78580D0   LWC1 F5, -32560(GP)
9D072A64  46802820   CVT.S.W F0, F5
9D072A68  C78580CC   LWC1 F5, -32564(GP)
9D072A6C  46802960   CVT.S.W F5, F5
9D072A70  44072800   MFC1 A3, F5
9D072A74  E7A40010   SWC1 F4, 16(SP)
9D072A78  E7A30014   SWC1 F3, 20(SP)
9D072A7C  E7A20018   SWC1 F2, 24(SP)
9D072A80  E7A1001C   SWC1 F1, 28(SP)
9D072A84  0F41C666   JAL MadgwickAHRSupdate
9D072A88  E7A00020   SWC1 F0, 32(SP)
9D072C60  0B41CA87   J 0x9D072A1C
9D072C64  C78080B4   LWC1 F0, -32588(GP)
181:                 		//MahonyAHRSupdate((float) gx*rps, (float) gy*rps, (float) gz*rps, (float) ax, (float) ay, (float) az, (float) mx, (float) my, (float) mz);
182:                 		/*
183:                 		 * linear acceleration without gravity
184:                 		 * rotate vector to earth
185:                 		 */
186:                 		g[0] = 2.0 * (q1 * q3 - q0 * q2);
9D072AB0  C7848068   LWC1 F4, -32664(GP)
9D072AB4  C78C8060   LWC1 F12, -32672(GP)
9D072AB8  C7908024   LWC1 F16, -32732(GP)
9D072ABC  C78B8064   LWC1 F11, -32668(GP)
9D072AEC  460B82C2   MUL.S F11, F16, F11
9D072B08  4D6C2128   MSUB.S F4, F11, F4, F12
9D072B24  46002121   CVT.D.S F4, F4
9D072B2C  46242100   ADD.D F4, F4, F4
9D072B84  F6C41B38   SDC1 F4, 6968(S6)
187:                 		g[1] = 2.0 * (q0 * q1 + q2 * q3);
9D072AC0  C7828024   LWC1 F2, -32732(GP)
9D072AC4  C7898068   LWC1 F9, -32664(GP)
9D072AC8  C78F8064   LWC1 F15, -32668(GP)
9D072ACC  C7878060   LWC1 F7, -32672(GP)
9D072AF0  460779C2   MUL.S F7, F15, F7
9D072B0C  4CE910A0   MADD.S F2, F7, F2, F9
9D072B28  460010A1   CVT.D.S F2, F2
9D072B34  46221080   ADD.D F2, F2, F2
9D072B88  F6A20008   SDC1 F2, 8(S5)
188:                 		g[2] = q0 * q0 - q1 * q1 - q2 * q2 + q3 * q3;
9D072AD0  C7818024   LWC1 F1, -32732(GP)
9D072AD4  C78E8024   LWC1 F14, -32732(GP)
9D072AD8  C78D8068   LWC1 F13, -32664(GP)
9D072ADC  C7808068   LWC1 F0, -32664(GP)
9D072AE0  C7858064   LWC1 F5, -32668(GP)
9D072AE4  C7838064   LWC1 F3, -32668(GP)
9D072AE8  46006B42   MUL.S F13, F13, F0
9D072AF4  46032942   MUL.S F5, F5, F3
9D072AF8  C7808060   LWC1 F0, -32672(GP)
9D072AFC  C7838060   LWC1 F3, -32672(GP)
9D072B04  4DAE0868   MSUB.S F1, F13, F1, F14
9D072B20  46050841   SUB.S F1, F1, F5
9D072B30  4C230020   MADD.S F0, F1, F0, F3
9D072B4C  46000021   CVT.D.S F0, F0
9D072B8C  F6A00010   SDC1 F0, 16(S5)
189:                 
190:                 		/*
191:                 		 * compensate accelerometer readings with the expected direction of gravity 
192:                 		 * https://diydrones.com/forum/topics/accelerometer-sensor-gravity-compensation
193:                 		 */
194:                 		accel[0] = ((double) ax / 5020.0 - g[0])*9.8;
9D0729C4  3C029D07   LUI V0, -25337
9D0729C8  D4566E18   LDC1 F22, 28184(V0)
9D0729CC  3C029D07   LUI V0, -25337
9D0729D0  D4546E20   LDC1 F20, 28192(V0)
9D0729D4  3C168000   LUI S6, -32768
9D0729D8  3C138000   LUI S3, -32768
9D0729DC  26D51B38   ADDIU S5, S6, 6968
9D0729E0  26711B20   ADDIU S1, S3, 6944
9D0729E4  3C1E9D07   LUI FP, -25337
9D0729E8  3C179D07   LUI S7, -25337
9D072A8C  C78080CC   LWC1 F0, -32564(GP)
9D072A90  468002A1   CVT.D.W F10, F0
9D072AA4  46365283   DIV.D F10, F10, F22
9D072B3C  46245281   SUB.D F10, F10, F4
9D072B54  46345282   MUL.D F10, F10, F20
9D072B90  F66A1B20   SDC1 F10, 6944(S3)
195:                 		accel[1] = ((double) ay / 5020.0 - g[1])*9.8;
9D072A94  C78180C4   LWC1 F1, -32572(GP)
9D072A98  46800A21   CVT.D.W F8, F1
9D072AA8  46364203   DIV.D F8, F8, F22
9D072B44  46224201   SUB.D F8, F8, F2
9D072B58  46344202   MUL.D F8, F8, F20
9D072B94  F6280008   SDC1 F8, 8(S1)
196:                 		accel[2] = ((double) az / 5020.0 - g[2])*9.8;
9D072A9C  C78580C8   LWC1 F5, -32568(GP)
9D072AA0  468029A1   CVT.D.W F6, F5
9D072AAC  46363183   DIV.D F6, F6, F22
9D072B50  46203181   SUB.D F6, F6, F0
9D072B6C  46343182   MUL.D F6, F6, F20
197:                 		dtog_Clear();
9D072B00  AE540034   SW S4, 52(S2)
198:                 		//		sprintf(cbuffer, "Gyro %6d %6d %6d Accel %6d %6d %6d Mag %6d %6d %6d \r\n", gx, gy, gz, ax, ay, az, mx, my, mz);
199:                 		//		UART1_Write((uint8_t *) cbuffer, strlen(cbuffer));
200:                 		sprintf(cbuffer, "%2.7f %2.7f %2.7f %2.7f ", q0, q1, q2, q3);
9D0729F0  0B41CB01   J .LVL37
9D0729F4  261017C0   ADDIU S0, S0, 6080
9D072B10  8F868024   LW A2, -32732(GP)
9D072B14  C7908068   LWC1 F16, -32664(GP)
9D072B18  C78E8064   LWC1 F14, -32668(GP)
9D072B1C  C78C8060   LWC1 F12, -32672(GP)
9D072B38  46008421   CVT.D.S F16, F16
9D072B40  460073A1   CVT.D.S F14, F14
9D072B48  46006321   CVT.D.S F12, F12
9D072B5C  44860800   MTC1 A2, F1
9D072B60  46000861   CVT.D.S F1, F1
9D072B64  44060800   MFC1 A2, F1
9D072B68  44670800   MFHC1 A3, F1
9D072B70  27C56DC8   ADDIU A1, FP, 28104
9D072B74  F7B00010   SDC1 F16, 16(SP)
9D072B78  F7AE0018   SDC1 F14, 24(SP)
9D072B7C  F7AC0020   SDC1 F12, 32(SP)
9D072B80  02002021   ADDU A0, S0, ZERO
9D072B98  0F41E224   JAL _sprintf_cdfFnopsuxX
9D072B9C  F6260010   SDC1 F6, 16(S1)
201:                 		UART1_Write((uint8_t *) cbuffer, strlen(cbuffer));
9D072BA0  0F41D8F5   JAL .LFE0, strlen
9D072BA4  02002021   ADDU A0, S0, ZERO
9D072BA8  02002021   ADDU A0, S0, ZERO
9D072BAC  0F41E0DD   JAL UART1_Write
9D072BB0  00402821   ADDU A1, V0, ZERO
202:                 		sprintf(cbuffer, "%3.2f %3.2f %3.2f\n\r", accel[0], accel[1], accel[2]);
9D072BB4  D6621B20   LDC1 F2, 6944(S3)
9D072BB8  D6210008   LDC1 F1, 8(S1)
9D072BBC  D6200010   LDC1 F0, 16(S1)
9D072BC0  44061000   MFC1 A2, F2
9D072BC4  44671000   MFHC1 A3, F2
9D072BC8  26E56DE4   ADDIU A1, S7, 28132
9D072BCC  F7A10010   SDC1 F1, 16(SP)
9D072BD0  F7A00018   SDC1 F0, 24(SP)
9D072BD4  0F41E224   JAL _sprintf_cdfFnopsuxX
9D072BD8  02002021   ADDU A0, S0, ZERO
203:                 		UART1_Write((uint8_t *) cbuffer, strlen(cbuffer));
9D072BDC  0F41D8F5   JAL .LFE0, strlen
9D072BE0  02002021   ADDU A0, S0, ZERO
9D072BE4  02002021   ADDU A0, S0, ZERO
9D072BE8  0F41E0DD   JAL UART1_Write
9D072BEC  00402821   ADDU A1, V0, ZERO
204:                 		//		sprintf(cbuffer, "Linear R acceleration %5.2f %5.2f %5.2f: %5.2f %5.2f %5.2f\n\r", (double) ax, (double) ay, (double) az, accel[0], accel[1], accel[2]);
205:                 		//		UART1_Write((uint8_t *) cbuffer, strlen(cbuffer));
206:                 		LED_Toggle();
9D072BF4  24020400   ADDIU V0, ZERO, 1024
9D072BF8  AE42003C   SW V0, 60(S2)
207:                 		CORETIMER_DelayMs(100); // 10 Hz updates
9D072BF0  24040064   ADDIU A0, ZERO, 100
9D072BFC  0F41E2F3   JAL CORETIMER_DelayMs
9D072C00  00000000   NOP
9D072C04  AE540038   SW S4, 56(S2)
9D072C08  0F41E3E2   JAL imu_gyroAvailable
9D072C0C  00000000   NOP
9D072C10  1040FF79   BEQ V0, ZERO, 0x9D0729F8
9D072C14  278480B4   ADDIU A0, GP, -32588
9D072C18  278580B8   ADDIU A1, GP, -32584
9D072C1C  0F41DF0A   JAL imu_readGyro
9D072C20  278680B0   ADDIU A2, GP, -32592
9D072C24  0F41E3CA   JAL imu_accelAvailable
9D072C28  00000000   NOP
9D072C2C  1040FF76   BEQ V0, ZERO, 0x9D072A08
9D072C30  278480CC   ADDIU A0, GP, -32564
9D072C34  278580C4   ADDIU A1, GP, -32572
9D072C38  0F41DED4   JAL imu_readAccel
9D072C3C  278680C8   ADDIU A2, GP, -32568
9D072C40  0F41E3D6   JAL imu_magAvailable
9D072C44  00000000   NOP
9D072C48  5040FF74   BEQL V0, ZERO, 0x9D072A1C
9D072C4C  C78080B4   LWC1 F0, -32588(GP)
9D072C50  278480BC   ADDIU A0, GP, -32580
9D072C54  278580C0   ADDIU A1, GP, -32576
9D072C58  0F41E071   JAL imu_readMag
9D072C5C  278680D0   ADDIU A2, GP, -32560
9D072C60  0B41CA87   J 0x9D072A1C
9D072C64  C78080B4   LWC1 F0, -32588(GP)
9D072C68  24626D58   ADDIU V0, V1, 27992
9D072C6C  8C6B6D58   LW T3, 27992(V1)
9D072C70  8C4A0004   LW T2, 4(V0)
9D072C74  8C490008   LW T1, 8(V0)
9D072C78  8C48000C   LW T0, 12(V0)
9D072C7C  8C470010   LW A3, 16(V0)
9D072C80  94430014   LHU V1, 20(V0)
9D072C84  90420016   LBU V0, 22(V0)
9D072C88  24040002   ADDIU A0, ZERO, 2
9D072C8C  00002821   ADDU A1, ZERO, ZERO
9D072C90  02203021   ADDU A2, S1, ZERO
9D072C94  AFAB0028   SW T3, 40(SP)
9D072C98  AFAA002C   SW T2, 44(SP)
9D072C9C  AFA90030   SW T1, 48(SP)
9D072CA0  AFA80034   SW T0, 52(SP)
9D072CA4  AFA70038   SW A3, 56(SP)
9D072CA8  A7A3003C   SH V1, 60(SP)
9D072CAC  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072CB0  A3A2003E   SB V0, 62(SP)
9D072CB4  0F41E23E   JAL OledUpdate
9D072CB8  00000000   NOP
9D072CBC  8E420120   LW V0, 288(S2)
9D072CC0  7C420200   EXT V0, V0, 8, 1
9D072CC4  5040FF3E   BEQL V0, ZERO, 0x9D0729C0
9D072CC8  3C029D07   LUI V0, -25337
9D072CCC  3C039D07   LUI V1, -25337
9D072CD0  24626D70   ADDIU V0, V1, 28016
9D072CD4  8C6B6D70   LW T3, 28016(V1)
9D072CD8  8C4A0004   LW T2, 4(V0)
9D072CDC  8C490008   LW T1, 8(V0)
9D072CE0  8C48000C   LW T0, 12(V0)
9D072CE4  8C470010   LW A3, 16(V0)
9D072CE8  8C430014   LW V1, 20(V0)
9D072CEC  94420018   LHU V0, 24(V0)
9D072CF0  24040003   ADDIU A0, ZERO, 3
9D072CF4  00002821   ADDU A1, ZERO, ZERO
9D072CF8  02203021   ADDU A2, S1, ZERO
9D072CFC  AFAB0028   SW T3, 40(SP)
9D072D00  AFAA002C   SW T2, 44(SP)
9D072D04  AFA90030   SW T1, 48(SP)
9D072D08  AFA80034   SW T0, 52(SP)
9D072D0C  AFA70038   SW A3, 56(SP)
9D072D10  AFA3003C   SW V1, 60(SP)
9D072D14  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072D18  A7A20040   SH V0, 64(SP)
9D072D1C  0F41E23E   JAL OledUpdate
9D072D20  00000000   NOP
9D072D24  0F41D0FC   JAL imu_calibrateAG
9D072D28  00000000   NOP
9D072D2C  3C039D07   LUI V1, -25337
9D072D30  24626D8C   ADDIU V0, V1, 28044
9D072D34  8C6B6D8C   LW T3, 28044(V1)
9D072D38  8C4A0004   LW T2, 4(V0)
9D072D3C  8C490008   LW T1, 8(V0)
9D072D40  8C48000C   LW T0, 12(V0)
9D072D44  8C470010   LW A3, 16(V0)
9D072D48  8C430014   LW V1, 20(V0)
9D072D4C  94420018   LHU V0, 24(V0)
9D072D50  24040004   ADDIU A0, ZERO, 4
9D072D54  00002821   ADDU A1, ZERO, ZERO
9D072D58  02203021   ADDU A2, S1, ZERO
9D072D5C  AFAB0028   SW T3, 40(SP)
9D072D60  AFAA002C   SW T2, 44(SP)
9D072D64  AFA90030   SW T1, 48(SP)
9D072D68  AFA80034   SW T0, 52(SP)
9D072D6C  AFA70038   SW A3, 56(SP)
9D072D70  AFA3003C   SW V1, 60(SP)
9D072D74  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072D78  A7A20040   SH V0, 64(SP)
9D072D7C  0F41E23E   JAL OledUpdate
9D072D80  00000000   NOP
9D072D84  3C039D07   LUI V1, -25337
9D072D88  24626DA8   ADDIU V0, V1, 28072
9D072D8C  8C6C6DA8   LW T4, 28072(V1)
9D072D90  8C4B0004   LW T3, 4(V0)
9D072D94  8C4A0008   LW T2, 8(V0)
9D072D98  8C49000C   LW T1, 12(V0)
9D072D9C  8C480010   LW T0, 16(V0)
9D072DA0  8C470014   LW A3, 20(V0)
9D072DA4  8C430018   LW V1, 24(V0)
9D072DA8  9042001C   LBU V0, 28(V0)
9D072DAC  24040005   ADDIU A0, ZERO, 5
9D072DB0  00002821   ADDU A1, ZERO, ZERO
9D072DB4  02203021   ADDU A2, S1, ZERO
9D072DB8  AFAC0028   SW T4, 40(SP)
9D072DBC  AFAB002C   SW T3, 44(SP)
9D072DC0  AFAA0030   SW T2, 48(SP)
9D072DC4  AFA90034   SW T1, 52(SP)
9D072DC8  AFA80038   SW T0, 56(SP)
9D072DCC  AFA7003C   SW A3, 60(SP)
9D072DD0  AFA30040   SW V1, 64(SP)
9D072DD4  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072DD8  A3A20044   SB V0, 68(SP)
9D072DDC  0F41E23E   JAL OledUpdate
9D072DE0  00000000   NOP
9D072DE4  0B41CA70   J 0x9D0729C0
9D072DE8  3C029D07   LUI V0, -25337
9D072DEC  8F868038   LW A2, -32712(GP)
9D072DF0  27B10028   ADDIU S1, SP, 40
9D072DF4  02202021   ADDU A0, S1, ZERO
9D072DF8  3C059D07   LUI A1, -25337
9D072DFC  0F41E224   JAL _sprintf_cdfFnopsuxX
9D072E00  24A56D1C   ADDIU A1, A1, 27932
9D072E04  00002021   ADDU A0, ZERO, ZERO
9D072E08  00002821   ADDU A1, ZERO, ZERO
9D072E0C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072E10  02203021   ADDU A2, S1, ZERO
9D072E14  3C039D07   LUI V1, -25337
9D072E18  24626D28   ADDIU V0, V1, 27944
9D072E1C  8C6B6D28   LW T3, 27944(V1)
9D072E20  8C4A0004   LW T2, 4(V0)
9D072E24  8C490008   LW T1, 8(V0)
9D072E28  8C48000C   LW T0, 12(V0)
9D072E2C  8C470010   LW A3, 16(V0)
9D072E30  8C430014   LW V1, 20(V0)
9D072E34  94420018   LHU V0, 24(V0)
9D072E38  24040001   ADDIU A0, ZERO, 1
9D072E3C  00002821   ADDU A1, ZERO, ZERO
9D072E40  02203021   ADDU A2, S1, ZERO
9D072E44  AFAB0028   SW T3, 40(SP)
9D072E48  AFAA002C   SW T2, 44(SP)
9D072E4C  AFA90030   SW T1, 48(SP)
9D072E50  AFA80034   SW T0, 52(SP)
9D072E54  AFA70038   SW A3, 56(SP)
9D072E58  AFA3003C   SW V1, 60(SP)
9D072E5C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D072E60  A7A20040   SH V0, 64(SP)
9D072E64  0F41E23E   JAL OledUpdate
9D072E68  3C108000   LUI S0, -32768
9D072E6C  0F41E2F3   JAL CORETIMER_DelayMs
9D072E70  240401F4   ADDIU A0, ZERO, 500
9D072E74  0B41CA4D   J 0x9D072934
9D072E78  00000000   NOP
208:                 	}
209:                 
210:                 	/* Execution should not come here during normal operation */
211:                 
212:                 	return( EXIT_FAILURE);
213:                 }
214:                 
215:                 static void NVMInitiateOperation(void)
216:                 {
217:                 	unsigned int saved_state;
218:                 	int dma_susp; // storage for current DMA state
219:                 
220:                 	saved_state = __builtin_get_isr_state();
9D076F84  40026000   MFC0 V0, Status
9D076F88  00022A82   SRL A1, V0, 10
9D076F8C  7C4518C4   INS A1, V0, 3, 1
9D076F90  30A5000F   ANDI A1, A1, 15
221:                 	__builtin_disable_interrupts();
9D076F94  41626000   DI V0
9D076F98  000000C0   EHB
222:                 	// Disable DMA
223:                 	if (!(dma_susp = DMACONbits.SUSPEND)) {
9D076F9C  3C04BF81   LUI A0, -16511
9D076FA0  8C821000   LW V0, 4096(A0)
9D076FA4  7C420300   EXT V0, V0, 12, 1
9D076FA8  14400027   BNE V0, ZERO, .LVL10, .LBB9
9D076FAC  24021000   ADDIU V0, ZERO, 4096
224:                 		DMACONSET = _DMACON_SUSPEND_MASK; // suspend
9D076FB0  AC821008   SW V0, 4104(A0)
225:                 		while ((DMACONbits.DMABUSY)); // wait to be actually suspended
9D076FB4  8C821000   LW V0, 4096(A0)
9D076FB8  30420800   ANDI V0, V0, 2048
9D076FBC  1440FFFD   BNE V0, ZERO, 0x9D076FB4
9D076FC0  00000000   NOP
226:                 	}
227:                 	NVMKEY = 0x0;
9D076FC4  AC600A10   SW ZERO, 2576(V1)
9D077048  AC600A10   SW ZERO, 2576(V1)
228:                 	NVMKEY = 0xAA996655;
9D076FC8  3C02AA99   LUI V0, -21863
9D076FCC  24426655   ADDIU V0, V0, 26197
9D076FD0  AC620A10   SW V0, 2576(V1)
9D07704C  3C02AA99   LUI V0, -21863
9D077050  24426655   ADDIU V0, V0, 26197
9D077054  AC620A10   SW V0, 2576(V1)
229:                 	NVMKEY = 0x556699AA;
9D076FD4  3C025566   LUI V0, 21862
9D076FD8  344299AA   ORI V0, V0, -26198
9D076FDC  AC620A10   SW V0, 2576(V1)
9D077058  3C025566   LUI V0, 21862
9D07705C  344299AA   ORI V0, V0, -26198
9D077060  AC620A10   SW V0, 2576(V1)
230:                 	NVMCONSET = 1 << 15; // must be an atomic instruction
9D076FE0  34028000   ORI V0, ZERO, -32768
9D076FE4  AC620A08   SW V0, 2568(V1)
9D077064  34028000   ORI V0, ZERO, -32768
9D077068  AC620A08   SW V0, 2568(V1)
9D07706C  0B41DBFD   J 0x9D076FF4
9D077070  00000000   NOP
231:                 	// Restore DMA
232:                 	if (!dma_susp) {
233:                 		DMACONCLR = _DMACON_SUSPEND_MASK; // resume DMA activity
9D076FE8  24041000   ADDIU A0, ZERO, 4096
9D076FEC  3C02BF81   LUI V0, -16511
9D076FF0  AC441004   SW A0, 4100(V0)
234:                 	}
235:                 	// Restore Interrupts
236:                 	__builtin_set_isr_state(saved_state); /* Set back to what was before. */
9D076FF4  41606000   DI ZERO
9D076FF8  000000C0   EHB
9D076FFC  40026000   MFC0 V0, Status
9D077000  7CA26284   INS V0, A1, 10, 3
9D077004  000528C2   SRL A1, A1, 3
9D077008  7CA20004   INS V0, A1, 0, 1
9D07700C  40826000   MTC0 V0, Status
9D077010  000000C0   EHB
237:                 }
238:                 
239:                 static unsigned int NVMWriteWord(void* address, unsigned int data)
240:                 {
9D076F54  27BDFFF8   ADDIU SP, SP, -8
9D076F58  AFBF0004   SW RA, 4(SP)
241:                 	unsigned int res = 0;
242:                 	// Load data into NVMDATA register
243:                 	NVMDATA0 = data;
9D076F5C  3C03BF80   LUI V1, -16512
9D076F60  AC650A30   SW A1, 2608(V1)
244:                 	// Load address to program into NVMADDR register
245:                 	NVMADDR = (unsigned int) address;
9D076F64  AC640A20   SW A0, 2592(V1)
246:                 	// Unlock and Write Word
247:                 	// set the operation, assumes WREN = 0
248:                 	NVMCONbits.NVMOP = 0x1; // NVMOP for Word programming
9D076F68  94620A00   LHU V0, 2560(V1)
9D076F6C  24040001   ADDIU A0, ZERO, 1
9D076F70  7C821804   INS V0, A0, 0, 4
9D076F74  A4620A00   SH V0, 2560(V1)
249:                 	// Enable Flash for write operation and set the NVMOP
250:                 	NVMCONbits.WREN = 1;
9D076F78  94620A00   LHU V0, 2560(V1)
9D076F7C  7C827384   INS V0, A0, 14, 1
9D076F80  A4620A00   SH V0, 2560(V1)
251:                 	// Start programming
252:                 	NVMInitiateOperation(); // see Example 52-1
253:                 	// Wait for WR bit to clear
254:                 	while (NVMCONbits.WR);
9D077014  8C620A00   LW V0, 2560(V1)
9D077018  30428000   ANDI V0, V0, -32768
9D07701C  1440FFFD   BNE V0, ZERO, .LBE6
9D077020  3C04BF80   LUI A0, -16512
255:                 	// Disable future Flash Write/Erase operations
256:                 	NVMCONbits.WREN = 0;
9D077024  94820A00   LHU V0, 2560(A0)
9D077028  7C027384   INS V0, ZERO, 14, 1
9D07702C  A4820A00   SH V0, 2560(A0)
257:                 	// Check Error Status
258:                 	if (NVMCON & 0x3000) // mask for WRERR and LVDERR
9D077030  8C820A00   LW V0, 2560(A0)
9D077034  30423000   ANDI V0, V0, 12288
9D077038  0002102B   SLTU V0, ZERO, V0
259:                 	{
260:                 		res = 1; // TESTING CLEAR POSSIBLE ERROR set 0
261:                 	}
262:                 	return res;
263:                 }
9D07703C  8FBF0004   LW RA, 4(SP)
9D077040  03E00008   JR RA
9D077044  27BD0008   ADDIU SP, SP, 8
9D077048  AC600A10   SW ZERO, 2576(V1)
9D07704C  3C02AA99   LUI V0, -21863
9D077050  24426655   ADDIU V0, V0, 26197
9D077054  AC620A10   SW V0, 2576(V1)
9D077058  3C025566   LUI V0, 21862
9D07705C  344299AA   ORI V0, V0, -26198
9D077060  AC620A10   SW V0, 2576(V1)
9D077064  34028000   ORI V0, ZERO, -32768
9D077068  AC620A08   SW V0, 2568(V1)
9D07706C  0B41DBFD   J 0x9D076FF4
9D077070  00000000   NOP
264:                 
265:                 uint32_t VirtToPhys(const void* p)
266:                 {
267:                 	return(uint32_t) p < 0 ? ((int) p & 0x1fffffffL) : (unsigned int) ((unsigned char*) p + 0x40000000L);
00000000  00000000   NOP
268:                 }
00000004  00000000   NOP
269:                 
270:                 uint32_t *datavp;
271:                 
272:                 /*
273:                  * read data from the virtual program address of the nvram variable
274:                  */
275:                 uint32_t nvram_in(uint8_t adr)
276:                 {
277:                 	//	uint32_t mydata;
278:                 	//		mydata= VirtToPhys(&myflash[adr]);
279:                 	//		datavp=(uint32_t*) NVM_STARTVADDRESS;
280:                 	//		return (uint32_t) &datavp;
281:                 //	return myflash[adr];
282:                 	return pmyflashr[adr];
9D078E5C  30C600FF   ANDI A2, A2, 255
00000000  00000000   NOP
283:                 }
00000004  00000000   NOP
284:                 
285:                 /*
286:                  * write data to the physical address of the nvram variable
287:                  * using the flash unlock sequence
288:                  */
289:                 uint32_t nvram_out(void *adr, uint32_t data)
290:                 {
291:                 	return NVMWriteWord((void*) adr, data);
00000000  00000000   NOP
292:                 }
293:                 
294:                 /*
295:                  * a few calibrations data specific sized read/write routine
296:                  */
297:                 
298:                 bool get_nvram_str(uint8_t adr, char * str)
299:                 {
9D078E50  24020006   ADDIU V0, ZERO, 6
9D078E54  240800FF   ADDIU T0, ZERO, 255
9D078E58  00443021   ADDU A2, V0, A0
300:                 	bool done = true;
301:                 	uint8_t sz = 7;
302:                 
303:                 	while (sz--) {
9D078E6C  2447FFFF   ADDIU A3, V0, -1
9D078E74  30E200FF   ANDI V0, A3, 255
9D078E78  1448FFF7   BNE V0, T0, .LVL64
9D078E7C  A0660000   SB A2, 0(V1)
304:                 		str[sz] = (char) nvram_in(adr + sz);
9D078E64  8F83803C   LW V1, -32708(GP)
9D078E68  7C66300A   LWX A2, A2(V1)
9D078E70  00A21821   ADDU V1, A1, V0
305:                 	}
306:                 	return done;
307:                 }
9D078E80  03E00008   JR RA
9D078E84  24020001   ADDIU V0, ZERO, 1
308:                 
309:                 bool set_nvram_str(uint32_t * adr, char * str)
310:                 {
9D07895C  27BDFFE8   ADDIU SP, SP, -24
9D078960  AFBF0014   SW RA, 20(SP)
9D078964  00804021   ADDU T0, A0, ZERO
9D078968  00A03821   ADDU A3, A1, ZERO
311:                 	bool done = true;
312:                 	uint8_t sz = 7;
313:                 
314:                 	while (sz--) {
9D07896C  24060006   ADDIU A2, ZERO, 6
9D078970  240900FF   ADDIU T1, ZERO, 255
9D078988  24C6FFFF   ADDIU A2, A2, -1
9D078994  14C9FFF8   BNE A2, T1, 0x9D078978
9D078998  00E61021   ADDU V0, A3, A2
315:                 		if ((done = NVMWriteWord((void *) &adr[sz], (uint32_t) str[sz]))) {
9D078974  00E61021   ADDU V0, A3, A2
9D078978  80450000   LB A1, 0(V0)
9D07897C  00062080   SLL A0, A2, 2
9D078980  0F41DBD5   JAL .LFB16, NVMWriteWord, .LVL0, .LFE0
9D078984  01042021   ADDU A0, T0, A0
9D07898C  14400007   BNE V0, ZERO, .LVL72
9D078990  30C600FF   ANDI A2, A2, 255
9D07899C  00001021   ADDU V0, ZERO, ZERO
316:                 			break; // stop on error
317:                 		}
318:                 	}
319:                 	return done;
320:                 }
9D0789A0  8FBF0014   LW RA, 20(SP)
9D0789A4  03E00008   JR RA
9D0789A8  27BD0018   ADDIU SP, SP, 24
9D0789AC  24020001   ADDIU V0, ZERO, 1
9D0789B0  8FBF0014   LW RA, 20(SP)
9D0789B4  03E00008   JR RA
9D0789B8  27BD0018   ADDIU SP, SP, 24
321:                 
322:                 /*******************************************************************************
323:                  End of File
324:                  */
325:                 
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/eadog.c  --------------
1:                   #include "eadog.h"
2:                   #include <stdio.h>
3:                   #include <string.h>
4:                   
5:                   static void send_lcd_cmd_long(uint8_t); // for display init only
6:                   static void send_lcd_data(uint8_t);
7:                   static void send_lcd_cmd(uint8_t);
8:                   static volatile uint8_t NOPER = 0;
9:                   
10:                  void RS_SetLow(void)
11:                  {
9D079138  24030002   ADDIU V1, ZERO, 2
9D07913C  3C02BF86   LUI V0, -16506
9D079140  AC430234   SW V1, 564(V0)
9D079144  03E00008   JR RA
9D079148  00000000   NOP
12:                  	RS_Clear(); // display board SPI_EN0
00000010  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000020  00000000   NOP
00000024  00000000   NOP
0000002C  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000064  00000000   NOP
00000088  00000000   NOP
000000AC  00000000   NOP
000000D0  00000000   NOP
000000F4  00000000   NOP
00000118  00000000   NOP
0000013C  00000000   NOP
0000015C  00000000   NOP
00000180  00000000   NOP
13:                  };
14:                  
15:                  void RS_SetHigh(void)
16:                  {
9D07914C  24030002   ADDIU V1, ZERO, 2
9D079150  3C02BF86   LUI V0, -16506
9D079154  AC430238   SW V1, 568(V0)
9D079158  03E00008   JR RA
9D07915C  00000000   NOP
17:                  	RS_Set();
00000008  00000000   NOP
00000018  00000000   NOP
00000020  00000000   NOP
0000002C  00000000   NOP
00000038  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000054  00000000   NOP
00000058  00000000   NOP
00000068  00000000   NOP
0000007C  00000000   NOP
000000A0  00000000   NOP
000000C4  00000000   NOP
000000E8  00000000   NOP
0000010C  00000000   NOP
00000130  00000000   NOP
00000154  00000000   NOP
00000174  00000000   NOP
00000194  00000000   NOP
18:                  };
19:                  
20:                  void CSB_SetLow(void)
21:                  {
9D079160  24030004   ADDIU V1, ZERO, 4
9D079164  3C02BF86   LUI V0, -16506
9D079168  AC430234   SW V1, 564(V0)
9D07916C  03E00008   JR RA
9D079170  00000000   NOP
22:                  	CSB_Clear(); // display board SPI_EN1
00000020  00000000   NOP
00000028  00000000   NOP
0000002C  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000040  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
00000060  00000000   NOP
00000068  00000000   NOP
00000070  00000000   NOP
0000008C  00000000   NOP
000000A8  00000000   NOP
000000B0  00000000   NOP
000000D4  00000000   NOP
000000F8  00000000   NOP
0000011C  00000000   NOP
00000140  00000000   NOP
00000160  00000000   NOP
00000184  00000000   NOP
23:                  };
24:                  
25:                  void CSB_SetHigh(void)
26:                  {
9D079174  24030004   ADDIU V1, ZERO, 4
9D079178  3C02BF86   LUI V0, -16506
9D07917C  AC430238   SW V1, 568(V0)
9D079180  03E00008   JR RA
9D079184  00000000   NOP
27:                  	CSB_Set();
00000014  00000000   NOP
00000024  00000000   NOP
28:                  };
29:                  
30:                  void SPI_Exchange8bit(uint8_t data)
31:                  {
9D079080  27BDFFE8   ADDIU SP, SP, -24
9D079084  AFBF0014   SW RA, 20(SP)
9D079088  A3A40018   SB A0, 24(SP)
32:                  	SPI1_Write(&data, 1);
9D07908C  24050001   ADDIU A1, ZERO, 1
9D079090  0F41E471   JAL SPI1_Write
9D079094  27A40018   ADDIU A0, SP, 24
00000010  00000000   NOP
0000001C  00000000   NOP
00000024  00000000   NOP
00000028  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000044  00000000   NOP
00000048  00000000   NOP
0000004C  00000000   NOP
00000060  00000000   NOP
00000064  00000000   NOP
0000006C  00000000   NOP
0000007C  00000000   NOP
00000090  00000000   NOP
00000098  00000000   NOP
000000AC  00000000   NOP
000000B4  00000000   NOP
000000D8  00000000   NOP
000000FC  00000000   NOP
00000120  00000000   NOP
00000144  00000000   NOP
00000164  00000000   NOP
00000188  00000000   NOP
33:                  };
9D079098  8FBF0014   LW RA, 20(SP)
9D07909C  03E00008   JR RA
9D0790A0  27BD0018   ADDIU SP, SP, 24
34:                  
35:                  void SPI_ExchangeBuffer(uint8_t *data, uint16_t len)
36:                  {
37:                  	SPI1_Write(data, len);
9D079220  0B41E471   J SPI1_Write
9D079224  00000000   NOP
38:                  };
39:                  
40:                  /*
41:                   * Init the EA DOGM163 in 8-bit serial mode
42:                   */
43:                  void init_display(void)
44:                  {
00000000  00000000   NOP
45:                  	CSB_SetHigh();
46:                  	CORETIMER_DelayMs(400); // > 400ms power up delay
0000001C  00000000   NOP
00000028  00000000   NOP
47:                  	send_lcd_cmd(0x39);
48:                  	send_lcd_cmd(0x15);
49:                  	send_lcd_cmd(0x55);
50:                  	send_lcd_cmd(0x6d);
51:                  	send_lcd_cmd(0x70); // contrast last 4 bits
52:                  	send_lcd_cmd_long(0x38); // follower control
53:                  	send_lcd_cmd(0x0f);
54:                  	send_lcd_cmd_long(0x01); // clear
55:                  	send_lcd_cmd(0x02);
56:                  	send_lcd_cmd(0x06);
57:                  	CORETIMER_DelayMs(50);
00000190  00000000   NOP
00000198  00000000   NOP
58:                  }
000001A0  00000000   NOP
59:                  
60:                  /*
61:                   * add short spi delay (default)
62:                   */
63:                  static void send_lcd_data(const uint8_t data)
64:                  {
65:                  	RS_SetHigh();
66:                  	CSB_SetLow();
67:                  	SPI_Exchange8bit(data);
68:                  }
69:                  
70:                  /*
71:                   * add inst spi delay
72:                   */
73:                  static void send_lcd_cmd(const uint8_t cmd)
74:                  {
75:                  	RS_SetLow();
76:                  	CSB_SetLow();
77:                  	SPI_Exchange8bit(cmd);
78:                  	RS_SetHigh();
79:                  }
80:                  
81:                  /*
82:                   * add clear/home spi delay
83:                   */
84:                  static void send_lcd_cmd_long(const uint8_t cmd)
85:                  {
86:                  	RS_SetLow();
87:                  	CSB_SetLow();
88:                  	SPI_Exchange8bit(cmd);
89:                  	RS_SetHigh();
90:                  }
91:                  
92:                  void eaDogM_WriteChr(const int8_t value)
93:                  {
00000000  00000000   NOP
94:                  	send_lcd_data((uint8_t) value);
95:                  }
00000030  00000000   NOP
96:                  
97:                  void eaDogM_WriteCommand(const uint8_t cmd)
98:                  {
00000000  00000000   NOP
99:                  	send_lcd_cmd(cmd);
100:                 }
0000003C  00000000   NOP
101:                 
102:                 void eaDogM_SetPos(const uint8_t r, const uint8_t c)
103:                 {
00000000  00000000   NOP
104:                 	uint8_t cmdPos;
105:                 	cmdPos = (uint8_t) EADOGM_CMD_DDRAM_ADDR + (uint8_t) ((uint8_t) r * (uint8_t) EADOGM_COLSPAN) + (uint8_t) c;
00000010  00000000   NOP
0000001C  00000000   NOP
106:                 	eaDogM_WriteCommand(cmdPos);
107:                 }
00000048  00000000   NOP
108:                 
109:                 void eaDogM_ClearRow(const uint8_t r)
110:                 {
00000000  00000000   NOP
111:                 	uint8_t i;
112:                 	eaDogM_SetPos(r, 0);
0000001C  00000000   NOP
113:                 	for (i = 0; i < EADOGM_COLSPAN; i++) {
00000058  00000000   NOP
114:                 		eaDogM_WriteChr(' ');
115:                 	}
116:                 }
00000060  00000000   NOP
117:                 
118:                 void eaDogM_WriteString(char *strPtr)
119:                 {
00000000  00000000   NOP
120:                 	uint8_t i = strlen(strPtr);
0000000C  00000000   NOP
121:                 
122:                 	RS_SetHigh();
123:                 	CSB_SetLow();
124:                 
125:                 	if (i > max_strlen) {
00000014  00000000   NOP
0000001C  00000000   NOP
00000030  00000000   NOP
126:                 		strPtr[max_strlen] = 0; // buffer overflow check
00000038  00000000   NOP
127:                 		i = max_strlen;
128:                 	}
129:                 
130:                 	SPI1_Write(strPtr, i); // use interrupt mode so we don't wait
00000040  00000000   NOP
0000004C  00000000   NOP
131:                 }
00000044  00000000   NOP
132:                 
133:                 void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
134:                 {
9D078EC0  27BDFFE8   ADDIU SP, SP, -24
9D078EC4  AFBF0014   SW RA, 20(SP)
9D078EC8  AFB00010   SW S0, 16(SP)
9D078ECC  00801021   ADDU V0, A0, ZERO
9D078ED0  00C08021   ADDU S0, A2, ZERO
135:                 #ifdef EDOGS
136:                 	OledSetCursor(c, r);
9D078ED4  00A02021   ADDU A0, A1, ZERO
9D078ED8  0F41E328   JAL OledSetCursor
9D078EDC  00402821   ADDU A1, V0, ZERO
137:                 	OledPutString(strPtr);
9D078EE0  02002021   ADDU A0, S0, ZERO
9D078EEC  0B41E287   J OledPutString
9D078EF0  27BD0018   ADDIU SP, SP, 24
138:                 #else
139:                 	send_lcd_cmd((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
140:                 	eaDogM_WriteString(strPtr);
141:                 #endif
142:                 }
9D078EE4  8FBF0014   LW RA, 20(SP)
9D078EE8  8FB00010   LW S0, 16(SP)
9D078EEC  0B41E287   J OledPutString
9D078EF0  27BD0018   ADDIU SP, SP, 24
143:                 
144:                 void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
145:                 {
00000000  00000000   NOP
0000003C  00000000   NOP
146:                 	eaDogM_WriteCommand((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
0000001C  00000000   NOP
00000030  00000000   NOP
147:                 
148:                 	eaDogM_WriteChr(i / 10 + '0');
00000054  00000000   NOP
00000074  00000000   NOP
149:                 	eaDogM_WriteChr(i % 10 + '0');
00000084  00000000   NOP
150:                 
151:                 }
000000B4  00000000   NOP
152:                 
153:                 // this writes a byte to the internal CGRAM (v2.02)
154:                 // format for ndx: 00CCCRRR = CCC = character 0 to 7, RRR = row 0 to 7
155:                 
156:                 void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
157:                 {
00000000  00000000   NOP
00000024  00000000   NOP
158:                 	uint8_t cmd;
159:                 
160:                 	cmd = ndx & 0b00111111; // mask off upper to bits
00000018  00000000   NOP
161:                 	cmd = cmd | EADOGM_CMD_CGRAM_ADDR; // set bit cmd bits
0000002C  00000000   NOP
162:                 
163:                 	eaDogM_WriteCommand(cmd);
164:                 	eaDogM_WriteChr(data);
165:                 
166:                 	// this is done to make sure we are back in data mode
167:                 	eaDogM_SetPos(0, 0);
0000006C  00000000   NOP
168:                 }
00000078  00000000   NOP
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/dogm-graphic.c  -------
1:                   /******************************************************************************
2:                    * Display Library
3:                    * for EA-DOGS102  GLCD (102px x 64px)
4:                    *     EA-DOGM128  GLCD (128px x 64px)
5:                    *     EA-DOGM132  GLCD (132px x 32px)
6:                    *     EA-DOGL128  GLCD (128px x 64px)
7:                    *     EA-DOGXL160 GLCD (160px x 104px)
8:                    *     EA-DOGXL240 GLCD (240px x 128px)
9:                    * 
10:                   * Provides all basic functions to access the display
11:                   * Since no graphics ram is used, the memory footprint is rather small but
12:                   * also does not allow to change single pixels. Data written to the LCD can
13:                   * not be read back!
14:                   * Text can be displayed using the attached font generator containing several
15:                   * character sets and font variants.
16:                   * Thanks to Oliver Schwaneberg for adding several functions to this library!
17:                   * 
18:                   * Author:  Jan Michel (jan at mueschelsoft dot de)
19:                   * License: GNU General Public License, version 3
20:                   * Version: v0.96 April 2017
21:                   * ****************************************************************************
22:                   * New features in v0.96
23:                   *   - added support for EA-DOGXL240 display
24:                   * New features in v0.95
25:                   *   - added initialization for top-view 
26:                   *   - automatic shifting column addresses (e.g. top-view)
27:                   * New features in v0.94
28:                   *   - corrected order of arguments in lcd_clear_area_xy()
29:                   *   - added command definitions for DOGXL160
30:                   *   - cleaned up dogm_graphic.h command area
31:                   * New features in v0.93
32:                   *   - modified initialization for DOGM128 and DOGS102
33:                   * New features in v0.92
34:                   *   - Added initialization for DOGS102 and DOGL128
35:                   * New features in v0.91
36:                   *   - Control of chip select pin
37:                   *   - backlight & chip select are optional - can be turned of in header file
38:                   *   - added function lcd_draw_image_P 
39:                   *   - added function lcd_draw_image_xy_P
40:                   *   - added function lcd_clear_area
41:                   *   - added SPI initialization
42:                   *****************************************************************************/
43:                  
44:                  #include "dogm-graphic.h"
45:                  
46:                  //=============================================================================
47:                  //keeping track of current position in ram - necessary for big fonts & bitmaps
48:                  //=============================================================================
49:                  
50:                  uint8_t lcd_current_page = 0;
51:                  uint8_t lcd_current_column = 0;
52:                  
53:                  void RS_SetLow(void);
54:                  void RS_SetHigh(void);
55:                  void CSB_SetLow(void);
56:                  void CSB_SetHigh(void);
57:                  void SPI_Exchange8bit(uint8_t);
58:                  
59:                  /******************************************************************************
60:                   * Changes the internal cursor by s pages
61:                   * s             - number of pages to move
62:                   */
63:                  uint8_t lcd_inc_page(int8_t s)
64:                  {
65:                  	uint8_t p = lcd_current_page;
9D078FE4  9383808B   LBU V1, -32629(GP)
00000000  00000000   NOP
66:                  	p += s;
9D078FEC  00642021   ADDU A0, V1, A0
00000004  00000000   NOP
67:                  	p %= LCD_RAM_PAGES; //all lcd have lcd_ram_pages which is power of two
9D078FF4  3083000F   ANDI V1, A0, 15
00000008  00000000   NOP
68:                  	lcd_current_page = p;
9D079004  A383808B   SB V1, -32629(GP)
69:                  	return p;
70:                  }
0000000C  00000000   NOP
71:                  
72:                  /******************************************************************************
73:                   * Changes the internal cursor by s columns, including wrapping (if selected)
74:                   * s             - number of columns to move
75:                   */
76:                  uint8_t lcd_inc_column(int16_t s)
77:                  {
00000000  00000000   NOP
78:                  	uint16_t c = lcd_current_column;
9D078D08  9382808A   LBU V0, -32630(GP)
9D078FE8  9382808A   LBU V0, -32630(GP)
79:                  	c += s;
9D078D0C  24420001   ADDIU V0, V0, 1
9D078FF0  00452821   ADDU A1, V0, A1
00000004  00000000   NOP
80:                  #if LCD_WRAP_AROUND == 1
81:                  	while (c >= LCD_WIDTH) {
82:                  		if (s > 0) lcd_inc_page(1);
83:                  		else lcd_inc_page(-1);
84:                  		if (s > 0) c -= LCD_WIDTH;
85:                  		else c += LCD_WIDTH;
86:                  	}
87:                  #endif
88:                  	lcd_current_column = c;
9D078D10  A382808A   SB V0, -32630(GP)
9D078FF8  30A200FF   ANDI V0, A1, 255
00000008  00000000   NOP
89:                  	return c;
90:                  }
0000000C  00000000   NOP
91:                  
92:                  /******************************************************************************
93:                   * Moves the cursor to the given position
94:                   * pages         - page to move to
95:                   * columns       - column to move to
96:                   */
97:                  void lcd_moveto_xy(uint8_t page, uint8_t column)
98:                  {
9D0789BC  27BDFFE0   ADDIU SP, SP, -32
9D0789C0  AFBF001C   SW RA, 28(SP)
9D0789C4  AFB10018   SW S1, 24(SP)
9D0789C8  AFB00014   SW S0, 20(SP)
9D0789CC  00808821   ADDU S1, A0, ZERO
99:                  	LCD_GOTO_ADDRESS(page, column);
9D0789D0  3084000F   ANDI A0, A0, 15
9D0789D4  34840060   ORI A0, A0, 96
9D0789D8  0F41E3EE   JAL lcd_command
9D0789DC  00A08021   ADDU S0, A1, ZERO
9D0789E0  00112102   SRL A0, S1, 4
9D0789E4  0F41E3EE   JAL lcd_command
9D0789E8  34840070   ORI A0, A0, 112
9D0789EC  00102102   SRL A0, S0, 4
9D0789F0  0F41E3EE   JAL lcd_command
9D0789F4  34840010   ORI A0, A0, 16
9D0789F8  0F41E3EE   JAL lcd_command
9D0789FC  3204000F   ANDI A0, S0, 15
100:                 	lcd_current_column = column;
9D078A00  A390808A   SB S0, -32630(GP)
101:                 	lcd_current_page = page;
9D078A04  A391808B   SB S1, -32629(GP)
102:                 }
9D078A08  8FBF001C   LW RA, 28(SP)
9D078A0C  8FB10018   LW S1, 24(SP)
9D078A10  8FB00014   LW S0, 20(SP)
9D078A14  03E00008   JR RA
9D078A18  27BD0020   ADDIU SP, SP, 32
103:                 
104:                 /******************************************************************************
105:                  * Moves the cursor relative to the current position
106:                  * pages         - number of pages to move
107:                  * columns       - number of columns to move
108:                  */
109:                 void lcd_move_xy(int8_t pages, int16_t columns)
110:                 {
111:                 	lcd_moveto_xy(lcd_inc_page(pages), lcd_inc_column(columns));
9D078FFC  00602021   ADDU A0, V1, ZERO
9D079000  00402821   ADDU A1, V0, ZERO
9D079008  0B41E26F   J lcd_moveto_xy
9D07900C  A382808A   SB V0, -32630(GP)
112:                 }
113:                 
114:                 
115:                 //=============================================================================
116:                 //Basic Byte Access to Display
117:                 //=============================================================================
118:                 
119:                 /******************************************************************************
120:                  * Writes one data byte
121:                  * data          - the data byte
122:                  */
123:                 void lcd_data(uint8_t data)
124:                 {
9D078CE0  27BDFFE0   ADDIU SP, SP, -32
9D078CE4  AFBF001C   SW RA, 28(SP)
125:                 	LCD_DRAM();
9D078CE8  0F41E453   JAL .LFB15, .LFE14, RS_SetHigh
9D078CEC  AFA40010   SW A0, 16(SP)
126:                 	LCD_SELECT();
9D078CF0  0F41E458   JAL .LFB16, .LFE15, CSB_SetLow
9D078CF4  00000000   NOP
127:                 	SPI_Exchange8bit(data);
9D078CF8  0F41E420   JAL .LFE13, .LFB18, .LVL0, SPI_Exchange8bit
9D078CFC  8FA40010   LW A0, 16(SP)
128:                 	LCD_UNSELECT();
9D078D00  0F41E45D   JAL .LFB17, .LFE16, CSB_SetHigh
9D078D04  00000000   NOP
129:                 	lcd_inc_column(1);
130:                 }
9D078D14  8FBF001C   LW RA, 28(SP)
9D078D18  03E00008   JR RA
9D078D1C  27BD0020   ADDIU SP, SP, 32
131:                 
132:                 /******************************************************************************
133:                  * Writes one command byte
134:                  * cmd           - the command byte
135:                  */
136:                 void lcd_command(uint8_t cmd)
137:                 {
9D078FB8  27BDFFE0   ADDIU SP, SP, -32
9D078FBC  AFBF001C   SW RA, 28(SP)
138:                 	LCD_CMD();
9D078FC0  0F41E44E   JAL .LFE30, .LFB14, RS_SetLow
9D078FC4  AFA40010   SW A0, 16(SP)
139:                 	LCD_SELECT();
9D078FC8  0F41E458   JAL .LFB16, .LFE15, CSB_SetLow
9D078FCC  00000000   NOP
140:                 
141:                 	SPI_Exchange8bit(cmd);
9D078FD0  0F41E420   JAL .LFE13, .LFB18, .LVL0, SPI_Exchange8bit
9D078FD4  8FA40010   LW A0, 16(SP)
142:                 	LCD_UNSELECT();
9D078FDC  0B41E45D   J .LFB17, .LFE16, CSB_SetHigh
9D078FE0  27BD0020   ADDIU SP, SP, 32
143:                 }
9D078FD8  8FBF001C   LW RA, 28(SP)
9D078FDC  0B41E45D   J .LFB17, .LFE16, CSB_SetHigh
9D078FE0  27BD0020   ADDIU SP, SP, 32
144:                 
145:                 
146:                 //=============================================================================
147:                 //Puts raw data from Flash to the Display
148:                 //=============================================================================
149:                 #if LCD_INCLUDE_GRAPHIC_FUNCTIONS >= 1
150:                 
151:                 /******************************************************************************
152:                  * This function draws a bitmap from the current position on the screen.
153:                  * Parameters:
154:                  * progmem_image - prog_uint8_t array of columns aka the bitmap image
155:                  * pages         - height of image in pages
156:                  * columns       - width of image in pixels (or columns)
157:                  * style         - Bit2: sets inverse mode
158:                  */
159:                 void lcd_draw_image_P(uint8_t * progmem_image, uint8_t pages, uint8_t columns, uint8_t style)
160:                 {
161:                 	uint8_t i, j = 0;
162:                 	uint8_t inv = (style & INVERT_BIT);
163:                 	while (j < pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
164:                 		for (i = 0; i < columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
165:                 			uint8_t tmp = *progmem_image++;
166:                 			if (!inv)
167:                 				lcd_data(tmp);
168:                 			else
169:                 				lcd_data(~tmp);
170:                 		}
171:                 		if (++j != pages && lcd_get_position_column() != 0)
172:                 			lcd_move_xy(1, -columns);
173:                 	}
174:                 }
175:                 
176:                 /******************************************************************************
177:                  * This function draws a bitmap at any xy-position on the screen. 
178:                  * Be aware that some pixels are deleted due to memory organization!
179:                  * Parameters:
180:                  * progmem_image - prog_uint8_t array of columns aka the bitmap image
181:                  * x             - x start coordinate on the screen (in pixel)
182:                  * y             - y start coordinate on the screen (in pixel)
183:                  * pages         - height of image in pages
184:                  * columns       - width of image in pixels
185:                  * style         - Bit2: sets inverse mode
186:                  */
187:                 void lcd_draw_image_xy_P(uint8_t * progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style)
188:                 {
189:                 	uint16_t i, j;
190:                 	uint8_t data = 0;
191:                 	uint8_t inv = style & INVERT_BIT;
192:                 	uint8_t offset = y & 0x7; //Optimized modulo 8
193:                 	//If there is an offset, we must use an additional page
194:                 	if (offset)
195:                 		pages++;
196:                 	//If there is not enough vertical space -> cut image
197:                 	if (pages > LCD_RAM_PAGES - lcd_get_position_page())
198:                 		pages = LCD_RAM_PAGES - lcd_get_position_page();
199:                 	//Goto starting point and draw
200:                 	lcd_moveto_xy((y >> 3), x);
201:                 	for (j = 0; j < pages; j++) {
202:                 		for (i = 0; i < columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
203:                 			data = 0;
204:                 			if (!offset || j + 1 != pages)
205:                 				data = (*progmem_image + j * columns + i) << offset;
206:                 			if (j > 0 && offset)
207:                 				data |= (*progmem_image + (j - 1) * columns + i) >> (8 - offset);
208:                 			if (inv) lcd_data(~data);
209:                 			else lcd_data(data);
210:                 		}
211:                 		if (j + 1 != pages)
212:                 			lcd_move_xy(1, -columns);
213:                 	}
214:                 }
215:                 #endif
216:                 
217:                 /******************************************************************************
218:                  * This function clears an area of the screen
219:                  * pages         - height of area in pages
220:                  * columns       - width of area in pixels
221:                  * style         - Bit2: sets inverse mode
222:                  * Cursor is moved to start of area after clear
223:                  */
224:                 void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style)
225:                 {
9D0778A8  27BDFFD0   ADDIU SP, SP, -48
9D0778AC  AFBF002C   SW RA, 44(SP)
9D0778B0  AFB50028   SW S5, 40(SP)
9D0778B4  AFB40024   SW S4, 36(SP)
9D0778B8  AFB30020   SW S3, 32(SP)
9D0778BC  AFB2001C   SW S2, 28(SP)
9D0778C0  AFB10018   SW S1, 24(SP)
9D0778C4  AFB00014   SW S0, 20(SP)
226:                 	uint8_t i, j, max;
227:                 	uint8_t inv = (style & INVERT_BIT) ? 0xFF : 0;
9D0778D4  7CC60080   EXT A2, A2, 2, 1
9D0778DC  00069023   SUBU S2, ZERO, A2
9D0778E0  0044182B   SLTU V1, V0, A0
9D0778E4  10600002   BEQ V1, ZERO, .LVL35
9D0778E8  325200FF   ANDI S2, S2, 255
9D0778EC  00402021   ADDU A0, V0, ZERO
228:                 
229:                 	if (pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))
9D0778C8  9382808B   LBU V0, -32629(GP)
9D0778CC  24030010   ADDIU V1, ZERO, 16
9D0778D0  00621023   SUBU V0, V1, V0
9D0778D8  304200FF   ANDI V0, V0, 255
230:                 		pages = max;
231:                 	if (columns > (max = LCD_WIDTH - lcd_get_position_column()))
9D0778F0  9382808A   LBU V0, -32630(GP)
9D0778F4  2403FFF0   ADDIU V1, ZERO, -16
9D0778F8  00621023   SUBU V0, V1, V0
9D0778FC  304200FF   ANDI V0, V0, 255
9D077900  0045182B   SLTU V1, V0, A1
9D077904  10600002   BEQ V1, ZERO, .LVL38
9D077908  309400FF   ANDI S4, A0, 255
9D07790C  00402821   ADDU A1, V0, ZERO
232:                 		columns = max;
233:                 
234:                 	for (j = 0; j < pages; j++) {
9D077910  12800013   BEQ S4, ZERO, .LVL48
9D077914  30B100FF   ANDI S1, A1, 255
9D077918  0011A823   SUBU S5, ZERO, S1
9D07791C  7C15AE20   SEH S5, S5
9D077920  00009821   ADDU S3, ZERO, ZERO
9D077950  26730001   ADDIU S3, S3, 1
9D077954  327300FF   ANDI S3, S3, 255
9D077958  1674FFF2   BNE S3, S4, .LVL39
9D07795C  00000000   NOP
235:                 		for (i = 0; i < columns; i++) {
9D077924  12200008   BEQ S1, ZERO, .LVL44
9D077928  24040001   ADDIU A0, ZERO, 1
9D07792C  00008021   ADDU S0, ZERO, ZERO
9D077938  26100001   ADDIU S0, S0, 1
9D07793C  321000FF   ANDI S0, S0, 255
9D077940  1611FFFB   BNE S0, S1, .LVL40
9D077944  24040001   ADDIU A0, ZERO, 1
236:                 			lcd_data(inv);
9D077930  0F41E338   JAL lcd_data
9D077934  02402021   ADDU A0, S2, ZERO
237:                 		}
238:                 		lcd_move_xy(1, -columns);
9D077948  0F41E3F9   JAL lcd_move_xy
9D07794C  02A02821   ADDU A1, S5, ZERO
239:                 	}
240:                 	lcd_move_xy(-pages, 0);
9D077960  00142023   SUBU A0, ZERO, S4
9D077964  7C042420   SEB A0, A0
9D077968  00002821   ADDU A1, ZERO, ZERO
9D077988  0B41E3F9   J lcd_move_xy
9D07798C  27BD0030   ADDIU SP, SP, 48
241:                 }
9D07796C  8FBF002C   LW RA, 44(SP)
9D077970  8FB50028   LW S5, 40(SP)
9D077974  8FB40024   LW S4, 36(SP)
9D077978  8FB30020   LW S3, 32(SP)
9D07797C  8FB2001C   LW S2, 28(SP)
9D077980  8FB10018   LW S1, 24(SP)
9D077984  8FB00014   LW S0, 20(SP)
9D077988  0B41E3F9   J lcd_move_xy
9D07798C  27BD0030   ADDIU SP, SP, 48
242:                 
243:                 /******************************************************************************
244:                  * This function clears an area of the screen starting at the given coordinates
245:                  * pages         - height of area in pages
246:                  * columns       - width of area in pixels
247:                  * style         - style modifier
248:                  * col           - column of upper left corner
249:                  * page          - page of upper left corner
250:                  * Cursor is moved to start of area after clear
251:                  */
252:                 void lcd_clear_area_xy(uint8_t pages, uint8_t columns, uint8_t style, uint8_t page, uint8_t col)
253:                 {
00000000  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
254:                 	lcd_moveto_xy(page, col);
9D077A40  00002021   ADDU A0, ZERO, ZERO
00000014  00000000   NOP
0000001C  00000000   NOP
255:                 	lcd_clear_area(pages, columns, style);
9D077A4C  24040010   ADDIU A0, ZERO, 16
00000028  00000000   NOP
00000040  00000000   NOP
256:                 }
00000034  00000000   NOP
257:                 
258:                 /******************************************************************************
259:                  * This function sets the display contrast
260:                  * value         - contrast level in percent (0 to 100)
261:                  */
262:                 #if DISPLAY_TYPE == 240
263:                 
264:                 void lcd_set_contrast(uint8_t value)
265:                 {
00000000  00000000   NOP
0000000C  00000000   NOP
266:                 	uint8_t x = (uint8_t) ((uint16_t) value * 255 / 100); // calculate 0-255 value from percent
00000018  00000000   NOP
267:                 	LCD_SET_POTI(x);
00000010  00000000   NOP
0000003C  00000000   NOP
00000048  00000000   NOP
268:                 }
00000040  00000000   NOP
269:                 #endif
270:                 
271:                 /******************************************************************************
272:                  * Initializes the display in 4x booster for 2.4-3.3V supply voltage
273:                  * scheme according to datasheet
274:                  * Suitable for all DOGS, DOGM, DOGL and DOGXL displays 
275:                  * in both bottom or top-view orientation.
276:                  */
277:                 void lcd_init(void)
278:                 {
9D077990  27BDFFE0   ADDIU SP, SP, -32
9D077994  AFBF001C   SW RA, 28(SP)
9D077998  AFB10018   SW S1, 24(SP)
9D07799C  AFB00014   SW S0, 20(SP)
279:                 	//Load settings
280:                 #if DISPLAY_TYPE == 2400
281:                 	BACKLIGHT_Clear();
282:                 	WaitMs(2);
283:                 	BACKLIGHT_Set();
284:                 	WaitMs(150);
285:                 	BACKLIGHT_Clear();
286:                 	WaitMs(2);
287:                 	BACKLIGHT_Set();
288:                 	WaitMs(150);
289:                 	lcd_command(0xF1); //last COM electrode
290:                 	lcd_command(0x7F); //128-1 = 127
291:                 	lcd_command(0xF2); //Display start line
292:                 	lcd_command(0x00); //0
293:                 	lcd_command(0xF3); //Display end line
294:                 	lcd_command(0x7F); //0
295:                 
296:                 	LCD_SET_POTI(0x8F); // set Contrast to mid range lvl
297:                 	LCD_SET_MAPPING_CTRL(2); // set mapping control to "bottom view"
298:                 
299:                 
300:                 	lcd_command(0xA3); //9.4K per second line rate
301:                 	lcd_command(0x25); //Set temp. comp. to -0.1%/?C
302:                 	lcd_command(0xA9); //Enable Display
303:                 	lcd_command(0xD1); //in Black and white mode
304:                 #endif
305:                 #if DISPLAY_TYPE == 240
306:                 //	LCD_SYSTEM_RESET; // software reset
307:                 	BACKLIGHT_Clear();
9D0779A0  3C10BF86   LUI S0, -16506
9D0779A4  24110400   ADDIU S1, ZERO, 1024
9D0779AC  AE110234   SW S1, 564(S0)
308:                 	CORETIMER_DelayMs(2);
9D0779A8  24040002   ADDIU A0, ZERO, 2
9D0779B0  0F41E2F3   JAL CORETIMER_DelayMs
9D0779B4  00000000   NOP
309:                 	BACKLIGHT_Set();
9D0779BC  AE110238   SW S1, 568(S0)
310:                 	CORETIMER_DelayMs(150);
9D0779B8  24040096   ADDIU A0, ZERO, 150
9D0779C0  0F41E2F3   JAL CORETIMER_DelayMs
9D0779C4  00000000   NOP
311:                 	LCD_SET_COM_END(127); // set last COM electrode
9D0779C8  0F41E3EE   JAL lcd_command
9D0779CC  240400F1   ADDIU A0, ZERO, 241
9D0779D0  0F41E3EE   JAL lcd_command
9D0779D4  2404007F   ADDIU A0, ZERO, 127
312:                 	LCD_SET_PARTIAL_DISPLAY(0, 127); // set partial display start and end
9D0779D8  0F41E3EE   JAL lcd_command
9D0779DC  240400F2   ADDIU A0, ZERO, 242
9D0779E0  0F41E3EE   JAL lcd_command
9D0779E4  00002021   ADDU A0, ZERO, ZERO
9D0779E8  0F41E3EE   JAL lcd_command
9D0779EC  240400F3   ADDIU A0, ZERO, 243
9D0779F0  0F41E3EE   JAL lcd_command
9D0779F4  2404007F   ADDIU A0, ZERO, 127
313:                 	LCD_SET_POTI(0x8F); // set Contrast to mid range lvl
9D0779F8  0F41E3EE   JAL lcd_command
9D0779FC  24040081   ADDIU A0, ZERO, 129
9D077A00  0F41E3EE   JAL lcd_command
9D077A04  2404008F   ADDIU A0, ZERO, 143
314:                 	LCD_SET_MAPPING_CTRL(2); // set mapping control to "bottom view"
9D077A08  0F41E3EE   JAL lcd_command
9D077A0C  240400C0   ADDIU A0, ZERO, 192
9D077A10  0F41E3EE   JAL lcd_command
9D077A14  24040002   ADDIU A0, ZERO, 2
315:                 	LCD_SET_LINE_RATE(11); // set line rate to 9.4 kilo lines per second
9D077A18  0F41E3EE   JAL lcd_command
9D077A1C  240400A3   ADDIU A0, ZERO, 163
316:                 	LCD_SET_TEMP_COMP(1); // set temp compensation to -0.10%
9D077A20  0F41E3EE   JAL lcd_command
9D077A24  24040025   ADDIU A0, ZERO, 37
317:                 	LCD_SWITCH_ON(); // set display enable (0xA9)
9D077A28  0F41E3EE   JAL lcd_command
9D077A2C  240400A9   ADDIU A0, ZERO, 169
318:                 	LCD_SET_DISPLAY_PATTERN(1); // set display pattern (0xD1)
9D077A30  0F41E3EE   JAL lcd_command
9D077A34  240400D1   ADDIU A0, ZERO, 209
319:                 	LCD_SET_RAM_ADDR_CTRL(1); // set auto-increment
9D077A38  0F41E3EE   JAL lcd_command
9D077A3C  24040089   ADDIU A0, ZERO, 137
320:                 #endif
321:                 #if DISPLAY_TYPE == 160
322:                 	LCD_SET_COM_END(103); //set last COM electrode
323:                 #if ORIENTATION_UPSIDEDOWN = 0
324:                 	LCD_SET_BOTTOM_VIEW(); //6 o'clock mode, normal orientation
325:                 #else
326:                 	LCD_SET_TOP_VIEW(); //12 o'clock mode, reversed orientation
327:                 #endif
328:                 	LCD_SET_START_LINE(0); //set scrolling to 0
329:                 	LCD_SET_PANEL_LOAD(3); //set panel loading to 28-38nF
330:                 	LCD_SET_BIAS_RATIO(3); //set bias ratio
331:                 	LCD_SET_VOLTAGE_BIAS(0x5F); //set Vbias potentiometer for contrast
332:                 	LCD_SET_RAM_ADDR_CTRL(1); //set auto-increment
333:                 #endif
334:                 #if DISPLAY_TYPE == 132
335:                 	LCD_SET_FIRST_LINE(0); //first bit in RAM is on the first line of the LCD
336:                 #if ORIENTATION_UPSIDEDOWN == 0
337:                 	LCD_SET_BOTTOM_VIEW(); //6 o'clock mode, normal orientation
338:                 	LCD_ORIENTATION_NORMAL();
339:                 #else
340:                 	LCD_SET_TOP_VIEW(); //12 o'clock mode, reversed orientation
341:                 	LCD_ORIENTATION_UPSIDEDOWN();
342:                 #endif
343:                 	LCD_SHOW_ALL_PIXELS_OFF(); //Normal Pixel mode
344:                 	LCD_SET_MODE_POSITIVE(); //positive display
345:                 	LCD_SET_BIAS_RATIO_1_9(); //bias 1/9
346:                 	LCD_SET_POWER_CONTROL(7); //power control mode: all features on
347:                 	LCD_SET_BIAS_VOLTAGE(3); //set voltage regulator R/R
348:                 	LCD_SET_VOLUME_MODE(0x1F); //volume mode set
349:                 	LCD_SET_INDICATOR_OFF(); //switch indicator off, no blinking
350:                 #endif
351:                 #if DISPLAY_TYPE == 128
352:                 	LCD_SET_FIRST_LINE(0); //first bit in RAM is on the first line of the LCD
353:                 #if ORIENTATION_UPSIDEDOWN == 0
354:                 	LCD_SET_BOTTOM_VIEW(); //6 o'clock mode, normal orientation
355:                 	LCD_ORIENTATION_NORMAL();
356:                 #else
357:                 	LCD_SET_TOP_VIEW(); //12 o'clock mode, reversed orientation
358:                 	LCD_ORIENTATION_UPSIDEDOWN();
359:                 #endif
360:                 	LCD_SHOW_ALL_PIXELS_OFF(); //Normal Pixel mode
361:                 	LCD_SET_MODE_POSITIVE(); //positive display
362:                 	LCD_SET_BIAS_RATIO_1_7(); //bias 1/7
363:                 	LCD_SET_POWER_CONTROL(7); //power control mode: all features on
364:                 	LCD_SET_BIAS_VOLTAGE(7); //set voltage regulator R/R
365:                 	LCD_SET_VOLUME_MODE(0x06); //volume mode set
366:                 	LCD_SET_INDICATOR_OFF(); //switch indicator off, no blinking
367:                 #endif
368:                 #if DISPLAY_TYPE == 102
369:                 	LCD_SET_FIRST_LINE(0); //first bit in RAM is on the first line of the LCD
370:                 #if ORIENTATION_UPSIDEDOWN == 0
371:                 	LCD_SET_BOTTOM_VIEW(); //6 o'clock mode, normal orientation
372:                 	LCD_ORIENTATION_NORMAL();
373:                 #else
374:                 	LCD_SET_TOP_VIEW(); //12 o'clock mode, reversed orientation
375:                 	LCD_ORIENTATION_UPSIDEDOWN();
376:                 #endif
377:                 	LCD_SHOW_ALL_PIXELS_OFF(); //Normal Pixel mode
378:                 	LCD_SET_MODE_POSITIVE(); //positive display
379:                 	LCD_SET_BIAS_RATIO_1_9(); //bias 1/9
380:                 	LCD_SET_POWER_CONTROL(7); //power control mode: all features on
381:                 	LCD_SET_BIAS_VOLTAGE(7); //set voltage regulator R/R
382:                 	LCD_SET_VOLUME_MODE(0x9); //volume mode set
383:                 	LCD_SET_ADV_PROG_CTRL(LCD_TEMPCOMP_HIGH);
384:                 #endif
385:                 	lcd_clear_area_xy(LCD_RAM_PAGES, LCD_WIDTH, NORMAL, 0, 0); //clear display content
386:                 
387:                 	LCD_SWITCH_ON(); //Switch display on
9D077A5C  240400A9   ADDIU A0, ZERO, 169
9D077A6C  0B41E3EE   J lcd_command
9D077A70  27BD0020   ADDIU SP, SP, 32
388:                 	return;
389:                 }
9D077A60  8FBF001C   LW RA, 28(SP)
9D077A64  8FB10018   LW S1, 24(SP)
9D077A68  8FB00014   LW S0, 20(SP)
9D077A6C  0B41E3EE   J lcd_command
9D077A70  27BD0020   ADDIU SP, SP, 32
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/conv.c  ---------------
1:                   /*___________________________________________________
2:                    |  _____                       _____ _ _       _    |
3:                    | |  __ \                     |  __ (_) |     | |   |
4:                    | | |__) |__ _ __   __ _ _   _| |__) || | ___ | |_  |
5:                    | |  ___/ _ \ '_ \ / _` | | | |  ___/ | |/ _ \| __| |
6:                    | | |  |  __/ | | | (_| | |_| | |   | | | (_) | |_  |
7:                    | |_|   \___|_| |_|\__, |\__,_|_|   |_|_|\___/ \__| |
8:                    |                   __/ |                           |
9:                    |  GNU/Linux based |___/  Multi-Rotor UAV Autopilot |
10:                   |___________________________________________________|
11:                    
12:                   Conversions Implementation
13:                  
14:                   Copyright (C) 2014 Tobias Simon, Integrated Communication Systems Group, TU Ilmenau
15:                  
16:                   This program is free software; you can redistribute it and/or modify
17:                   it under the terms of the GNU General Public License as published by
18:                   the Free Software Foundation; either version 2 of the License, or
19:                   (at your option) any later version.
20:                  
21:                   This program is distributed in the hope that it will be useful,
22:                   but WITHOUT ANY WARRANTY; without even the implied warranty of
23:                   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
24:                   GNU General Public License for more details. */
25:                  
26:                  
27:                  
28:                  #include <math.h>
29:                  
30:                  
31:                  float deg2rad(float x)
32:                  {
33:                     return x * (float)(M_PI / 180.0);
00000000  00000000   NOP
34:                  }
00000008  00000000   NOP
35:                  
36:                  
37:                  float rad2deg(float x)
38:                  {
39:                     return x * (float)(180.0 / M_PI);
00000000  00000000   NOP
40:                  }
00000008  00000000   NOP
41:                  
42:                  
43:                  float norm_angle_0_2pi(float a)
44:                  {
00000000  00000000   NOP
45:                     a = fmod(a, M_PI * 2);
00000020  00000000   NOP
46:                     if (a < 0)
00000024  00000000   NOP
47:                     {
48:                        a += M_PI * 2;
00000034  00000000   NOP
49:                     }
50:                     return a;
51:                  }
00000040  00000000   NOP
52:                  
53:                  
54:                  float norm_angle_sym_pi(float a)
55:                  {
00000000  00000000   NOP
00000014  00000000   NOP
56:                     if (a < -M_PI)
00000018  00000000   NOP
57:                     {
58:                        a = fmod(a, M_PI * 2.0f);
000000A4  00000000   NOP
59:                        if (a < -M_PI)
000000A8  00000000   NOP
60:                        {
61:                           a += M_PI * 2.0f;
000000B8  00000000   NOP
62:                        }
63:                     }
64:                     else if (a > M_PI)
00000030  00000000   NOP
65:                     {
66:                        a = fmod(a, M_PI * 2.0f);
00000064  00000000   NOP
67:                        if (a > M_PI)
00000068  00000000   NOP
68:                        {
69:                           a -= M_PI * 2.0f;
00000078  00000000   NOP
70:                        }
71:                     }
72:                     return a;
73:                  }
00000040  00000000   NOP
00000080  00000000   NOP
000000C0  00000000   NOP
74:                  
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/stdio/xc32_monitor.c
1:                   /*******************************************************************************
2:                    Debug Console Source file
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       xc32_monitor.c
9:                   
10:                    Summary:
11:                      debug console Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  
42:                  #ifdef __arm__
43:                  /* Declaration of these functions are missing in stdio.h for ARM parts*/
44:                  int _mon_getc(int canblock);
45:                  void _mon_putc(char c);
46:                  #endif //__arm__
47:                  
48:                  int _mon_getc(int canblock)
49:                  {
50:                     return 0;
51:                  }
00000000  00000000   NOP
52:                  
53:                  void _mon_putc(char c)
54:                  {
9D079218  03E00008   JR RA
9D07921C  00000000   NOP
55:                  }
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/uart/plib_uart2.c
1:                   /*******************************************************************************
2:                     UART2 PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_uart2.c
9:                   
10:                    Summary:
11:                      UART2 PLIB Implementation File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "plib_uart2.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: UART2 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  UART_RING_BUFFER_OBJECT uart2Obj;
51:                  
52:                  #define UART2_READ_BUFFER_SIZE      128
53:                  #define UART2_RX_INT_DISABLE()      IEC1CLR = _IEC1_U2RXIE_MASK;
54:                  #define UART2_RX_INT_ENABLE()       IEC1SET = _IEC1_U2RXIE_MASK;
55:                  
56:                  static uint8_t UART2_ReadBuffer[UART2_READ_BUFFER_SIZE];
57:                  
58:                  #define UART2_WRITE_BUFFER_SIZE     128
59:                  #define UART2_TX_INT_DISABLE()      IEC1CLR = _IEC1_U2TXIE_MASK;
60:                  #define UART2_TX_INT_ENABLE()       IEC1SET = _IEC1_U2TXIE_MASK;
61:                  
62:                  static uint8_t UART2_WriteBuffer[UART2_WRITE_BUFFER_SIZE];
63:                  
64:                  void static UART2_ErrorClear( void )
65:                  {
66:                      /* rxBufferLen = (FIFO level + RX register) */
67:                      uint8_t rxBufferLen = UART_RXFIFO_DEPTH;
68:                      uint8_t dummyData = 0u;
69:                  
70:                      /* If it's a overrun error then clear it to flush FIFO */
71:                      if(U2STA & _U2STA_OERR_MASK)
0000001C  00000000   NOP
72:                      {
73:                          U2STACLR = _U2STA_OERR_MASK;
00000070  00000000   NOP
74:                      }
75:                  
76:                      /* Read existing error bytes from FIFO to clear parity and framing error flags */
77:                      while(U2STA & (_U2STA_FERR_MASK | _U2STA_PERR_MASK))
00000030  00000000   NOP
78:                      {
79:                          dummyData = (uint8_t )(U2RXREG );
00000048  00000000   NOP
80:                          rxBufferLen--;
81:                  
82:                          /* Try to flush error bytes for one full FIFO and exit instead of
83:                           * blocking here if more error bytes are received */
84:                          if(rxBufferLen == 0u)
0000004C  00000000   NOP
85:                          {
86:                              break;
87:                          }
88:                      }
89:                  
90:                      // Ignore the warning
91:                      (void)dummyData;
92:                  
93:                      /* Clear error interrupt flag */
94:                      IFS1CLR = _IFS1_U2EIF_MASK;
00000054  00000000   NOP
95:                  
96:                      /* Clear up the receive interrupt flag so that RX interrupt is not
97:                       * triggered for error bytes */
98:                      IFS1CLR = _IFS1_U2RXIF_MASK;
00000060  00000000   NOP
99:                  
100:                     return;
101:                 }
102:                 
103:                 void UART2_Initialize( void )
104:                 {
105:                     /* Set up UxMODE bits */
106:                     /* STSEL  = 0*/
107:                     /* PDSEL = 0 */
108:                     /* BRGH = 1 */
109:                     /* RXINV = 0 */
110:                     /* ABAUD = 0 */
111:                     /* LPBACK = 0 */
112:                     /* WAKE = 0 */
113:                     /* SIDL = 0 */
114:                     /* RUNOVF = 0 */
115:                     /* CLKSEL = 0 */
116:                     /* SLPEN = 0 */
117:                     U2MODE = 0x8;
9D078508  3C03BF83   LUI V1, -16509
9D078510  24060008   ADDIU A2, ZERO, 8
9D078514  AC668200   SW A2, -32256(V1)
118:                 
119:                     /* Enable UART2 Receiver, Transmitter and TX Interrupt selection */
120:                     U2STASET = (_U2STA_UTXEN_MASK | _U2STA_URXEN_MASK | _U2STA_UTXISEL1_MASK);
9D07851C  34069400   ORI A2, ZERO, -27648
9D078520  AC668218   SW A2, -32232(V1)
121:                 
122:                     /* BAUD Rate register Setup */
123:                     U2BRG = 129;
9D078528  24060081   ADDIU A2, ZERO, 129
9D07852C  AC668240   SW A2, -32192(V1)
124:                 
125:                     IEC1CLR = _IEC1_U2TXIE_MASK;
9D07850C  3C04BF81   LUI A0, -16511
9D078534  3C060400   LUI A2, 1024
9D078538  AC8600D4   SW A2, 212(A0)
126:                 
127:                     /* Initialize instance object */
128:                     uart2Obj.rdCallback = NULL;
9D078500  3C058000   LUI A1, -32768
9D078504  24A2017C   ADDIU V0, A1, 380
9D078518  AC40001C   SW ZERO, 28(V0)
129:                     uart2Obj.rdInIndex = 0;
9D078540  AC400024   SW ZERO, 36(V0)
130:                     uart2Obj.rdOutIndex = 0;
9D078548  AC400028   SW ZERO, 40(V0)
131:                     uart2Obj.isRdNotificationEnabled = false;
9D078524  A040002C   SB ZERO, 44(V0)
132:                     uart2Obj.isRdNotifyPersistently = false;
9D078530  A0400034   SB ZERO, 52(V0)
133:                     uart2Obj.rdThreshold = 0;
9D07853C  AC400030   SW ZERO, 48(V0)
134:                 
135:                     uart2Obj.wrCallback = NULL;
9D078544  ACA0017C   SW ZERO, 380(A1)
136:                     uart2Obj.wrInIndex = 0;
9D078550  AC400008   SW ZERO, 8(V0)
137:                     uart2Obj.wrOutIndex = 0;
9D078558  AC40000C   SW ZERO, 12(V0)
138:                     uart2Obj.isWrNotificationEnabled = false;
9D07854C  A0400010   SB ZERO, 16(V0)
139:                     uart2Obj.isWrNotifyPersistently = false;
9D078554  A0400018   SB ZERO, 24(V0)
140:                     uart2Obj.wrThreshold = 0;
9D07855C  AC400014   SW ZERO, 20(V0)
141:                 
142:                     /* Turn ON UART2 */
143:                     U2MODESET = _U2MODE_ON_MASK;
9D078560  34028000   ORI V0, ZERO, -32768
9D078564  AC628208   SW V0, -32248(V1)
144:                 
145:                     /* Enable UART2_FAULT Interrupt */
146:                     IEC1SET = _IEC1_U2EIE_MASK;
9D078568  3C020100   LUI V0, 256
9D07856C  AC8200D8   SW V0, 216(A0)
147:                 
148:                     /* Enable UART2_RX Interrupt */
149:                     IEC1SET = _IEC1_U2RXIE_MASK;
9D078570  3C020200   LUI V0, 512
9D078574  AC8200D8   SW V0, 216(A0)
9D078578  03E00008   JR RA
9D07857C  00000000   NOP
150:                 }
151:                 
152:                 bool UART2_SerialSetup( UART_SERIAL_SETUP *setup, uint32_t srcClkFreq )
153:                 {
154:                     bool status = false;
000000C8  00000000   NOP
155:                     uint32_t baud;
156:                     int32_t brgValHigh = 0;
157:                     int32_t brgValLow = 0;
158:                     uint32_t brgVal = 0;
159:                     uint32_t uartMode;
160:                 
161:                     if (setup != NULL)
00000000  00000000   NOP
162:                     {
163:                         baud = setup->baudRate;
00000008  00000000   NOP
164:                 
165:                         if (baud == 0)
0000000C  00000000   NOP
166:                         {
167:                             return status;
168:                         }
169:                 
170:                         /* Turn OFF UART2 */
171:                         U2MODECLR = _U2MODE_ON_MASK;
00000014  00000000   NOP
172:                 
173:                         if(srcClkFreq == 0)
0000001C  00000000   NOP
174:                         {
175:                             srcClkFreq = UART2_FrequencyGet();
176:                         }
177:                 
178:                         /* Calculate BRG value */
179:                         brgValLow = (((srcClkFreq >> 4) + (baud >> 1)) / baud ) - 1;
0000002C  00000000   NOP
00000044  00000000   NOP
180:                         brgValHigh = (((srcClkFreq >> 2) + (baud >> 1)) / baud ) - 1;
000000AC  00000000   NOP
181:                 
182:                         /* Check if the baud value can be set with low baud settings */
183:                         if((brgValLow >= 0) && (brgValLow <= UINT16_MAX))
00000040  00000000   NOP
00000048  00000000   NOP
184:                         {
185:                             brgVal =  brgValLow;
186:                             U2MODECLR = _U2MODE_BRGH_MASK;
00000054  00000000   NOP
187:                         }
188:                         else if ((brgValHigh >= 0) && (brgValHigh <= UINT16_MAX))
000000BC  00000000   NOP
189:                         {
190:                             brgVal = brgValHigh;
191:                             U2MODESET = _U2MODE_BRGH_MASK;
000000E0  00000000   NOP
192:                         }
193:                         else
194:                         {
195:                             return status;
196:                         }
197:                 
198:                         if(setup->dataWidth == UART_DATA_9_BIT)
0000005C  00000000   NOP
000000E4  00000000   NOP
199:                         {
200:                             if(setup->parity != UART_PARITY_NONE)
000000F4  00000000   NOP
201:                             {
202:                                return status;
203:                             }
204:                             else
205:                             {
206:                                /* Configure UART2 mode */
207:                                uartMode = U2MODE;
00000100  00000000   NOP
208:                                uartMode &= ~_U2MODE_PDSEL_MASK;
209:                                U2MODE = uartMode | setup->dataWidth;
00000104  00000000   NOP
210:                             }
211:                         }
212:                         else
213:                         {
214:                             /* Configure UART2 mode */
215:                             uartMode = U2MODE;
0000006C  00000000   NOP
216:                             uartMode &= ~_U2MODE_PDSEL_MASK;
00000074  00000000   NOP
217:                             U2MODE = uartMode | setup->parity ;
00000070  00000000   NOP
00000078  00000000   NOP
218:                         }
219:                 
220:                         /* Configure UART2 mode */
221:                         uartMode = U2MODE;
00000080  00000000   NOP
222:                         uartMode &= ~_U2MODE_STSEL_MASK;
00000088  00000000   NOP
223:                         U2MODE = uartMode | setup->stopBits ;
00000084  00000000   NOP
0000008C  00000000   NOP
224:                 
225:                         /* Configure UART2 Baud Rate */
226:                         U2BRG = brgVal;
00000098  00000000   NOP
227:                 
228:                         U2MODESET = _U2MODE_ON_MASK;
0000009C  00000000   NOP
229:                 
230:                         status = true;
00000094  00000000   NOP
231:                     }
232:                 
233:                     return status;
234:                 }
000000A4  00000000   NOP
235:                 
236:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
237:                 static inline bool UART2_RxPushByte(uint8_t rdByte)
238:                 {
239:                     uint32_t tempInIndex;
240:                     bool isSuccess = false;
241:                 
242:                     tempInIndex = uart2Obj.rdInIndex + 1;
9D076AA4  3C108000   LUI S0, -32768
9D076AA8  2610017C   ADDIU S0, S0, 380
9D076AC8  8E020024   LW V0, 36(S0)
9D076AD4  24420001   ADDIU V0, V0, 1
243:                 
244:                     if (tempInIndex >= UART2_READ_BUFFER_SIZE)
9D076AD8  2C440080   SLTIU A0, V0, 128
245:                     {
246:                         tempInIndex = 0;
9D076ADC  0004100A   MOVZ V0, ZERO, A0
247:                     }
248:                 
249:                     if (tempInIndex == uart2Obj.rdOutIndex)
9D076ACC  8E030028   LW V1, 40(S0)
9D076AE0  50620029   BEQL V1, V0, .LVL101, .LBB74
9D076AE4  8E03001C   LW V1, 28(S0)
250:                     {
251:                         /* Queue is full - Report it to the application. Application gets a chance to free up space by reading data out from the RX ring buffer */
252:                         if(uart2Obj.rdCallback != NULL)
9D076B88  1060FFD7   BEQ V1, ZERO, 0x9D076AE8
9D076B8C  00000000   NOP
253:                         {
254:                             uart2Obj.rdCallback(UART_EVENT_READ_BUFFER_FULL, uart2Obj.rdContext);
9D076B90  8E050020   LW A1, 32(S0)
9D076B94  0060F809   JALR V1
9D076B98  24040001   ADDIU A0, ZERO, 1
255:                 
256:                             /* Read the indices again in case application has freed up space in RX ring buffer */
257:                             tempInIndex = uart2Obj.rdInIndex + 1;
9D076B9C  8E020024   LW V0, 36(S0)
9D076BA0  24420001   ADDIU V0, V0, 1
258:                 
259:                             if (tempInIndex >= UART2_READ_BUFFER_SIZE)
9D076BA4  2C430080   SLTIU V1, V0, 128
260:                             {
261:                                 tempInIndex = 0;
9D076BA8  0B41DABA   J 0x9D076AE8
9D076BAC  0003100A   MOVZ V0, ZERO, V1
262:                             }
263:                         }
264:                     }
265:                 
266:                     if (tempInIndex != uart2Obj.rdOutIndex)
9D076AE8  8E030028   LW V1, 40(S0)
9D076AEC  1062FFF1   BEQ V1, V0, .LBE58
9D076AF0  00000000   NOP
267:                     {
268:                         UART2_ReadBuffer[uart2Obj.rdInIndex] = rdByte;
9D076AAC  3C148000   LUI S4, -32768
9D076AB0  26941A40   ADDIU S4, S4, 6720
9D076AF4  8E040024   LW A0, 36(S0)
9D076B00  00941021   ADDU V0, A0, S4
269:                         uart2Obj.rdInIndex = tempInIndex;
9D076AFC  AE020024   SW V0, 36(S0)
270:                         isSuccess = true;
271:                     }
272:                     else
273:                     {
274:                         /* Queue is full. Data will be lost. */
275:                     }
276:                 
277:                     return isSuccess;
278:                 }
279:                 
280:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
281:                 static void UART2_ReadNotificationSend(void)
282:                 {
283:                     uint32_t nUnreadBytesAvailable;
284:                 
285:                     if (uart2Obj.isRdNotificationEnabled == true)
9D076AF8  9203002C   LBU V1, 44(S0)
9D076B04  1060FFEB   BEQ V1, ZERO, .LBE58
9D076B08  A0510000   SB S1, 0(V0)
286:                     {
287:                         nUnreadBytesAvailable = UART2_ReadCountGet();
288:                 
289:                         if(uart2Obj.rdCallback != NULL)
9D076B20  8E06001C   LW A2, 28(S0)
9D076B24  10C0FFE3   BEQ A2, ZERO, .LBE58
9D076B28  00621023   SUBU V0, V1, V0
290:                         {
291:                             if (uart2Obj.isRdNotifyPersistently == true)
9D076B2C  92030034   LBU V1, 52(S0)
9D076B30  1060001F   BEQ V1, ZERO, .LVL105, .LBB75
9D076B34  8E030030   LW V1, 48(S0)
292:                             {
293:                                 if (nUnreadBytesAvailable >= uart2Obj.rdThreshold)
9D076B38  0043102B   SLTU V0, V0, V1
9D076B3C  1440FFDD   BNE V0, ZERO, .LBE58
9D076B40  00000000   NOP
294:                                 {
295:                                     uart2Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart2Obj.rdContext);
296:                                 }
297:                             }
298:                             else
299:                             {
300:                                 if (nUnreadBytesAvailable == uart2Obj.rdThreshold)
9D076BB0  1443FFC0   BNE V0, V1, .LBE58
9D076BB4  00000000   NOP
301:                                 {
302:                                     uart2Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart2Obj.rdContext);
9D076B44  8E050020   LW A1, 32(S0)
9D076B48  00C0F809   JALR A2
9D076B4C  00002021   ADDU A0, ZERO, ZERO
9D076BB8  0B41DAD2   J 0x9D076B48
9D076BBC  8E050020   LW A1, 32(S0)
303:                                 }
304:                             }
305:                         }
306:                     }
307:                 }
308:                 
309:                 size_t UART2_Read(uint8_t* pRdBuffer, const size_t size)
310:                 {
311:                     size_t nBytesRead = 0;
00000028  00000000   NOP
00000094  00000000   NOP
000000A8  00000000   NOP
312:                     uint32_t rdOutIndex;
313:                     uint32_t rdInIndex;
314:                 
315:                     while (nBytesRead < size)
00000000  00000000   NOP
00000084  00000000   NOP
316:                     {
317:                         UART2_RX_INT_DISABLE();
00000008  00000000   NOP
0000003C  00000000   NOP
318:                 
319:                         rdOutIndex = uart2Obj.rdOutIndex;
00000010  00000000   NOP
00000040  00000000   NOP
320:                         rdInIndex = uart2Obj.rdInIndex;
0000001C  00000000   NOP
00000044  00000000   NOP
321:                 
322:                         if (rdOutIndex != rdInIndex)
00000020  00000000   NOP
00000048  00000000   NOP
323:                         {
324:                             pRdBuffer[nBytesRead++] = UART2_ReadBuffer[uart2Obj.rdOutIndex++];
00000050  00000000   NOP
325:                 
326:                             if (uart2Obj.rdOutIndex >= UART2_READ_BUFFER_SIZE)
00000070  00000000   NOP
327:                             {
328:                                 uart2Obj.rdOutIndex = 0;
329:                             }
330:                             UART2_RX_INT_ENABLE();
00000030  00000000   NOP
00000080  00000000   NOP
331:                         }
332:                         else
333:                         {
334:                             UART2_RX_INT_ENABLE();
00000098  00000000   NOP
335:                             break;
000000A0  00000000   NOP
336:                         }
337:                     }
338:                 
339:                     return nBytesRead;
340:                 }
341:                 
342:                 size_t UART2_ReadCountGet(void)
343:                 {
344:                     size_t nUnreadBytesAvailable;
345:                     uint32_t rdInIndex;
346:                     uint32_t rdOutIndex;
347:                 
348:                     /* Take a snapshot of indices to avoid creation of critical section */
349:                     rdInIndex = uart2Obj.rdInIndex;
9D076B0C  8E030024   LW V1, 36(S0)
00000000  00000000   NOP
350:                     rdOutIndex = uart2Obj.rdOutIndex;
9D076B10  8E020028   LW V0, 40(S0)
0000000C  00000000   NOP
351:                 
352:                     if ( rdInIndex >=  rdOutIndex)
9D076B14  0062202B   SLTU A0, V1, V0
00000010  00000000   NOP
353:                     {
354:                         nUnreadBytesAvailable =  rdInIndex -  rdOutIndex;
355:                     }
356:                     else
357:                     {
358:                         nUnreadBytesAvailable =  (UART2_READ_BUFFER_SIZE -  rdOutIndex) + rdInIndex;
359:                     }
360:                 
361:                     return nUnreadBytesAvailable;
362:                 }
0000001C  00000000   NOP
363:                 
364:                 size_t UART2_ReadFreeBufferCountGet(void)
365:                 {
366:                     return (UART2_READ_BUFFER_SIZE - 1) - UART2_ReadCountGet();
00000020  00000000   NOP
367:                 }
00000024  00000000   NOP
368:                 
369:                 size_t UART2_ReadBufferSizeGet(void)
370:                 {
371:                     return (UART2_READ_BUFFER_SIZE - 1);
372:                 }
373:                 
374:                 bool UART2_ReadNotificationEnable(bool isEnabled, bool isPersistent)
375:                 {
376:                     bool previousStatus = uart2Obj.isRdNotificationEnabled;
00000000  00000000   NOP
377:                 
378:                     uart2Obj.isRdNotificationEnabled = isEnabled;
379:                 
380:                     uart2Obj.isRdNotifyPersistently = isPersistent;
0000000C  00000000   NOP
381:                 
382:                     return previousStatus;
383:                 }
00000010  00000000   NOP
384:                 
385:                 void UART2_ReadThresholdSet(uint32_t nBytesThreshold)
386:                 {
387:                     if (nBytesThreshold > 0)
00000000  00000000   NOP
388:                     {
389:                         uart2Obj.rdThreshold = nBytesThreshold;
00000008  00000000   NOP
390:                     }
391:                 }
392:                 
393:                 void UART2_ReadCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
394:                 {
395:                     uart2Obj.rdCallback = callback;
00000000  00000000   NOP
396:                 
397:                     uart2Obj.rdContext = context;
0000000C  00000000   NOP
398:                 }
399:                 
400:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
401:                 static bool UART2_TxPullByte(uint8_t* pWrByte)
402:                 {
403:                     bool isSuccess = false;
404:                     uint32_t wrOutIndex = uart2Obj.wrOutIndex;
9D000064  8E03000C   LW V1, 12(S0)
405:                     uint32_t wrInIndex = uart2Obj.wrInIndex;
9D000068  8E020008   LW V0, 8(S0)
406:                 
407:                     if (wrOutIndex != wrInIndex)
9D00006C  5062003E   BEQL V1, V0, .LVL130
9D000070  3C02BF81   LUI V0, -16511
408:                     {
409:                         *pWrByte = UART2_WriteBuffer[uart2Obj.wrOutIndex++];
9D000048  3C128000   LUI S2, -32768
9D00004C  265219C0   ADDIU S2, S2, 6592
9D000074  8E02000C   LW V0, 12(S0)
9D000078  24430001   ADDIU V1, V0, 1
9D00007C  AE03000C   SW V1, 12(S0)
410:                 
411:                         if (uart2Obj.wrOutIndex >= UART2_WRITE_BUFFER_SIZE)
9D000080  8E03000C   LW V1, 12(S0)
9D000084  2C630080   SLTIU V1, V1, 128
9D000088  14600002   BNE V1, ZERO, .LVL117, .LBE106, .LBB107
9D00008C  7E42118A   LBUX V0, V0(S2)
412:                         {
413:                             uart2Obj.wrOutIndex = 0;
9D000090  AE00000C   SW ZERO, 12(S0)
414:                         }
415:                         isSuccess = true;
416:                     }
417:                 
418:                     return isSuccess;
419:                 }
420:                 
421:                 static inline bool UART2_TxPushByte(uint8_t wrByte)
422:                 {
423:                     uint32_t tempInIndex;
424:                     bool isSuccess = false;
425:                 
426:                     tempInIndex = uart2Obj.wrInIndex + 1;
00000040  00000000   NOP
00000048  00000000   NOP
427:                 
428:                     if (tempInIndex >= UART2_WRITE_BUFFER_SIZE)
0000004C  00000000   NOP
429:                     {
430:                         tempInIndex = 0;
00000050  00000000   NOP
431:                     }
432:                     if (tempInIndex != uart2Obj.wrOutIndex)
00000044  00000000   NOP
00000054  00000000   NOP
433:                     {
434:                         UART2_WriteBuffer[uart2Obj.wrInIndex] = wrByte;
0000001C  00000000   NOP
00000034  00000000   NOP
435:                         uart2Obj.wrInIndex = tempInIndex;
00000030  00000000   NOP
436:                         isSuccess = true;
437:                     }
438:                     else
439:                     {
440:                         /* Queue is full. Report Error. */
441:                     }
442:                 
443:                     return isSuccess;
444:                 }
445:                 
446:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
447:                 static void UART2_WriteNotificationSend(void)
448:                 {
449:                     uint32_t nFreeWrBufferCount;
450:                 
451:                     if (uart2Obj.isWrNotificationEnabled == true)
9D000094  92030010   LBU V1, 16(S0)
9D00009C  1060FFED   BEQ V1, ZERO, .LVL110, .LBE95, .LBE93
9D0000A0  00000000   NOP
452:                     {
453:                         nFreeWrBufferCount = UART2_WriteFreeBufferCountGet();
454:                 
455:                         if(uart2Obj.wrCallback != NULL)
9D0000BC  8E66017C   LW A2, 380(S3)
9D0000C0  10C0FFE4   BEQ A2, ZERO, .LVL110, .LBE95, .LBE93
9D0000C4  02821023   SUBU V0, S4, V0
456:                         {
457:                             if (uart2Obj.isWrNotifyPersistently == true)
9D0000C8  92030018   LBU V1, 24(S0)
9D0000CC  10600015   BEQ V1, ZERO, .LVL126, .LBB109
9D0000D0  8E030014   LW V1, 20(S0)
458:                             {
459:                                 if (nFreeWrBufferCount >= uart2Obj.wrThreshold)
9D0000D4  0043102B   SLTU V0, V0, V1
9D0000D8  1440FFDE   BNE V0, ZERO, .LVL110, .LBE95, .LBE93
9D0000DC  00000000   NOP
460:                                 {
461:                                     uart2Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart2Obj.wrContext);
462:                                 }
463:                             }
464:                             else
465:                             {
466:                                 if (nFreeWrBufferCount == uart2Obj.wrThreshold)
9D000124  1443FFCB   BNE V0, V1, .LVL110, .LBE95, .LBE93
9D000128  00000000   NOP
467:                                 {
468:                                     uart2Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart2Obj.wrContext);
9D0000E0  8E050004   LW A1, 4(S0)
9D0000E4  00C0F809   JALR A2
9D0000E8  24040003   ADDIU A0, ZERO, 3
9D00012C  8E050004   LW A1, 4(S0)
9D000130  00C0F809   JALR A2
9D000134  24040003   ADDIU A0, ZERO, 3
9D000138  0B40003B   J .LVL124, .LBE108
9D00013C  00000000   NOP
469:                                 }
470:                             }
471:                         }
472:                     }
473:                 }
474:                 
475:                 static size_t UART2_WritePendingBytesGet(void)
476:                 {
477:                     size_t nPendingTxBytes;
478:                 
479:                     /* Take a snapshot of indices to avoid creation of critical section */
480:                     uint32_t wrOutIndex = uart2Obj.wrOutIndex;
9D00001C  3C138000   LUI S3, -32768
9D0000A4  8E02000C   LW V0, 12(S0)
0000005C  00000000   NOP
481:                     uint32_t wrInIndex = uart2Obj.wrInIndex;
9D000028  8E030008   LW V1, 8(S0)
9D0000A8  8E030008   LW V1, 8(S0)
0000000C  00000000   NOP
00000060  00000000   NOP
482:                 
483:                     if ( wrInIndex >=  wrOutIndex)
9D00002C  0062202B   SLTU A0, V1, V0
9D0000AC  0062202B   SLTU A0, V1, V0
00000010  00000000   NOP
00000064  00000000   NOP
484:                     {
485:                         nPendingTxBytes =  wrInIndex -  wrOutIndex;
486:                     }
487:                     else
488:                     {
489:                         nPendingTxBytes =  (UART2_WRITE_BUFFER_SIZE -  wrOutIndex) + wrInIndex;
9D000038  00621023   SUBU V0, V1, V0
9D0000B8  00621023   SUBU V0, V1, V0
0000001C  00000000   NOP
00000070  00000000   NOP
490:                     }
491:                 
492:                     return nPendingTxBytes;
493:                 }
494:                 
495:                 size_t UART2_WriteCountGet(void)
496:                 {
00000000  00000000   NOP
497:                     size_t nPendingTxBytes;
498:                 
499:                     nPendingTxBytes = UART2_WritePendingBytesGet();
500:                 
501:                     return nPendingTxBytes;
502:                 }
0000001C  00000000   NOP
503:                 
504:                 size_t UART2_Write(uint8_t* pWrBuffer, const size_t size )
505:                 {
506:                     size_t nBytesWritten  = 0;
0000000C  00000000   NOP
507:                 
508:                     UART2_TX_INT_DISABLE();
00000000  00000000   NOP
509:                 
510:                     while (nBytesWritten < size)
00000014  00000000   NOP
00000038  00000000   NOP
511:                     {
512:                         if (UART2_TxPushByte(pWrBuffer[nBytesWritten]) == true)
513:                         {
514:                             nBytesWritten++;
0000002C  00000000   NOP
515:                         }
516:                         else
517:                         {
518:                             /* Queue is full, exit the loop */
519:                             break;
520:                         }
521:                     }
522:                 
523:                     /* Check if any data is pending for transmission */
524:                     if (UART2_WritePendingBytesGet() > 0)
00000074  00000000   NOP
525:                     {
526:                         /* Enable TX interrupt as data is pending for transmission */
527:                         UART2_TX_INT_ENABLE();
0000007C  00000000   NOP
528:                     }
529:                 
530:                     return nBytesWritten;
531:                 }
00000080  00000000   NOP
532:                 
533:                 size_t UART2_WriteFreeBufferCountGet(void)
534:                 {
00000000  00000000   NOP
535:                     return (UART2_WRITE_BUFFER_SIZE - 1) - UART2_WriteCountGet();
9D000050  2414007F   ADDIU S4, ZERO, 127
00000020  00000000   NOP
536:                 }
00000024  00000000   NOP
537:                 
538:                 size_t UART2_WriteBufferSizeGet(void)
539:                 {
540:                     return (UART2_WRITE_BUFFER_SIZE - 1);
541:                 }
542:                 
543:                 bool UART2_WriteNotificationEnable(bool isEnabled, bool isPersistent)
544:                 {
545:                     bool previousStatus = uart2Obj.isWrNotificationEnabled;
00000000  00000000   NOP
546:                 
547:                     uart2Obj.isWrNotificationEnabled = isEnabled;
548:                 
549:                     uart2Obj.isWrNotifyPersistently = isPersistent;
0000000C  00000000   NOP
550:                 
551:                     return previousStatus;
552:                 }
00000010  00000000   NOP
553:                 
554:                 void UART2_WriteThresholdSet(uint32_t nBytesThreshold)
555:                 {
556:                     if (nBytesThreshold > 0)
00000000  00000000   NOP
557:                     {
558:                         uart2Obj.wrThreshold = nBytesThreshold;
00000008  00000000   NOP
559:                     }
560:                 }
561:                 
562:                 void UART2_WriteCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
563:                 {
564:                     uart2Obj.wrCallback = callback;
00000000  00000000   NOP
00000008  00000000   NOP
565:                 
566:                     uart2Obj.wrContext = context;
00000004  00000000   NOP
0000000C  00000000   NOP
567:                 }
568:                 
569:                 UART_ERROR UART2_ErrorGet( void )
570:                 {
0000002C  00000000   NOP
00000074  00000000   NOP
571:                     UART_ERROR errors = UART_ERROR_NONE;
572:                     uint32_t status = U2STA;
00000000  00000000   NOP
573:                 
574:                     errors = (UART_ERROR)(status & (_U2STA_OERR_MASK | _U2STA_FERR_MASK | _U2STA_PERR_MASK));
00000008  00000000   NOP
575:                 
576:                     if(errors != UART_ERROR_NONE)
0000000C  00000000   NOP
577:                     {
578:                         UART2_ErrorClear();
579:                     }
580:                 
581:                     /* All errors are cleared, but send the previous error state */
582:                     return errors;
583:                 }
00000014  00000000   NOP
00000068  00000000   NOP
584:                 
585:                 bool UART2_AutoBaudQuery( void )
586:                 {
587:                     if(U2MODE & _U2MODE_ABAUD_MASK)
00000000  00000000   NOP
588:                         return true;
589:                     else
590:                         return false;
591:                 }
00000008  00000000   NOP
592:                 
593:                 void UART2_AutoBaudSet( bool enable )
594:                 {
595:                     if( enable == true )
00000000  00000000   NOP
596:                     {
597:                         U2MODESET = _U2MODE_ABAUD_MASK;
00000008  00000000   NOP
598:                     }
599:                 
600:                     /* Turning off ABAUD if it was on can lead to unpredictable behavior, so that
601:                        direction of control is not allowed in this function.                      */
602:                 }
603:                 
604:                 void UART2_FAULT_InterruptHandler (void)
605:                 {
606:                     /* Disable the fault interrupt */
607:                     IEC1CLR = _IEC1_U2EIE_MASK;
9D078DE8  3C02BF81   LUI V0, -16511
9D078DEC  3C040100   LUI A0, 256
9D078DF0  AC4400D4   SW A0, 212(V0)
608:                     /* Disable the receive interrupt */
609:                     IEC1CLR = _IEC1_U2RXIE_MASK;
9D078DF4  3C040200   LUI A0, 512
9D078DF8  AC4400D4   SW A0, 212(V0)
610:                 
611:                     /* Client must call UARTx_ErrorGet() function to clear the errors */
612:                     if( uart2Obj.rdCallback != NULL )
9D078DDC  3C038000   LUI V1, -32768
9D078DE0  2463017C   ADDIU V1, V1, 380
9D078DE4  8C79001C   LW T9, 28(V1)
9D078DFC  13200004   BEQ T9, ZERO, .LVL87
9D078E00  00000000   NOP
613:                     {
614:                         uart2Obj.rdCallback(UART_EVENT_READ_ERROR, uart2Obj.rdContext);
9D078E04  8C650020   LW A1, 32(V1)
9D078E08  03200008   JR T9
9D078E0C  24040002   ADDIU A0, ZERO, 2
9D078E10  03E00008   JR RA
9D078E14  00000000   NOP
615:                     }
616:                 }
617:                 
618:                 void UART2_RX_InterruptHandler (void)
619:                 {
9D076A80  27BDFFD8   ADDIU SP, SP, -40
9D076A84  AFBF0024   SW RA, 36(SP)
9D076A88  AFB40020   SW S4, 32(SP)
9D076A8C  AFB3001C   SW S3, 28(SP)
9D076A90  AFB20018   SW S2, 24(SP)
9D076A94  AFB10014   SW S1, 20(SP)
9D076A98  AFB00010   SW S0, 16(SP)
9D076A9C  3C12BF83   LUI S2, -16509
620:                     /* Keep reading until there is a character availabe in the RX FIFO */
621:                     while((U2STA & _U2STA_URXDA_MASK) == _U2STA_URXDA_MASK)
9D076AA0  02409821   ADDU S3, S2, ZERO
9D076AB4  8E428210   LW V0, -32240(S2)
9D076AB8  30420001   ANDI V0, V0, 1
9D076ABC  10400028   BEQ V0, ZERO, .LVL100
9D076AC0  3C030200   LUI V1, 512
9D076B50  8E428210   LW V0, -32240(S2)
9D076B54  30420001   ANDI V0, V0, 1
9D076B58  1440FFDA   BNE V0, ZERO, 0x9D076AC4
9D076B5C  3C030200   LUI V1, 512
622:                     {
623:                         if (UART2_RxPushByte( (uint8_t )(U2RXREG) ) == true)
9D076AC4  8E648230   LW A0, -32208(S3)
9D076AD0  309100FF   ANDI S1, A0, 255
624:                         {
625:                             UART2_ReadNotificationSend();
626:                         }
627:                         else
628:                         {
629:                             /* UART RX buffer is full */
630:                         }
631:                     }
632:                 
633:                     /* Clear UART2 RX Interrupt flag */
634:                     IFS1CLR = _IFS1_U2RXIF_MASK;
9D076B60  3C02BF81   LUI V0, -16511
9D076B64  AC430054   SW V1, 84(V0)
635:                 }
9D076B68  8FBF0024   LW RA, 36(SP)
9D076B6C  8FB40020   LW S4, 32(SP)
9D076B70  8FB3001C   LW S3, 28(SP)
9D076B74  8FB20018   LW S2, 24(SP)
9D076B78  8FB10014   LW S1, 20(SP)
9D076B7C  8FB00010   LW S0, 16(SP)
9D076B80  03E00008   JR RA
9D076B84  27BD0028   ADDIU SP, SP, 40
9D076B88  1060FFD7   BEQ V1, ZERO, 0x9D076AE8
9D076B8C  00000000   NOP
9D076B90  8E050020   LW A1, 32(S0)
9D076B94  0060F809   JALR V1
9D076B98  24040001   ADDIU A0, ZERO, 1
9D076B9C  8E020024   LW V0, 36(S0)
9D076BA0  24420001   ADDIU V0, V0, 1
9D076BA4  2C430080   SLTIU V1, V0, 128
9D076BA8  0B41DABA   J 0x9D076AE8
9D076BAC  0003100A   MOVZ V0, ZERO, V1
9D076BB0  1443FFC0   BNE V0, V1, .LBE58
9D076BB4  00000000   NOP
9D076BB8  0B41DAD2   J 0x9D076B48
9D076BBC  8E050020   LW A1, 32(S0)
636:                 
637:                 void UART2_TX_InterruptHandler (void)
638:                 {
9D000000  27BDFFD8   ADDIU SP, SP, -40
9D000004  AFBF0024   SW RA, 36(SP)
9D000008  AFB40020   SW S4, 32(SP)
9D00000C  AFB3001C   SW S3, 28(SP)
9D000010  AFB20018   SW S2, 24(SP)
9D000014  AFB10014   SW S1, 20(SP)
9D000018  AFB00010   SW S0, 16(SP)
639:                     uint8_t wrByte;
640:                 
641:                     /* Check if any data is pending for transmission */
642:                     if (UART2_WritePendingBytesGet() > 0)
9D00003C  10400040   BEQ V0, ZERO, .LVL128, .LBE109
9D000040  3C030400   LUI V1, 1024
9D000044  3C11BF83   LUI S1, -16509
643:                     {
644:                         /* Keep writing to the TX FIFO as long as there is space */
645:                         while(!(U2STA & _U2STA_UTXBF_MASK))
9D000054  8E228210   LW V0, -32240(S1)
9D000058  30420200   ANDI V0, V0, 512
9D00005C  14400027   BNE V0, ZERO, .LVL125
9D000060  3C02BF81   LUI V0, -16511
9D0000EC  8E228210   LW V0, -32240(S1)
9D0000F0  30420200   ANDI V0, V0, 512
9D0000F4  1040FFDB   BEQ V0, ZERO, .LVL111, .LBB106
9D0000F8  3C02BF81   LUI V0, -16511
646:                         {
647:                             if (UART2_TxPullByte(&wrByte) == true)
648:                             {
649:                                 U2TXREG = wrByte;
9D000098  AE228220   SW V0, -32224(S1)
650:                 
651:                                 /* Send notification */
652:                                 UART2_WriteNotificationSend();
653:                             }
654:                             else
655:                             {
656:                                 /* Nothing to transmit. Disable the data register empty interrupt. */
657:                                 UART2_TX_INT_DISABLE();
9D000168  3C030400   LUI V1, 1024
9D00016C  AC4300D4   SW V1, 212(V0)
658:                                 break;
659:                             }
660:                         }
661:                 
662:                         /* Clear UART2TX Interrupt flag */
663:                         IFS1CLR = _IFS1_U2TXIF_MASK;
9D0000FC  3C030400   LUI V1, 1024
9D000100  AC430054   SW V1, 84(V0)
9D000170  3C030400   LUI V1, 1024
9D000174  AC430054   SW V1, 84(V0)
664:                 
665:                     }
666:                     else
667:                     {
668:                         /* Nothing to transmit. Disable the data register empty interrupt. */
669:                         UART2_TX_INT_DISABLE();
9D000140  3C02BF81   LUI V0, -16511
9D000144  AC4300D4   SW V1, 212(V0)
670:                     }
671:                 }
9D000104  8FBF0024   LW RA, 36(SP)
9D000108  8FB40020   LW S4, 32(SP)
9D00010C  8FB3001C   LW S3, 28(SP)
9D000110  8FB20018   LW S2, 24(SP)
9D000114  8FB10014   LW S1, 20(SP)
9D000118  8FB00010   LW S0, 16(SP)
9D00011C  03E00008   JR RA
9D000120  27BD0028   ADDIU SP, SP, 40
9D000148  8FBF0024   LW RA, 36(SP)
9D00014C  8FB40020   LW S4, 32(SP)
9D000150  8FB3001C   LW S3, 28(SP)
9D000154  8FB20018   LW S2, 24(SP)
9D000158  8FB10014   LW S1, 20(SP)
9D00015C  8FB00010   LW S0, 16(SP)
9D000160  03E00008   JR RA
9D000164  27BD0028   ADDIU SP, SP, 40
9D000178  0B400042   J 0x9D000108
9D00017C  8FBF0024   LW RA, 36(SP)
672:                 
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/uart/plib_uart1.c
1:                   /*******************************************************************************
2:                     UART1 PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_uart1.c
9:                   
10:                    Summary:
11:                      UART1 PLIB Implementation File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "plib_uart1.h"
43:                  #include "../../bsp/bsp.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: UART1 Implementation
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  UART_RING_BUFFER_OBJECT uart1Obj;
52:                  
53:                  #define UART1_READ_BUFFER_SIZE      128
54:                  #define UART1_RX_INT_DISABLE()      IEC1CLR = _IEC1_U1RXIE_MASK;
55:                  #define UART1_RX_INT_ENABLE()       IEC1SET = _IEC1_U1RXIE_MASK;
56:                  
57:                  static uint8_t UART1_ReadBuffer[UART1_READ_BUFFER_SIZE];
58:                  
59:                  #define UART1_WRITE_BUFFER_SIZE     128
60:                  #define UART1_TX_INT_DISABLE()      IEC1CLR = _IEC1_U1TXIE_MASK;
61:                  #define UART1_TX_INT_ENABLE()       IEC1SET = _IEC1_U1TXIE_MASK;
62:                  
63:                  static uint8_t UART1_WriteBuffer[UART1_WRITE_BUFFER_SIZE];
64:                  
65:                  void static UART1_ErrorClear( void )
66:                  {
67:                      /* rxBufferLen = (FIFO level + RX register) */
68:                      uint8_t rxBufferLen = UART_RXFIFO_DEPTH;
69:                      uint8_t dummyData = 0u;
70:                  
71:                      /* If it's a overrun error then clear it to flush FIFO */
72:                      if(U1STA & _U1STA_OERR_MASK)
0000001C  00000000   NOP
73:                      {
74:                          U1STACLR = _U1STA_OERR_MASK;
00000070  00000000   NOP
75:                      }
76:                  
77:                      /* Read existing error bytes from FIFO to clear parity and framing error flags */
78:                      while(U1STA & (_U1STA_FERR_MASK | _U1STA_PERR_MASK))
00000030  00000000   NOP
79:                      {
80:                          dummyData = (uint8_t )(U1RXREG );
00000048  00000000   NOP
81:                          rxBufferLen--;
82:                  
83:                          /* Try to flush error bytes for one full FIFO and exit instead of
84:                           * blocking here if more error bytes are received */
85:                          if(rxBufferLen == 0u)
0000004C  00000000   NOP
86:                          {
87:                              break;
88:                          }
89:                      }
90:                  
91:                      // Ignore the warning
92:                      (void)dummyData;
93:                  
94:                      /* Clear error interrupt flag */
95:                      IFS1CLR = _IFS1_U1EIF_MASK;
00000054  00000000   NOP
96:                  
97:                      /* Clear up the receive interrupt flag so that RX interrupt is not
98:                       * triggered for error bytes */
99:                      IFS1CLR = _IFS1_U1RXIF_MASK;
00000060  00000000   NOP
100:                 
101:                     return;
102:                 }
103:                 
104:                 void UART1_Initialize( void )
105:                 {
106:                     /* Set up UxMODE bits */
107:                     /* STSEL  = 0*/
108:                     /* PDSEL = 0 */
109:                     /* BRGH = 1 */
110:                     /* RXINV = 0 */
111:                     /* ABAUD = 0 */
112:                     /* LPBACK = 0 */
113:                     /* WAKE = 0 */
114:                     /* SIDL = 0 */
115:                     /* RUNOVF = 0 */
116:                     /* CLKSEL = 0 */
117:                     /* SLPEN = 0 */
118:                     U1MODE = 0x8;
9D078488  3C03BF83   LUI V1, -16509
9D078490  24060008   ADDIU A2, ZERO, 8
9D078494  AC668000   SW A2, -32768(V1)
119:                 
120:                     /* Enable UART1 Receiver, Transmitter and TX Interrupt selection */
121:                     U1STASET = (_U1STA_UTXEN_MASK | _U1STA_URXEN_MASK | _U1STA_UTXISEL1_MASK);
9D07849C  34069400   ORI A2, ZERO, -27648
9D0784A0  AC668018   SW A2, -32744(V1)
122:                 
123:                     /* BAUD Rate register Setup */
124:                     U1BRG = 129;
9D0784A8  24060081   ADDIU A2, ZERO, 129
9D0784AC  AC668040   SW A2, -32704(V1)
125:                 
126:                     IEC1CLR = _IEC1_U1TXIE_MASK;
9D07848C  3C04BF81   LUI A0, -16511
9D0784B4  24060100   ADDIU A2, ZERO, 256
9D0784B8  AC8600D4   SW A2, 212(A0)
127:                 
128:                     /* Initialize instance object */
129:                     uart1Obj.rdCallback = NULL;
9D078480  3C058000   LUI A1, -32768
9D078484  24A20144   ADDIU V0, A1, 324
9D078498  AC40001C   SW ZERO, 28(V0)
130:                     uart1Obj.rdInIndex = 0;
9D0784C0  AC400024   SW ZERO, 36(V0)
131:                     uart1Obj.rdOutIndex = 0;
9D0784C8  AC400028   SW ZERO, 40(V0)
132:                     uart1Obj.isRdNotificationEnabled = false;
9D0784A4  A040002C   SB ZERO, 44(V0)
133:                     uart1Obj.isRdNotifyPersistently = false;
9D0784B0  A0400034   SB ZERO, 52(V0)
134:                     uart1Obj.rdThreshold = 0;
9D0784BC  AC400030   SW ZERO, 48(V0)
135:                 
136:                     uart1Obj.wrCallback = NULL;
9D0784C4  ACA00144   SW ZERO, 324(A1)
137:                     uart1Obj.wrInIndex = 0;
9D0784D0  AC400008   SW ZERO, 8(V0)
138:                     uart1Obj.wrOutIndex = 0;
9D0784D8  AC40000C   SW ZERO, 12(V0)
139:                     uart1Obj.isWrNotificationEnabled = false;
9D0784CC  A0400010   SB ZERO, 16(V0)
140:                     uart1Obj.isWrNotifyPersistently = false;
9D0784D4  A0400018   SB ZERO, 24(V0)
141:                     uart1Obj.wrThreshold = 0;
9D0784DC  AC400014   SW ZERO, 20(V0)
142:                 
143:                     /* Turn ON UART1 */
144:                     U1MODESET = _U1MODE_ON_MASK;
9D0784E0  34028000   ORI V0, ZERO, -32768
9D0784E4  AC628008   SW V0, -32760(V1)
145:                 
146:                     /* Enable UART1_FAULT Interrupt */
147:                     IEC1SET = _IEC1_U1EIE_MASK;
9D0784E8  24020040   ADDIU V0, ZERO, 64
9D0784EC  AC8200D8   SW V0, 216(A0)
148:                 
149:                     /* Enable UART1_RX Interrupt */
150:                     IEC1SET = _IEC1_U1RXIE_MASK;
9D0784F0  24020080   ADDIU V0, ZERO, 128
9D0784F4  AC8200D8   SW V0, 216(A0)
9D0784F8  03E00008   JR RA
9D0784FC  00000000   NOP
151:                 }
152:                 
153:                 bool UART1_SerialSetup( UART_SERIAL_SETUP *setup, uint32_t srcClkFreq )
154:                 {
155:                     bool status = false;
000000C8  00000000   NOP
156:                     uint32_t baud;
157:                     int32_t brgValHigh = 0;
158:                     int32_t brgValLow = 0;
159:                     uint32_t brgVal = 0;
160:                     uint32_t uartMode;
161:                 
162:                     if (setup != NULL)
00000000  00000000   NOP
163:                     {
164:                         baud = setup->baudRate;
00000008  00000000   NOP
165:                 
166:                         if (baud == 0)
0000000C  00000000   NOP
167:                         {
168:                             return status;
169:                         }
170:                 
171:                         /* Turn OFF UART1 */
172:                         U1MODECLR = _U1MODE_ON_MASK;
00000014  00000000   NOP
173:                 
174:                         if(srcClkFreq == 0)
0000001C  00000000   NOP
175:                         {
176:                             srcClkFreq = UART1_FrequencyGet();
177:                         }
178:                 
179:                         /* Calculate BRG value */
180:                         brgValLow = (((srcClkFreq >> 4) + (baud >> 1)) / baud ) - 1;
0000002C  00000000   NOP
00000044  00000000   NOP
181:                         brgValHigh = (((srcClkFreq >> 2) + (baud >> 1)) / baud ) - 1;
000000AC  00000000   NOP
182:                 
183:                         /* Check if the baud value can be set with low baud settings */
184:                         if((brgValLow >= 0) && (brgValLow <= UINT16_MAX))
00000040  00000000   NOP
00000048  00000000   NOP
185:                         {
186:                             brgVal =  brgValLow;
187:                             U1MODECLR = _U1MODE_BRGH_MASK;
00000054  00000000   NOP
188:                         }
189:                         else if ((brgValHigh >= 0) && (brgValHigh <= UINT16_MAX))
000000BC  00000000   NOP
190:                         {
191:                             brgVal = brgValHigh;
192:                             U1MODESET = _U1MODE_BRGH_MASK;
000000E0  00000000   NOP
193:                         }
194:                         else
195:                         {
196:                             return status;
197:                         }
198:                 
199:                         if(setup->dataWidth == UART_DATA_9_BIT)
0000005C  00000000   NOP
000000E4  00000000   NOP
200:                         {
201:                             if(setup->parity != UART_PARITY_NONE)
000000F4  00000000   NOP
202:                             {
203:                                return status;
204:                             }
205:                             else
206:                             {
207:                                /* Configure UART1 mode */
208:                                uartMode = U1MODE;
00000100  00000000   NOP
209:                                uartMode &= ~_U1MODE_PDSEL_MASK;
210:                                U1MODE = uartMode | setup->dataWidth;
00000104  00000000   NOP
211:                             }
212:                         }
213:                         else
214:                         {
215:                             /* Configure UART1 mode */
216:                             uartMode = U1MODE;
0000006C  00000000   NOP
217:                             uartMode &= ~_U1MODE_PDSEL_MASK;
00000074  00000000   NOP
218:                             U1MODE = uartMode | setup->parity ;
00000070  00000000   NOP
00000078  00000000   NOP
219:                         }
220:                 
221:                         /* Configure UART1 mode */
222:                         uartMode = U1MODE;
00000080  00000000   NOP
223:                         uartMode &= ~_U1MODE_STSEL_MASK;
00000088  00000000   NOP
224:                         U1MODE = uartMode | setup->stopBits ;
00000084  00000000   NOP
0000008C  00000000   NOP
225:                 
226:                         /* Configure UART1 Baud Rate */
227:                         U1BRG = brgVal;
00000098  00000000   NOP
228:                 
229:                         U1MODESET = _U1MODE_ON_MASK;
0000009C  00000000   NOP
230:                 
231:                         status = true;
00000094  00000000   NOP
232:                     }
233:                 
234:                     return status;
235:                 }
000000A4  00000000   NOP
236:                 
237:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
238:                 static inline bool UART1_RxPushByte(uint8_t rdByte)
239:                 {
240:                     uint32_t tempInIndex;
241:                     bool isSuccess = false;
242:                 
243:                     tempInIndex = uart1Obj.rdInIndex + 1;
9D076964  3C108000   LUI S0, -32768
9D076968  26100144   ADDIU S0, S0, 324
9D076988  8E020024   LW V0, 36(S0)
9D076994  24420001   ADDIU V0, V0, 1
244:                 
245:                     if (tempInIndex >= UART1_READ_BUFFER_SIZE)
9D076998  2C440080   SLTIU A0, V0, 128
246:                     {
247:                         tempInIndex = 0;
9D07699C  0004100A   MOVZ V0, ZERO, A0
248:                     }
249:                 
250:                     if (tempInIndex == uart1Obj.rdOutIndex)
9D07698C  8E030028   LW V1, 40(S0)
9D0769A0  50620029   BEQL V1, V0, .LVL101, .LBB74
9D0769A4  8E03001C   LW V1, 28(S0)
251:                     {
252:                         /* Queue is full - Report it to the application. Application gets a chance to free up space by reading data out from the RX ring buffer */
253:                         if(uart1Obj.rdCallback != NULL)
9D076A48  1060FFD7   BEQ V1, ZERO, 0x9D0769A8
9D076A4C  00000000   NOP
254:                         {
255:                             uart1Obj.rdCallback(UART_EVENT_READ_BUFFER_FULL, uart1Obj.rdContext);
9D076A50  8E050020   LW A1, 32(S0)
9D076A54  0060F809   JALR V1
9D076A58  24040001   ADDIU A0, ZERO, 1
256:                 
257:                             /* Read the indices again in case application has freed up space in RX ring buffer */
258:                             tempInIndex = uart1Obj.rdInIndex + 1;
9D076A5C  8E020024   LW V0, 36(S0)
9D076A60  24420001   ADDIU V0, V0, 1
259:                 
260:                             if (tempInIndex >= UART1_READ_BUFFER_SIZE)
9D076A64  2C430080   SLTIU V1, V0, 128
261:                             {
262:                                 tempInIndex = 0;
9D076A68  0B41DA6A   J 0x9D0769A8
9D076A6C  0003100A   MOVZ V0, ZERO, V1
263:                             }
264:                         }
265:                     }
266:                 
267:                     if (tempInIndex != uart1Obj.rdOutIndex)
9D0769A8  8E030028   LW V1, 40(S0)
9D0769AC  1062FFF1   BEQ V1, V0, .LBE58
9D0769B0  00000000   NOP
268:                     {
269:                         UART1_ReadBuffer[uart1Obj.rdInIndex] = rdByte;
9D07696C  3C148000   LUI S4, -32768
9D076970  26941940   ADDIU S4, S4, 6464
9D0769B4  8E040024   LW A0, 36(S0)
9D0769C0  00941021   ADDU V0, A0, S4
270:                         uart1Obj.rdInIndex = tempInIndex;
9D0769BC  AE020024   SW V0, 36(S0)
271:                         isSuccess = true;
272:                     }
273:                     else
274:                     {
275:                         /* Queue is full. Data will be lost. */
276:                     }
277:                 
278:                     return isSuccess;
279:                 }
280:                 
281:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
282:                 static void UART1_ReadNotificationSend(void)
283:                 {
284:                     uint32_t nUnreadBytesAvailable;
285:                 
286:                     if (uart1Obj.isRdNotificationEnabled == true)
9D0769B8  9203002C   LBU V1, 44(S0)
9D0769C4  1060FFEB   BEQ V1, ZERO, .LBE58
9D0769C8  A0510000   SB S1, 0(V0)
287:                     {
288:                         nUnreadBytesAvailable = UART1_ReadCountGet();
289:                 
290:                         if(uart1Obj.rdCallback != NULL)
9D0769E0  8E06001C   LW A2, 28(S0)
9D0769E4  10C0FFE3   BEQ A2, ZERO, .LBE58
9D0769E8  00621023   SUBU V0, V1, V0
291:                         {
292:                             if (uart1Obj.isRdNotifyPersistently == true)
9D0769EC  92030034   LBU V1, 52(S0)
9D0769F0  1060001F   BEQ V1, ZERO, .LVL105, .LBB75
9D0769F4  8E030030   LW V1, 48(S0)
293:                             {
294:                                 if (nUnreadBytesAvailable >= uart1Obj.rdThreshold)
9D0769F8  0043102B   SLTU V0, V0, V1
9D0769FC  1440FFDD   BNE V0, ZERO, .LBE58
9D076A00  00000000   NOP
295:                                 {
296:                                     uart1Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart1Obj.rdContext);
297:                                 }
298:                             }
299:                             else
300:                             {
301:                                 if (nUnreadBytesAvailable == uart1Obj.rdThreshold)
9D076A70  1443FFC0   BNE V0, V1, .LBE58
9D076A74  00000000   NOP
302:                                 {
303:                                     uart1Obj.rdCallback(UART_EVENT_READ_THRESHOLD_REACHED, uart1Obj.rdContext);
9D076A04  8E050020   LW A1, 32(S0)
9D076A08  00C0F809   JALR A2
9D076A0C  00002021   ADDU A0, ZERO, ZERO
9D076A78  0B41DA82   J 0x9D076A08
9D076A7C  8E050020   LW A1, 32(S0)
304:                                 }
305:                             }
306:                         }
307:                     }
308:                 }
309:                 
310:                 size_t UART1_Read(uint8_t* pRdBuffer, const size_t size)
311:                 {
312:                     size_t nBytesRead = 0;
00000028  00000000   NOP
00000094  00000000   NOP
000000A8  00000000   NOP
313:                     uint32_t rdOutIndex;
314:                     uint32_t rdInIndex;
315:                 
316:                     while (nBytesRead < size)
00000000  00000000   NOP
00000084  00000000   NOP
317:                     {
318:                         UART1_RX_INT_DISABLE();
00000008  00000000   NOP
0000003C  00000000   NOP
319:                 
320:                         rdOutIndex = uart1Obj.rdOutIndex;
00000010  00000000   NOP
00000040  00000000   NOP
321:                         rdInIndex = uart1Obj.rdInIndex;
0000001C  00000000   NOP
00000044  00000000   NOP
322:                 
323:                         if (rdOutIndex != rdInIndex)
00000020  00000000   NOP
00000048  00000000   NOP
324:                         {
325:                             pRdBuffer[nBytesRead++] = UART1_ReadBuffer[uart1Obj.rdOutIndex++];
00000050  00000000   NOP
326:                 
327:                             if (uart1Obj.rdOutIndex >= UART1_READ_BUFFER_SIZE)
00000070  00000000   NOP
328:                             {
329:                                 uart1Obj.rdOutIndex = 0;
330:                             }
331:                             UART1_RX_INT_ENABLE();
00000030  00000000   NOP
00000080  00000000   NOP
332:                         }
333:                         else
334:                         {
335:                             UART1_RX_INT_ENABLE();
00000098  00000000   NOP
336:                             break;
000000A0  00000000   NOP
337:                         }
338:                     }
339:                 
340:                     return nBytesRead;
341:                 }
342:                 
343:                 size_t UART1_ReadCountGet(void)
344:                 {
345:                     size_t nUnreadBytesAvailable;
346:                     uint32_t rdInIndex;
347:                     uint32_t rdOutIndex;
348:                 
349:                     /* Take a snapshot of indices to avoid creation of critical section */
350:                     rdInIndex = uart1Obj.rdInIndex;
9D0769CC  8E030024   LW V1, 36(S0)
00000000  00000000   NOP
351:                     rdOutIndex = uart1Obj.rdOutIndex;
9D0769D0  8E020028   LW V0, 40(S0)
0000000C  00000000   NOP
352:                 
353:                     if ( rdInIndex >=  rdOutIndex)
9D0769D4  0062202B   SLTU A0, V1, V0
00000010  00000000   NOP
354:                     {
355:                         nUnreadBytesAvailable =  rdInIndex -  rdOutIndex;
356:                     }
357:                     else
358:                     {
359:                         nUnreadBytesAvailable =  (UART1_READ_BUFFER_SIZE -  rdOutIndex) + rdInIndex;
360:                     }
361:                 
362:                     return nUnreadBytesAvailable;
363:                 }
0000001C  00000000   NOP
364:                 
365:                 size_t UART1_ReadFreeBufferCountGet(void)
366:                 {
367:                     return (UART1_READ_BUFFER_SIZE - 1) - UART1_ReadCountGet();
00000020  00000000   NOP
368:                 }
00000024  00000000   NOP
369:                 
370:                 size_t UART1_ReadBufferSizeGet(void)
371:                 {
372:                     return (UART1_READ_BUFFER_SIZE - 1);
373:                 }
374:                 
375:                 bool UART1_ReadNotificationEnable(bool isEnabled, bool isPersistent)
376:                 {
377:                     bool previousStatus = uart1Obj.isRdNotificationEnabled;
00000000  00000000   NOP
378:                 
379:                     uart1Obj.isRdNotificationEnabled = isEnabled;
380:                 
381:                     uart1Obj.isRdNotifyPersistently = isPersistent;
0000000C  00000000   NOP
382:                 
383:                     return previousStatus;
384:                 }
00000010  00000000   NOP
385:                 
386:                 void UART1_ReadThresholdSet(uint32_t nBytesThreshold)
387:                 {
388:                     if (nBytesThreshold > 0)
00000000  00000000   NOP
389:                     {
390:                         uart1Obj.rdThreshold = nBytesThreshold;
00000008  00000000   NOP
391:                     }
392:                 }
393:                 
394:                 void UART1_ReadCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
395:                 {
396:                     uart1Obj.rdCallback = callback;
00000000  00000000   NOP
397:                 
398:                     uart1Obj.rdContext = context;
0000000C  00000000   NOP
399:                 }
400:                 
401:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
402:                 static bool UART1_TxPullByte(uint8_t* pWrByte)
403:                 {
404:                     bool isSuccess = false;
405:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
9D075FBC  8E03000C   LW V1, 12(S0)
406:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
9D075FC0  8E020008   LW V0, 8(S0)
407:                 
408:                     if (wrOutIndex != wrInIndex)
9D075FC4  5062003E   BEQL V1, V0, .LVL130
9D075FC8  3C02BF81   LUI V0, -16511
409:                     {
410:                         *pWrByte = UART1_WriteBuffer[uart1Obj.wrOutIndex++];
9D075FA0  3C128000   LUI S2, -32768
9D075FA4  265218C0   ADDIU S2, S2, 6336
9D075FCC  8E02000C   LW V0, 12(S0)
9D075FD0  24430001   ADDIU V1, V0, 1
9D075FD4  AE03000C   SW V1, 12(S0)
411:                 
412:                         if (uart1Obj.wrOutIndex >= UART1_WRITE_BUFFER_SIZE)
9D075FD8  8E03000C   LW V1, 12(S0)
9D075FDC  2C630080   SLTIU V1, V1, 128
9D075FE0  14600002   BNE V1, ZERO, .LVL117, .LBE108, .LBB109
9D075FE4  7E42118A   LBUX V0, V0(S2)
413:                         {
414:                             uart1Obj.wrOutIndex = 0;
9D075FE8  AE00000C   SW ZERO, 12(S0)
415:                         }
416:                         isSuccess = true;
417:                     }
418:                 
419:                     return isSuccess;
420:                 }
421:                 
422:                 static inline bool UART1_TxPushByte(uint8_t wrByte)
423:                 {
424:                     uint32_t tempInIndex;
425:                     bool isSuccess = false;
426:                 
427:                     tempInIndex = uart1Obj.wrInIndex + 1;
9D0783B4  8CC30008   LW V1, 8(A2)
9D0783BC  24630001   ADDIU V1, V1, 1
428:                 
429:                     if (tempInIndex >= UART1_WRITE_BUFFER_SIZE)
9D0783C0  2C680080   SLTIU T0, V1, 128
430:                     {
431:                         tempInIndex = 0;
9D0783C4  0008180A   MOVZ V1, ZERO, T0
432:                     }
433:                     if (tempInIndex != uart1Obj.wrOutIndex)
9D0783B8  8CC7000C   LW A3, 12(A2)
9D0783C8  14E3FFF4   BNE A3, V1, .LVL54, .LBB35
9D0783CC  7C82498A   LBUX T1, V0(A0)
434:                     {
435:                         UART1_WriteBuffer[uart1Obj.wrInIndex] = wrByte;
9D078390  3C0A8000   LUI T2, -32768
9D078394  0B41E0ED   J .LVL58, .LBB37
9D078398  254A18C0   ADDIU T2, T2, 6336
9D07839C  8CC70008   LW A3, 8(A2)
9D0783A8  00EA1821   ADDU V1, A3, T2
436:                         uart1Obj.wrInIndex = tempInIndex;
9D0783A4  ACC30008   SW V1, 8(A2)
437:                         isSuccess = true;
438:                     }
439:                     else
440:                     {
441:                         /* Queue is full. Report Error. */
442:                     }
443:                 
444:                     return isSuccess;
445:                 }
446:                 
447:                 /* This routine is only called from ISR. Hence do not disable/enable USART interrupts. */
448:                 static void UART1_WriteNotificationSend(void)
449:                 {
450:                     uint32_t nFreeWrBufferCount;
451:                 
452:                     if (uart1Obj.isWrNotificationEnabled == true)
9D075FEC  92030010   LBU V1, 16(S0)
9D075FF4  1060FFED   BEQ V1, ZERO, .LVL110, .LBE97, .LBE95
9D075FF8  00000000   NOP
453:                     {
454:                         nFreeWrBufferCount = UART1_WriteFreeBufferCountGet();
455:                 
456:                         if(uart1Obj.wrCallback != NULL)
9D076014  8E660144   LW A2, 324(S3)
9D076018  10C0FFE4   BEQ A2, ZERO, .LVL110, .LBE97, .LBE95
9D07601C  02821023   SUBU V0, S4, V0
457:                         {
458:                             if (uart1Obj.isWrNotifyPersistently == true)
9D076020  92030018   LBU V1, 24(S0)
9D076024  10600015   BEQ V1, ZERO, .LVL126, .LBB111
9D076028  8E030014   LW V1, 20(S0)
459:                             {
460:                                 if (nFreeWrBufferCount >= uart1Obj.wrThreshold)
9D07602C  0043102B   SLTU V0, V0, V1
9D076030  1440FFDE   BNE V0, ZERO, .LVL110, .LBE97, .LBE95
9D076034  00000000   NOP
461:                                 {
462:                                     uart1Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart1Obj.wrContext);
463:                                 }
464:                             }
465:                             else
466:                             {
467:                                 if (nFreeWrBufferCount == uart1Obj.wrThreshold)
9D07607C  1443FFCB   BNE V0, V1, .LVL110, .LBE97, .LBE95
9D076080  00000000   NOP
468:                                 {
469:                                     uart1Obj.wrCallback(UART_EVENT_WRITE_THRESHOLD_REACHED, uart1Obj.wrContext);
9D076038  8E050004   LW A1, 4(S0)
9D07603C  00C0F809   JALR A2
9D076040  24040003   ADDIU A0, ZERO, 3
9D076084  8E050004   LW A1, 4(S0)
9D076088  00C0F809   JALR A2
9D07608C  24040003   ADDIU A0, ZERO, 3
9D076090  0B41D811   J .LVL124, .LBE110
9D076094  00000000   NOP
470:                                 }
471:                             }
472:                         }
473:                     }
474:                 }
475:                 
476:                 static size_t UART1_WritePendingBytesGet(void)
477:                 {
478:                     size_t nPendingTxBytes;
479:                 
480:                     /* Take a snapshot of indices to avoid creation of critical section */
481:                     uint32_t wrOutIndex = uart1Obj.wrOutIndex;
9D075F68  3C138000   LUI S3, -32768
9D075F78  26700144   ADDIU S0, S3, 324
9D075F7C  8E02000C   LW V0, 12(S0)
9D075FFC  8E02000C   LW V0, 12(S0)
9D0783D0  8CC3000C   LW V1, 12(A2)
482:                     uint32_t wrInIndex = uart1Obj.wrInIndex;
9D075F80  8E030008   LW V1, 8(S0)
9D076000  8E030008   LW V1, 8(S0)
9D0783D4  8CC40008   LW A0, 8(A2)
0000000C  00000000   NOP
483:                 
484:                     if ( wrInIndex >=  wrOutIndex)
9D075F84  0062202B   SLTU A0, V1, V0
9D075F88  54800001   BNEL A0, ZERO, .LVL108
9D075F8C  24630080   ADDIU V1, V1, 128
9D076004  0062202B   SLTU A0, V1, V0
9D0783D8  0083282B   SLTU A1, A0, V1
00000010  00000000   NOP
485:                     {
486:                         nPendingTxBytes =  wrInIndex -  wrOutIndex;
487:                     }
488:                     else
489:                     {
490:                         nPendingTxBytes =  (UART1_WRITE_BUFFER_SIZE -  wrOutIndex) + wrInIndex;
9D075F90  00621023   SUBU V0, V1, V0
9D076010  00621023   SUBU V0, V1, V0
9D0783E4  00831823   SUBU V1, A0, V1
0000001C  00000000   NOP
491:                     }
492:                 
493:                     return nPendingTxBytes;
494:                 }
495:                 
496:                 size_t UART1_WriteCountGet(void)
497:                 {
00000000  00000000   NOP
498:                     size_t nPendingTxBytes;
499:                 
500:                     nPendingTxBytes = UART1_WritePendingBytesGet();
501:                 
502:                     return nPendingTxBytes;
503:                 }
0000001C  00000000   NOP
504:                 
505:                 size_t UART1_Write(uint8_t* pWrBuffer, const size_t size )
506:                 {
507:                     size_t nBytesWritten  = 0;
9D078380  00001021   ADDU V0, ZERO, ZERO
9D078384  3C068000   LUI A2, -32768
508:                 
509:                     UART1_TX_INT_DISABLE();
9D078374  3C0BBF81   LUI T3, -16511
9D078378  24020100   ADDIU V0, ZERO, 256
9D07837C  AD6200D4   SW V0, 212(T3)
510:                 
511:                     while (nBytesWritten < size)
9D078388  10A00011   BEQ A1, ZERO, .LVL62, .LBE37, .LBB38, .LBB39
9D07838C  24C60144   ADDIU A2, A2, 324
9D0783AC  10450008   BEQ V0, A1, .LVL62, .LBE37, .LBB38, .LBB39
9D0783B0  A0690000   SB T1, 0(V1)
512:                     {
513:                         if (UART1_TxPushByte(pWrBuffer[nBytesWritten]) == true)
514:                         {
515:                             nBytesWritten++;
9D0783A0  24420001   ADDIU V0, V0, 1
516:                         }
517:                         else
518:                         {
519:                             /* Queue is full, exit the loop */
520:                             break;
521:                         }
522:                     }
523:                 
524:                     /* Check if any data is pending for transmission */
525:                     if (UART1_WritePendingBytesGet() > 0)
9D0783E8  10600002   BEQ V1, ZERO, 0x9D0783F4
9D0783EC  24030100   ADDIU V1, ZERO, 256
526:                     {
527:                         /* Enable TX interrupt as data is pending for transmission */
528:                         UART1_TX_INT_ENABLE();
9D0783F0  AD6300D8   SW V1, 216(T3)
529:                     }
530:                 
531:                     return nBytesWritten;
532:                 }
9D0783F4  03E00008   JR RA
9D0783F8  00000000   NOP
533:                 
534:                 size_t UART1_WriteFreeBufferCountGet(void)
535:                 {
00000000  00000000   NOP
536:                     return (UART1_WRITE_BUFFER_SIZE - 1) - UART1_WriteCountGet();
9D075FA8  2414007F   ADDIU S4, ZERO, 127
00000020  00000000   NOP
537:                 }
00000024  00000000   NOP
538:                 
539:                 size_t UART1_WriteBufferSizeGet(void)
540:                 {
541:                     return (UART1_WRITE_BUFFER_SIZE - 1);
542:                 }
543:                 
544:                 bool UART1_WriteNotificationEnable(bool isEnabled, bool isPersistent)
545:                 {
546:                     bool previousStatus = uart1Obj.isWrNotificationEnabled;
00000000  00000000   NOP
547:                 
548:                     uart1Obj.isWrNotificationEnabled = isEnabled;
549:                 
550:                     uart1Obj.isWrNotifyPersistently = isPersistent;
0000000C  00000000   NOP
551:                 
552:                     return previousStatus;
553:                 }
00000010  00000000   NOP
554:                 
555:                 void UART1_WriteThresholdSet(uint32_t nBytesThreshold)
556:                 {
557:                     if (nBytesThreshold > 0)
00000000  00000000   NOP
558:                     {
559:                         uart1Obj.wrThreshold = nBytesThreshold;
00000008  00000000   NOP
560:                     }
561:                 }
562:                 
563:                 void UART1_WriteCallbackRegister( UART_RING_BUFFER_CALLBACK callback, uintptr_t context)
564:                 {
565:                     uart1Obj.wrCallback = callback;
00000000  00000000   NOP
00000008  00000000   NOP
566:                 
567:                     uart1Obj.wrContext = context;
00000004  00000000   NOP
0000000C  00000000   NOP
568:                 }
569:                 
570:                 UART_ERROR UART1_ErrorGet( void )
571:                 {
0000002C  00000000   NOP
00000074  00000000   NOP
572:                     UART_ERROR errors = UART_ERROR_NONE;
573:                     uint32_t status = U1STA;
00000000  00000000   NOP
574:                 
575:                     errors = (UART_ERROR)(status & (_U1STA_OERR_MASK | _U1STA_FERR_MASK | _U1STA_PERR_MASK));
00000008  00000000   NOP
576:                 
577:                     if(errors != UART_ERROR_NONE)
0000000C  00000000   NOP
578:                     {
579:                         UART1_ErrorClear();
580:                     }
581:                 
582:                     /* All errors are cleared, but send the previous error state */
583:                     return errors;
584:                 }
00000014  00000000   NOP
00000068  00000000   NOP
585:                 
586:                 bool UART1_AutoBaudQuery( void )
587:                 {
588:                     if(U1MODE & _U1MODE_ABAUD_MASK)
00000000  00000000   NOP
589:                         return true;
590:                     else
591:                         return false;
592:                 }
00000008  00000000   NOP
593:                 
594:                 void UART1_AutoBaudSet( bool enable )
595:                 {
596:                     if( enable == true )
00000000  00000000   NOP
597:                     {
598:                         U1MODESET = _U1MODE_ABAUD_MASK;
00000008  00000000   NOP
599:                     }
600:                 
601:                     /* Turning off ABAUD if it was on can lead to unpredictable behavior, so that
602:                        direction of control is not allowed in this function.                      */
603:                 }
604:                 
605:                 void UART1_FAULT_InterruptHandler (void)
606:                 {
607:                     /* Disable the fault interrupt */
608:                     IEC1CLR = _IEC1_U1EIE_MASK;
9D078DAC  3C02BF81   LUI V0, -16511
9D078DB0  24040040   ADDIU A0, ZERO, 64
9D078DB4  AC4400D4   SW A0, 212(V0)
609:                     /* Disable the receive interrupt */
610:                     IEC1CLR = _IEC1_U1RXIE_MASK;
9D078DB8  24040080   ADDIU A0, ZERO, 128
9D078DBC  AC4400D4   SW A0, 212(V0)
611:                 
612:                     /* Client must call UARTx_ErrorGet() function to clear the errors */
613:                     if( uart1Obj.rdCallback != NULL )
9D078DA0  3C038000   LUI V1, -32768
9D078DA4  24630144   ADDIU V1, V1, 324
9D078DA8  8C79001C   LW T9, 28(V1)
9D078DC0  13200004   BEQ T9, ZERO, .LVL87
9D078DC4  00000000   NOP
614:                     {
615:                         uart1Obj.rdCallback(UART_EVENT_READ_ERROR, uart1Obj.rdContext);
9D078DC8  8C650020   LW A1, 32(V1)
9D078DCC  03200008   JR T9
9D078DD0  24040002   ADDIU A0, ZERO, 2
9D078DD4  03E00008   JR RA
9D078DD8  00000000   NOP
616:                     }
617:                 }
618:                 
619:                 void UART1_RX_InterruptHandler (void)
620:                 {
9D076940  27BDFFD8   ADDIU SP, SP, -40
9D076944  AFBF0024   SW RA, 36(SP)
9D076948  AFB40020   SW S4, 32(SP)
9D07694C  AFB3001C   SW S3, 28(SP)
9D076950  AFB20018   SW S2, 24(SP)
9D076954  AFB10014   SW S1, 20(SP)
9D076958  AFB00010   SW S0, 16(SP)
9D07695C  3C12BF83   LUI S2, -16509
621:                     /* Keep reading until there is a character availabe in the RX FIFO */
622:                     while((U1STA & _U1STA_URXDA_MASK) == _U1STA_URXDA_MASK)
9D076960  02409821   ADDU S3, S2, ZERO
9D076974  8E428010   LW V0, -32752(S2)
9D076978  30420001   ANDI V0, V0, 1
9D07697C  10400028   BEQ V0, ZERO, .LVL100
9D076980  24030080   ADDIU V1, ZERO, 128
9D076A10  8E428010   LW V0, -32752(S2)
9D076A14  30420001   ANDI V0, V0, 1
9D076A18  1440FFDA   BNE V0, ZERO, 0x9D076984
9D076A1C  24030080   ADDIU V1, ZERO, 128
623:                     {
624:                         if (UART1_RxPushByte( (uint8_t )(U1RXREG) ) == true)
9D076984  8E648030   LW A0, -32720(S3)
9D076990  309100FF   ANDI S1, A0, 255
625:                         {
626:                             UART1_ReadNotificationSend();
627:                         }
628:                         else
629:                         {
630:                             /* UART RX buffer is full */
631:                         }
632:                     }
633:                 
634:                     /* Clear UART1 RX Interrupt flag */
635:                     IFS1CLR = _IFS1_U1RXIF_MASK;
9D076A20  3C02BF81   LUI V0, -16511
9D076A24  AC430054   SW V1, 84(V0)
636:                 }
9D076A28  8FBF0024   LW RA, 36(SP)
9D076A2C  8FB40020   LW S4, 32(SP)
9D076A30  8FB3001C   LW S3, 28(SP)
9D076A34  8FB20018   LW S2, 24(SP)
9D076A38  8FB10014   LW S1, 20(SP)
9D076A3C  8FB00010   LW S0, 16(SP)
9D076A40  03E00008   JR RA
9D076A44  27BD0028   ADDIU SP, SP, 40
9D076A48  1060FFD7   BEQ V1, ZERO, 0x9D0769A8
9D076A4C  00000000   NOP
9D076A50  8E050020   LW A1, 32(S0)
9D076A54  0060F809   JALR V1
9D076A58  24040001   ADDIU A0, ZERO, 1
9D076A5C  8E020024   LW V0, 36(S0)
9D076A60  24420001   ADDIU V0, V0, 1
9D076A64  2C430080   SLTIU V1, V0, 128
9D076A68  0B41DA6A   J 0x9D0769A8
9D076A6C  0003100A   MOVZ V0, ZERO, V1
9D076A70  1443FFC0   BNE V0, V1, .LBE58
9D076A74  00000000   NOP
9D076A78  0B41DA82   J 0x9D076A08
9D076A7C  8E050020   LW A1, 32(S0)
637:                 
638:                 void UART1_TX_InterruptHandler (void)
639:                 {
9D075F4C  27BDFFD8   ADDIU SP, SP, -40
9D075F50  AFBF0024   SW RA, 36(SP)
9D075F54  AFB40020   SW S4, 32(SP)
9D075F58  AFB3001C   SW S3, 28(SP)
9D075F5C  AFB20018   SW S2, 24(SP)
9D075F60  AFB10014   SW S1, 20(SP)
9D075F64  AFB00010   SW S0, 16(SP)
640:                     uint8_t wrByte;
641:                 
642:                     /* Check if any data is pending for transmission */
643:                     LED1_Toggle();
9D075F6C  24032000   ADDIU V1, ZERO, 8192
9D075F70  3C02BF86   LUI V0, -16506
9D075F74  AC43043C   SW V1, 1084(V0)
644:                     if (UART1_WritePendingBytesGet() > 0)
9D075F94  10400040   BEQ V0, ZERO, .LVL128, .LBE111
9D075F98  24030100   ADDIU V1, ZERO, 256
9D075F9C  3C11BF83   LUI S1, -16509
645:                     {
646:                         /* Keep writing to the TX FIFO as long as there is space */
647:                         while(!(U1STA & _U1STA_UTXBF_MASK))
9D075FAC  8E228010   LW V0, -32752(S1)
9D075FB0  30420200   ANDI V0, V0, 512
9D075FB4  14400027   BNE V0, ZERO, .LVL125
9D075FB8  3C02BF81   LUI V0, -16511
9D076044  8E228010   LW V0, -32752(S1)
9D076048  30420200   ANDI V0, V0, 512
9D07604C  1040FFDB   BEQ V0, ZERO, .LVL111, .LBB108
9D076050  3C02BF81   LUI V0, -16511
648:                         {
649:                             if (UART1_TxPullByte(&wrByte) == true)
650:                             {
651:                                 U1TXREG = wrByte;
9D075FF0  AE228020   SW V0, -32736(S1)
652:                 
653:                                 /* Send notification */
654:                                 UART1_WriteNotificationSend();
655:                             }
656:                             else
657:                             {
658:                                 /* Nothing to transmit. Disable the data register empty interrupt. */
659:                                 UART1_TX_INT_DISABLE();
9D0760C0  24030100   ADDIU V1, ZERO, 256
9D0760C4  AC4300D4   SW V1, 212(V0)
660:                                 break;
661:                             }
662:                         }
663:                 
664:                         /* Clear UART1TX Interrupt flag */
665:                         IFS1CLR = _IFS1_U1TXIF_MASK;
9D076054  24030100   ADDIU V1, ZERO, 256
9D076058  AC430054   SW V1, 84(V0)
9D0760C8  24030100   ADDIU V1, ZERO, 256
9D0760CC  AC430054   SW V1, 84(V0)
666:                 
667:                     }
668:                     else
669:                     {
670:                         /* Nothing to transmit. Disable the data register empty interrupt. */
671:                         UART1_TX_INT_DISABLE();
9D076098  3C02BF81   LUI V0, -16511
9D07609C  AC4300D4   SW V1, 212(V0)
672:                     }
673:                 }
9D07605C  8FBF0024   LW RA, 36(SP)
9D076060  8FB40020   LW S4, 32(SP)
9D076064  8FB3001C   LW S3, 28(SP)
9D076068  8FB20018   LW S2, 24(SP)
9D07606C  8FB10014   LW S1, 20(SP)
9D076070  8FB00010   LW S0, 16(SP)
9D076074  03E00008   JR RA
9D076078  27BD0028   ADDIU SP, SP, 40
9D0760A0  8FBF0024   LW RA, 36(SP)
9D0760A4  8FB40020   LW S4, 32(SP)
9D0760A8  8FB3001C   LW S3, 28(SP)
9D0760AC  8FB20018   LW S2, 24(SP)
9D0760B0  8FB10014   LW S1, 20(SP)
9D0760B4  8FB00010   LW S0, 16(SP)
9D0760B8  03E00008   JR RA
9D0760BC  27BD0028   ADDIU SP, SP, 40
9D0760D0  0B41D818   J 0x9D076060
9D0760D4  8FBF0024   LW RA, 36(SP)
674:                 
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/spi/spi_master/plib_spi2_master.c
1:                   /*******************************************************************************
2:                     SPI PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_spi2_master.c
9:                   
10:                    Summary:
11:                      SPI2 Master Source File
12:                  
13:                    Description:
14:                      This file has implementation of all the interfaces provided for particular
15:                      SPI peripheral.
16:                  
17:                  *******************************************************************************/
18:                  
19:                  /*******************************************************************************
20:                  * Copyright (C) 2018-2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  
42:                  #include "plib_spi2_master.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: SPI2 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  
51:                  #define SPI2_CON_MSTEN                      (1 << _SPI2CON_MSTEN_POSITION)
52:                  #define SPI2_CON_CKP                        (1 << _SPI2CON_CKP_POSITION)
53:                  #define SPI2_CON_CKE                        (0 << _SPI2CON_CKE_POSITION)
54:                  #define SPI2_CON_MODE_32_MODE_16            (0 << _SPI2CON_MODE16_POSITION)
55:                  #define SPI2_CON_ENHBUF                     (1 << _SPI2CON_ENHBUF_POSITION)
56:                  #define SPI2_CON_MCLKSEL                    (0 << _SPI2CON_MCLKSEL_POSITION)
57:                  #define SPI2_CON_MSSEN                      (0 << _SPI2CON_MSSEN_POSITION)
58:                  #define SPI2_CON_SMP                        (0 << _SPI2CON_SMP_POSITION)
59:                  
60:                  void SPI2_Initialize ( void )
61:                  {
62:                      uint32_t rdata;
63:                  
64:                      /* Disable SPI2 Interrupts */
65:                      IEC1CLR = 0x200000;
9D07875C  3C03BF81   LUI V1, -16511
9D078760  3C060020   LUI A2, 32
9D07876C  AC6600D4   SW A2, 212(V1)
66:                      IEC1CLR = 0x400000;
9D078764  3C050040   LUI A1, 64
9D078770  AC6500D4   SW A1, 212(V1)
67:                      IEC1CLR = 0x800000;
9D078768  3C040080   LUI A0, 128
9D078774  AC6400D4   SW A0, 212(V1)
68:                  
69:                      /* STOP and Reset the SPI */
70:                      SPI2CON = 0;
9D078758  3C02BF82   LUI V0, -16510
9D078778  AC407200   SW ZERO, 29184(V0)
71:                  
72:                      /* Clear the Receiver buffer */
73:                      rdata = SPI2BUF;
9D07877C  8C477220   LW A3, 29216(V0)
74:                      rdata = rdata;
75:                  
76:                      /* Clear SPI2 Interrupt flags */
77:                      IFS1CLR = 0x200000;
9D078780  AC660054   SW A2, 84(V1)
78:                      IFS1CLR = 0x400000;
9D078784  AC650054   SW A1, 84(V1)
79:                      IFS1CLR = 0x800000;
9D078788  AC640054   SW A0, 84(V1)
80:                  
81:                      /* BAUD Rate register Setup */
82:                      SPI2BRG = 4;
9D07878C  24030004   ADDIU V1, ZERO, 4
9D078790  AC437230   SW V1, 29232(V0)
83:                  
84:                      /* CLear the Overflow */
85:                      SPI2STATCLR = _SPI2STAT_SPIROV_MASK;
9D078794  24030040   ADDIU V1, ZERO, 64
9D078798  AC437214   SW V1, 29204(V0)
86:                  
87:                      /*
88:                      MSTEN = 1
89:                      CKP = 1
90:                      CKE = 0
91:                      MODE<32,16> = 0
92:                      ENHBUF = 1
93:                      MSSEN = 0
94:                      MCLKSEL = 0
95:                      */
96:                      SPI2CONSET = (SPI2_CON_MSSEN | SPI2_CON_MCLKSEL | SPI2_CON_ENHBUF | SPI2_CON_MODE_32_MODE_16 | SPI2_CON_CKE | SPI2_CON_CKP | SPI2_CON_MSTEN | SPI2_CON_SMP);
9D07879C  3C030001   LUI V1, 1
9D0787A0  24630060   ADDIU V1, V1, 96
9D0787A4  AC437208   SW V1, 29192(V0)
97:                  
98:                      /* Enable transmit interrupt when transmit buffer is completely empty (STXISEL = '01') */
99:                      /* Enable receive interrupt when the receive buffer is not empty (SRXISEL = '01') */
100:                     SPI2CONSET = 0x00000005;
9D0787A8  24030005   ADDIU V1, ZERO, 5
9D0787AC  AC437208   SW V1, 29192(V0)
101:                 
102:                 
103:                     /* Enable SPI2 */
104:                     SPI2CONSET = _SPI2CON_ON_MASK;
9D0787B0  34038000   ORI V1, ZERO, -32768
9D0787B4  AC437208   SW V1, 29192(V0)
9D0787B8  03E00008   JR RA
9D0787BC  00000000   NOP
105:                 }
106:                 
107:                 bool SPI2_TransferSetup (SPI_TRANSFER_SETUP* setup, uint32_t spiSourceClock )
108:                 {
109:                     uint32_t t_brg;
110:                     uint32_t baudHigh;
111:                     uint32_t baudLow;
112:                     uint32_t errorHigh;
113:                     uint32_t errorLow;
114:                 
115:                     if ((setup == NULL) || (setup->clockFrequency == 0))
00000000  00000000   NOP
116:                     {
117:                         return false;
118:                     }
119:                 
120:                     if(spiSourceClock == 0)
00000014  00000000   NOP
121:                     {
122:                         // Use Master Clock Frequency set in GUI
123:                         spiSourceClock = 60000000;
0000001C  00000000   NOP
124:                     }
125:                 
126:                     t_brg = (((spiSourceClock / (setup->clockFrequency)) / 2u) - 1u);
00000024  00000000   NOP
00000060  00000000   NOP
127:                     baudHigh = spiSourceClock / (2u * (t_brg + 1u));
00000034  00000000   NOP
0000003C  00000000   NOP
128:                     baudLow = spiSourceClock / (2u * (t_brg + 2u));
00000038  00000000   NOP
00000048  00000000   NOP
129:                     errorHigh = baudHigh - setup->clockFrequency;
00000054  00000000   NOP
130:                     errorLow = setup->clockFrequency - baudLow;
00000058  00000000   NOP
131:                 
132:                     if (errorHigh > errorLow)
0000005C  00000000   NOP
133:                     {
134:                         t_brg++;
135:                     }
136:                 
137:                     if(t_brg > 8191)
00000068  00000000   NOP
138:                     {
139:                         return false;
140:                     }
141:                 
142:                     SPI2BRG = t_brg;
00000074  00000000   NOP
143:                     SPI2CON = (SPI2CON & (~(_SPI2CON_MODE16_MASK | _SPI2CON_MODE32_MASK | _SPI2CON_CKP_MASK | _SPI2CON_CKE_MASK))) |
00000084  00000000   NOP
00000094  00000000   NOP
144:                                             (setup->clockPolarity | setup->clockPhase | setup->dataBits);
0000007C  00000000   NOP
00000088  00000000   NOP
145:                 
146:                     return true;
000000A4  00000000   NOP
147:                 }
000000AC  00000000   NOP
148:                 
149:                 bool SPI2_Write(void* pTransmitData, size_t txSize)
150:                 {
151:                     return(SPI2_WriteRead(pTransmitData, txSize, NULL, 0));
9D0791B8  00003021   ADDU A2, ZERO, ZERO
9D0791BC  0B41D220   J SPI2_WriteRead
9D0791C0  00003821   ADDU A3, ZERO, ZERO
152:                 }
153:                 
154:                 bool SPI2_Read(void* pReceiveData, size_t rxSize)
155:                 {
9D079110  00803021   ADDU A2, A0, ZERO
9D079114  00A03821   ADDU A3, A1, ZERO
156:                     return(SPI2_WriteRead(NULL, 0, pReceiveData, rxSize));
9D079118  00002021   ADDU A0, ZERO, ZERO
9D07911C  0B41D220   J SPI2_WriteRead
9D079120  00002821   ADDU A1, ZERO, ZERO
157:                 }
158:                 
159:                 bool SPI2_WriteRead(void* pTransmitData, size_t txSize, void* pReceiveData, size_t rxSize)
160:                 {
161:                     size_t txCount = 0;
162:                     size_t rxCount = 0;
163:                     size_t dummySize = 0;
164:                     size_t dummyRxCntr = 0;
165:                     size_t receivedData;
166:                     bool isSuccess = false;
167:                 
168:                     /* Verify the request */
169:                     if (((txSize > 0) && (pTransmitData != NULL)) || ((rxSize > 0) && (pReceiveData != NULL)))
9D074880  10A00051   BEQ A1, ZERO, .LVL28
9D074884  00000000   NOP
9D074888  1080004F   BEQ A0, ZERO, .LVL28
9D07488C  00000000   NOP
9D0749C8  10E00003   BEQ A3, ZERO, .LVL29
9D0749CC  00001021   ADDU V0, ZERO, ZERO
9D0749D0  14C0FFB0   BNE A2, ZERO, .LVL13
9D0749D4  0004280A   MOVZ A1, ZERO, A0
170:                     {
171:                         if (pTransmitData == NULL)
172:                         {
173:                             txSize = 0;
174:                         }
175:                         if (pReceiveData == NULL)
176:                         {
177:                             rxSize = 0;
9D074890  0006380A   MOVZ A3, ZERO, A2
178:                         }
179:                 
180:                         /* Clear the receive overflow error if any */
181:                         SPI2STATCLR = _SPI2STAT_SPIROV_MASK;
9D074894  3C03BF82   LUI V1, -16510
9D074898  24020040   ADDIU V0, ZERO, 64
9D07489C  AC627214   SW V0, 29204(V1)
182:                 
183:                         /* Flush out any unread data in SPI read buffer from the previous transfer */
184:                         while ((bool)(SPI2STAT & _SPI2STAT_SPIRBE_MASK) == false)
9D0748A0  8C627210   LW V0, 29200(V1)
9D0748A4  30420020   ANDI V0, V0, 32
9D0748A8  14400006   BNE V0, ZERO, 0x9D0748C4
9D0748AC  00000000   NOP
9D0748B4  8C627210   LW V0, 29200(V1)
9D0748B8  30420020   ANDI V0, V0, 32
9D0748BC  1040FFFC   BEQ V0, ZERO, 0x9D0748B0
9D0748C0  00000000   NOP
185:                         {
186:                             receivedData = SPI2BUF;
9D0748B0  8C627220   LW V0, 29216(V1)
187:                         }
188:                 
189:                         if (rxSize > txSize)
9D0748C8  00A7702B   SLTU T6, A1, A3
190:                         {
191:                             dummySize = rxSize - txSize;
9D0748CC  00E54023   SUBU T0, A3, A1
9D0748D4  000E400A   MOVZ T0, ZERO, T6
192:                         }
193:                 
194:                         /* If dataBit size is 32 bits */
195:                         if (_SPI2CON_MODE32_MASK == (SPI2CON & _SPI2CON_MODE32_MASK))
9D0748C4  8C627200   LW V0, 29184(V1)
9D0748D0  30420800   ANDI V0, V0, 2048
9D0748D8  10400070   BEQ V0, ZERO, .LVL43
9D0748DC  01007021   ADDU T6, T0, ZERO
196:                         {
197:                             rxSize >>= 2;
9D0748E0  00073882   SRL A3, A3, 2
198:                             txSize >>= 2;
9D0748E4  00052882   SRL A1, A1, 2
199:                             dummySize >>= 2;
9D0748E8  00087082   SRL T6, T0, 2
200:                         }
201:                         /* If dataBit size is 16 bits */
202:                         else if (_SPI2CON_MODE16_MASK == (SPI2CON & _SPI2CON_MODE16_MASK))
9D074A9C  3C02BF82   LUI V0, -16510
9D074AA0  8C427200   LW V0, 29184(V0)
9D074AA4  30420400   ANDI V0, V0, 1024
9D074AA8  1040FF90   BEQ V0, ZERO, .LVL17
9D074AAC  00000000   NOP
203:                         {
204:                             rxSize >>= 1;
9D074AB0  00073842   SRL A3, A3, 1
205:                             txSize >>= 1;
9D074AB4  00052842   SRL A1, A1, 1
206:                             dummySize >>= 1;
9D074AB8  0B41D23B   J .LVL17
9D074ABC  00087042   SRL T6, T0, 1
207:                         }
208:                 
209:                         /* Make sure transmit buffer is empty */
210:                         while((bool)(SPI2STAT & _SPI2STAT_SPITBE_MASK) == false);
9D0748EC  8C627210   LW V0, 29200(V1)
9D0748F0  30420008   ANDI V0, V0, 8
9D0748F4  1040FFFD   BEQ V0, ZERO, .LVL17
9D0748F8  00004821   ADDU T1, ZERO, ZERO
9D0748FC  00005821   ADDU T3, ZERO, ZERO
9D074900  00005021   ADDU T2, ZERO, ZERO
211:                 
212:                         while ((txCount != txSize) || (dummySize != 0))
9D07490C  1145001A   BEQ T2, A1, .LVL24
9D074910  00000000   NOP
9D074970  1545FFE8   BNE T2, A1, 0x9D074914
9D074974  256B0001   ADDIU T3, T3, 1
9D074978  11C00024   BEQ T6, ZERO, 0x9D074A0C
9D07497C  00000000   NOP
213:                         {
214:                             if (txCount != txSize)
215:                             {
216:                                 if((_SPI2CON_MODE32_MASK) == (SPI2CON & (_SPI2CON_MODE32_MASK)))
9D074908  3C0CBF82   LUI T4, -16510
9D074914  8C627200   LW V0, 29184(V1)
9D074918  30420800   ANDI V0, V0, 2048
9D07491C  10400030   BEQ V0, ZERO, .LVL30
9D074920  000A1080   SLL V0, T2, 2
217:                                 {
218:                                     SPI2BUF = ((uint32_t*)pTransmitData)[txCount++];
9D074924  7C82100A   LWX V0, V0(A0)
9D074928  254A0001   ADDIU T2, T2, 1
9D07492C  AD827220   SW V0, 29216(T4)
219:                                 }
220:                                 else if((_SPI2CON_MODE16_MASK) == (SPI2CON & (_SPI2CON_MODE16_MASK)))
9D0749E0  8D827200   LW V0, 29184(T4)
9D0749E4  30420400   ANDI V0, V0, 1024
9D0749E8  5040001C   BEQL V0, ZERO, .LVL36
9D0749EC  7C8A118A   LBUX V0, T2(A0)
221:                                 {
222:                                     SPI2BUF = ((uint16_t*)pTransmitData)[txCount++];
9D0749F0  000A1040   SLL V0, T2, 1
9D0749F4  00821021   ADDU V0, A0, V0
9D0749F8  94420000   LHU V0, 0(V0)
9D0749FC  254A0001   ADDIU T2, T2, 1
9D074A00  AD827220   SW V0, 29216(T4)
9D074A04  0B41D24C   J 0x9D074930
9D074A08  00000000   NOP
223:                                 }
224:                                 else
225:                                 {
226:                                     SPI2BUF = ((uint8_t*)pTransmitData)[txCount++];
9D074A5C  254A0001   ADDIU T2, T2, 1
9D074A60  AD827220   SW V0, 29216(T4)
9D074A64  0B41D24C   J 0x9D074930
9D074A68  00000000   NOP
227:                                 }
228:                             }
229:                             else if (dummySize > 0)
230:                             {
231:                                 SPI2BUF = 0xff;
9D074904  240F00FF   ADDIU T7, ZERO, 255
9D074980  AC6F7220   SW T7, 29216(V1)
232:                                 dummySize--;
233:                             }
234:                 
235:                             if (rxCount == rxSize)
9D074930  11670016   BEQ T3, A3, 0x9D07498C
9D074934  00000000   NOP
9D074984  1567FFEC   BNE T3, A3, 0x9D074938
9D074988  25CEFFFF   ADDIU T6, T6, -1
236:                             {
237:                                 /* If inside this if condition, then it means that txSize > rxSize and all RX bytes are received */
238:                 
239:                                 /* For transmit only request, wait for buffer to become empty */
240:                                 while((bool)(SPI2STAT & _SPI2STAT_SPITBE_MASK) == false);
9D07498C  8C627210   LW V0, 29200(V1)
9D074990  30420008   ANDI V0, V0, 8
9D074994  1040FFFD   BEQ V0, ZERO, 0x9D07498C
9D074998  3C02BF82   LUI V0, -16510
241:                 
242:                                 /* Read until the receive buffer is not empty */
243:                                 while ((bool)(SPI2STAT & _SPI2STAT_SPIRBE_MASK) == false)
9D07499C  8C427210   LW V0, 29200(V0)
9D0749A0  30420020   ANDI V0, V0, 32
9D0749A4  5440FFD9   BNEL V0, ZERO, .LVL18
9D0749A8  00E05821   ADDU T3, A3, ZERO
9D0749B0  8C627210   LW V0, 29200(V1)
9D0749B4  30420020   ANDI V0, V0, 32
9D0749B8  1040FFFC   BEQ V0, ZERO, 0x9D0749AC
9D0749BC  25290001   ADDIU T1, T1, 1
9D0749C0  0B41D243   J .LVL18
9D0749C4  00E05821   ADDU T3, A3, ZERO
244:                                 {
245:                                     receivedData = SPI2BUF;
9D0749AC  8C627220   LW V0, 29216(V1)
246:                                     dummyRxCntr++;
247:                                 }
248:                             }
249:                             else
250:                             {
251:                                 /* If data is read, wait for the Receiver Data the data to become available */
252:                                 while((SPI2STAT & _SPI2STAT_SPIRBE_MASK) == _SPI2STAT_SPIRBE_MASK);
9D074938  8C627210   LW V0, 29200(V1)
9D07493C  30420020   ANDI V0, V0, 32
9D074940  1440FFFD   BNE V0, ZERO, 0x9D074938
9D074944  3C08BF82   LUI T0, -16510
253:                 
254:                                 /* We have data waiting in the SPI buffer */
255:                                 receivedData = SPI2BUF;
9D07494C  8D0D7220   LW T5, 29216(T0)
256:                 
257:                                 if (rxCount < rxSize)
9D074948  0167102B   SLTU V0, T3, A3
9D074950  1040FFEE   BEQ V0, ZERO, .LVL18
9D074954  00000000   NOP
258:                                 {
259:                                     if((_SPI2CON_MODE32_MASK) == (SPI2CON & (_SPI2CON_MODE32_MASK)))
9D074958  8D027200   LW V0, 29184(T0)
9D07495C  30420800   ANDI V0, V0, 2048
9D074960  10400042   BEQ V0, ZERO, .LVL38
9D074964  000B1080   SLL V0, T3, 2
260:                                     {
261:                                         ((uint32_t*)pReceiveData)[rxCount++]  = receivedData;
9D074968  00C21021   ADDU V0, A2, V0
9D07496C  AC4D0000   SW T5, 0(V0)
262:                                     }
263:                                     else if((_SPI2CON_MODE16_MASK) == (SPI2CON & (_SPI2CON_MODE16_MASK)))
9D074A6C  8D027200   LW V0, 29184(T0)
9D074A70  30420400   ANDI V0, V0, 1024
9D074A74  10400006   BEQ V0, ZERO, .LVL41
9D074A78  00CB1021   ADDU V0, A2, T3
264:                                     {
265:                                         ((uint16_t*)pReceiveData)[rxCount++]  = receivedData;
9D074A7C  000B1040   SLL V0, T3, 1
9D074A80  00C21021   ADDU V0, A2, V0
9D074A84  A44D0000   SH T5, 0(V0)
9D074A88  0B41D243   J .LVL18
9D074A8C  256B0001   ADDIU T3, T3, 1
266:                                     }
267:                                     else
268:                                     {
269:                                         ((uint8_t*)pReceiveData)[rxCount++]  = receivedData;
9D074A90  A04D0000   SB T5, 0(V0)
9D074A94  0B41D243   J .LVL18
9D074A98  256B0001   ADDIU T3, T3, 1
270:                                     }
271:                                 }
272:                             }
273:                         }
274:                 
275:                         /* Make sure no data is pending in the shift register */
276:                         while ((bool)((SPI2STAT & _SPI2STAT_SRMT_MASK) == false));
9D074A0C  8C627210   LW V0, 29200(V1)
9D074A10  30420080   ANDI V0, V0, 128
9D074A14  1040FFFD   BEQ V0, ZERO, 0x9D074A0C
9D074A18  00E5202B   SLTU A0, A3, A1
277:                 
278:                         /* Make sure for every character transmitted a character is also received back.
279:                          * If this is not done, we may prematurely exit this routine with the last bit still being
280:                          * transmitted out. As a result, the application may prematurely deselect the CS line and also
281:                          * the next request can receive last character of previous request as its first character.
282:                          */
283:                         if (txSize > rxSize)
9D074A20  1080FFED   BEQ A0, ZERO, .LVL29
9D074A24  00A72823   SUBU A1, A1, A3
284:                         {
285:                             while (dummyRxCntr != (txSize - rxSize))
9D074A28  1125FFEB   BEQ T1, A1, .LVL29
9D074A2C  24020001   ADDIU V0, ZERO, 1
286:                             {
287:                                 /* Wait for all the RX bytes to be received. */
288:                                 while ((bool)(SPI2STAT & _SPI2STAT_SPIRBE_MASK) == false)
9D074A30  8C627210   LW V0, 29200(V1)
9D074A34  30420020   ANDI V0, V0, 32
9D074A38  1440FFFB   BNE V0, ZERO, 0x9D074A28
9D074A3C  00000000   NOP
9D074A44  8C627210   LW V0, 29200(V1)
9D074A48  30420020   ANDI V0, V0, 32
9D074A4C  1040FFFC   BEQ V0, ZERO, 0x9D074A40
9D074A50  25290001   ADDIU T1, T1, 1
9D074A54  0B41D28A   J 0x9D074A28
9D074A58  00000000   NOP
289:                                 {
290:                                     receivedData = SPI2BUF;
9D074A40  8C627220   LW V0, 29216(V1)
291:                                     dummyRxCntr++;
292:                                 }
293:                             }
294:                         }
295:                 
296:                         isSuccess = true;
9D074A1C  24020001   ADDIU V0, ZERO, 1
297:                     }
298:                 
299:                     return isSuccess;
300:                 }
9D0749D8  03E00008   JR RA
9D0749DC  00000000   NOP
9D0749E0  8D827200   LW V0, 29184(T4)
9D0749E4  30420400   ANDI V0, V0, 1024
9D0749E8  5040001C   BEQL V0, ZERO, .LVL36
9D0749EC  7C8A118A   LBUX V0, T2(A0)
9D0749F0  000A1040   SLL V0, T2, 1
9D0749F4  00821021   ADDU V0, A0, V0
9D0749F8  94420000   LHU V0, 0(V0)
9D0749FC  254A0001   ADDIU T2, T2, 1
9D074A00  AD827220   SW V0, 29216(T4)
9D074A04  0B41D24C   J 0x9D074930
9D074A08  00000000   NOP
9D074A0C  8C627210   LW V0, 29200(V1)
9D074A10  30420080   ANDI V0, V0, 128
9D074A14  1040FFFD   BEQ V0, ZERO, 0x9D074A0C
9D074A18  00E5202B   SLTU A0, A3, A1
9D074A1C  24020001   ADDIU V0, ZERO, 1
9D074A20  1080FFED   BEQ A0, ZERO, .LVL29
9D074A24  00A72823   SUBU A1, A1, A3
9D074A28  1125FFEB   BEQ T1, A1, .LVL29
9D074A2C  24020001   ADDIU V0, ZERO, 1
9D074A30  8C627210   LW V0, 29200(V1)
9D074A34  30420020   ANDI V0, V0, 32
9D074A38  1440FFFB   BNE V0, ZERO, 0x9D074A28
9D074A3C  00000000   NOP
9D074A40  8C627220   LW V0, 29216(V1)
9D074A44  8C627210   LW V0, 29200(V1)
9D074A48  30420020   ANDI V0, V0, 32
9D074A4C  1040FFFC   BEQ V0, ZERO, 0x9D074A40
9D074A50  25290001   ADDIU T1, T1, 1
9D074A54  0B41D28A   J 0x9D074A28
9D074A58  00000000   NOP
9D074A5C  254A0001   ADDIU T2, T2, 1
9D074A60  AD827220   SW V0, 29216(T4)
9D074A64  0B41D24C   J 0x9D074930
9D074A68  00000000   NOP
9D074A6C  8D027200   LW V0, 29184(T0)
9D074A70  30420400   ANDI V0, V0, 1024
9D074A74  10400006   BEQ V0, ZERO, .LVL41
9D074A78  00CB1021   ADDU V0, A2, T3
9D074A7C  000B1040   SLL V0, T3, 1
9D074A80  00C21021   ADDU V0, A2, V0
9D074A84  A44D0000   SH T5, 0(V0)
9D074A88  0B41D243   J .LVL18
9D074A8C  256B0001   ADDIU T3, T3, 1
9D074A90  A04D0000   SB T5, 0(V0)
9D074A94  0B41D243   J .LVL18
9D074A98  256B0001   ADDIU T3, T3, 1
9D074A9C  3C02BF82   LUI V0, -16510
9D074AA0  8C427200   LW V0, 29184(V0)
9D074AA4  30420400   ANDI V0, V0, 1024
9D074AA8  1040FF90   BEQ V0, ZERO, .LVL17
9D074AAC  00000000   NOP
9D074AB0  00073842   SRL A3, A3, 1
9D074AB4  00052842   SRL A1, A1, 1
9D074AB8  0B41D23B   J .LVL17
9D074ABC  00087042   SRL T6, T0, 1
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/spi/spi_master/plib_spi1_master.c
1:                   /*******************************************************************************
2:                     SPI PLIB
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_spi1_master.c
9:                   
10:                    Summary:
11:                      SPI1 Master Source File
12:                  
13:                    Description:
14:                      This file has implementation of all the interfaces provided for particular
15:                      SPI peripheral.
16:                  
17:                  *******************************************************************************/
18:                  
19:                  /*******************************************************************************
20:                  * Copyright (C) 2018-2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  
42:                  #include "plib_spi1_master.h"
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: SPI1 Implementation
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  /* Global object to save SPI Exchange related data */
51:                  SPI_OBJECT spi1Obj;
52:                  
53:                  #define SPI1_CON_MSTEN                      (1 << _SPI1CON_MSTEN_POSITION)
54:                  #define SPI1_CON_CKP                        (1 << _SPI1CON_CKP_POSITION)
55:                  #define SPI1_CON_CKE                        (0 << _SPI1CON_CKE_POSITION)
56:                  #define SPI1_CON_MODE_32_MODE_16            (0 << _SPI1CON_MODE16_POSITION)
57:                  #define SPI1_CON_ENHBUF                     (1 << _SPI1CON_ENHBUF_POSITION)
58:                  #define SPI1_CON_MCLKSEL                    (0 << _SPI1CON_MCLKSEL_POSITION)
59:                  #define SPI1_CON_MSSEN                      (0 << _SPI1CON_MSSEN_POSITION)
60:                  #define SPI1_CON_SMP                        (0 << _SPI1CON_SMP_POSITION)
61:                  
62:                  void SPI1_Initialize ( void )
63:                  {
64:                      uint32_t rdata;
65:                  
66:                      /* Disable SPI1 Interrupts */
67:                      IEC1CLR = 0x8;
9D07867C  3C03BF81   LUI V1, -16511
9D078680  24070008   ADDIU A3, ZERO, 8
9D07868C  AC6700D4   SW A3, 212(V1)
68:                      IEC1CLR = 0x10;
9D078684  24050010   ADDIU A1, ZERO, 16
9D078698  AC6500D4   SW A1, 212(V1)
69:                      IEC1CLR = 0x20;
9D078688  24040020   ADDIU A0, ZERO, 32
9D07869C  AC6400D4   SW A0, 212(V1)
70:                  
71:                      /* STOP and Reset the SPI */
72:                      SPI1CON = 0;
9D078678  3C02BF82   LUI V0, -16510
9D0786A0  AC407000   SW ZERO, 28672(V0)
73:                  
74:                      /* Clear the Receiver buffer */
75:                      rdata = SPI1BUF;
9D0786A4  8C487020   LW T0, 28704(V0)
76:                      rdata = rdata;
77:                  
78:                      /* Clear SPI1 Interrupt flags */
79:                      IFS1CLR = 0x8;
9D0786AC  AC670054   SW A3, 84(V1)
80:                      IFS1CLR = 0x10;
9D0786B4  AC650054   SW A1, 84(V1)
81:                      IFS1CLR = 0x20;
9D0786B8  AC640054   SW A0, 84(V1)
82:                  
83:                      /* BAUD Rate register Setup */
84:                      SPI1BRG = 3;
9D0786BC  24030003   ADDIU V1, ZERO, 3
9D0786C0  AC437030   SW V1, 28720(V0)
85:                  
86:                      /* CLear the Overflow */
87:                      SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
9D0786C4  24030040   ADDIU V1, ZERO, 64
9D0786C8  AC437014   SW V1, 28692(V0)
88:                  
89:                      /*
90:                      MSTEN = 1
91:                      CKP = 1
92:                      CKE = 0
93:                      MODE<32,16> = 0
94:                      ENHBUF = 1
95:                      MSSEN = 0
96:                      MCLKSEL = 0
97:                      */
98:                      SPI1CONSET = (SPI1_CON_MSSEN | SPI1_CON_MCLKSEL | SPI1_CON_ENHBUF | SPI1_CON_MODE_32_MODE_16 | SPI1_CON_CKE | SPI1_CON_CKP | SPI1_CON_MSTEN | SPI1_CON_SMP);
9D0786CC  3C030001   LUI V1, 1
9D0786D0  24630060   ADDIU V1, V1, 96
9D0786D4  AC437008   SW V1, 28680(V0)
99:                  
100:                     /* Enable transmit interrupt when transmit buffer is completely empty (STXISEL = '01') */
101:                     /* Enable receive interrupt when the receive buffer is not empty (SRXISEL = '01') */
102:                     SPI1CONSET = 0x00000005;
9D0786D8  24030005   ADDIU V1, ZERO, 5
9D0786DC  AC437008   SW V1, 28680(V0)
103:                 
104:                     /* Initialize global variables */
105:                     spi1Obj.transferIsBusy = false;
9D078690  3C068000   LUI A2, -32768
9D078694  24C6011C   ADDIU A2, A2, 284
9D0786A8  A0C0001C   SB ZERO, 28(A2)
106:                     spi1Obj.callback = NULL;
9D0786B0  ACC00020   SW ZERO, 32(A2)
107:                 
108:                     /* Enable SPI1 */
109:                     SPI1CONSET = _SPI1CON_ON_MASK;
9D0786E0  34038000   ORI V1, ZERO, -32768
9D0786E4  AC437008   SW V1, 28680(V0)
9D0786E8  03E00008   JR RA
9D0786EC  00000000   NOP
110:                 }
111:                 
112:                 bool SPI1_TransferSetup (SPI_TRANSFER_SETUP* setup, uint32_t spiSourceClock )
113:                 {
114:                     uint32_t t_brg;
115:                     uint32_t baudHigh;
116:                     uint32_t baudLow;
117:                     uint32_t errorHigh;
118:                     uint32_t errorLow;
119:                 
120:                     if ((setup == NULL) || (setup->clockFrequency == 0))
00000000  00000000   NOP
121:                     {
122:                         return false;
123:                     }
124:                 
125:                     if(spiSourceClock == 0)
00000014  00000000   NOP
126:                     {
127:                         // Use Master Clock Frequency set in GUI
128:                         spiSourceClock = 60000000;
0000001C  00000000   NOP
129:                     }
130:                 
131:                     t_brg = (((spiSourceClock / (setup->clockFrequency)) / 2u) - 1u);
00000024  00000000   NOP
00000060  00000000   NOP
132:                     baudHigh = spiSourceClock / (2u * (t_brg + 1u));
00000034  00000000   NOP
0000003C  00000000   NOP
133:                     baudLow = spiSourceClock / (2u * (t_brg + 2u));
00000038  00000000   NOP
00000048  00000000   NOP
134:                     errorHigh = baudHigh - setup->clockFrequency;
00000054  00000000   NOP
135:                     errorLow = setup->clockFrequency - baudLow;
00000058  00000000   NOP
136:                 
137:                     if (errorHigh > errorLow)
0000005C  00000000   NOP
138:                     {
139:                         t_brg++;
140:                     }
141:                 
142:                     if(t_brg > 8191)
00000068  00000000   NOP
143:                     {
144:                         return false;
145:                     }
146:                 
147:                     SPI1BRG = t_brg;
00000074  00000000   NOP
148:                     SPI1CON = (SPI1CON & (~(_SPI1CON_MODE16_MASK | _SPI1CON_MODE32_MASK | _SPI1CON_CKP_MASK | _SPI1CON_CKE_MASK))) |
00000084  00000000   NOP
00000094  00000000   NOP
149:                                             (setup->clockPolarity | setup->clockPhase | setup->dataBits);
0000007C  00000000   NOP
00000088  00000000   NOP
150:                 
151:                     return true;
000000A4  00000000   NOP
152:                 }
000000AC  00000000   NOP
153:                 
154:                 bool SPI1_Write(void* pTransmitData, size_t txSize)
155:                 {
156:                     return(SPI1_WriteRead(pTransmitData, txSize, NULL, 0));
9D0791C4  00003021   ADDU A2, ZERO, ZERO
9D0791C8  0B41D33E   J .LFB8, .LVL12, .LFE4, SPI1_WriteRead
9D0791CC  00003821   ADDU A3, ZERO, ZERO
157:                 }
158:                 
159:                 bool SPI1_Read(void* pReceiveData, size_t rxSize)
160:                 {
00000000  00000000   NOP
161:                     return(SPI1_WriteRead(NULL, 0, pReceiveData, rxSize));
00000008  00000000   NOP
162:                 }
163:                 
164:                 bool SPI1_WriteRead (void* pTransmitData, size_t txSize, void* pReceiveData, size_t rxSize)
165:                 {
166:                     bool isRequestAccepted = false;
167:                     uint32_t dummyData;
168:                 
169:                     /* Verify the request */
170:                     if((((txSize > 0) && (pTransmitData != NULL)) || ((rxSize > 0) && (pReceiveData != NULL))) && (spi1Obj.transferIsBusy == false))
9D074CF8  10A0004C   BEQ A1, ZERO, .LVL18
9D074CFC  00000000   NOP
9D074D00  1080004A   BEQ A0, ZERO, .LVL18
9D074D04  3C038000   LUI V1, -32768
9D074D08  2468011C   ADDIU T0, V1, 284
9D074D0C  9109001C   LBU T1, 28(T0)
9D074D10  15200044   BNE T1, ZERO, .LVL17, .LBE4
9D074D14  00001021   ADDU V0, ZERO, ZERO
9D074E2C  10E0FFFD   BEQ A3, ZERO, .LVL17, .LBE4
9D074E30  00001021   ADDU V0, ZERO, ZERO
9D074E34  10C0FFFB   BEQ A2, ZERO, .LVL17, .LBE4
9D074E38  3C038000   LUI V1, -32768
9D074E3C  2468011C   ADDIU T0, V1, 284
9D074E40  9109001C   LBU T1, 28(T0)
9D074E44  5120FFB5   BEQL T1, ZERO, 0x9D074D1C
9D074E48  AC64011C   SW A0, 284(V1)
9D074E4C  0B41D389   J .LVL17, .LBE4
9D074E50  00000000   NOP
171:                     {
172:                         isRequestAccepted = true;
173:                         spi1Obj.txBuffer = pTransmitData;
9D074D18  AC64011C   SW A0, 284(V1)
174:                         spi1Obj.rxBuffer = pReceiveData;
9D074D1C  AD060004   SW A2, 4(T0)
175:                         spi1Obj.rxCount = 0;
9D074D20  AD000014   SW ZERO, 20(T0)
176:                         spi1Obj.txCount = 0;
9D074D24  AD000018   SW ZERO, 24(T0)
177:                         spi1Obj.dummySize = 0;
178:                 
179:                         if (pTransmitData != NULL)
9D074D28  1080006F   BEQ A0, ZERO, .LVL26, .LBB12
9D074D2C  AD000010   SW ZERO, 16(T0)
180:                         {
181:                             spi1Obj.txSize = txSize;
9D074D30  AD050008   SW A1, 8(T0)
182:                         }
183:                         else
184:                         {
185:                             spi1Obj.txSize = 0;
9D074EE8  AD000008   SW ZERO, 8(T0)
9D074EEC  0B41D34D   J .LVL14
9D074EF0  00002821   ADDU A1, ZERO, ZERO
186:                         }
187:                 
188:                         if (pReceiveData != NULL)
9D074D34  10C00067   BEQ A2, ZERO, .LVL25
9D074D38  00A7102B   SLTU V0, A1, A3
189:                         {
190:                             spi1Obj.rxSize = rxSize;
9D074D3C  AD07000C   SW A3, 12(T0)
191:                         }
192:                         else
193:                         {
194:                             spi1Obj.rxSize = 0;
9D074ED4  AD00000C   SW ZERO, 12(T0)
195:                         }
196:                 
197:                         spi1Obj.transferIsBusy = true;
9D074D40  24030001   ADDIU V1, ZERO, 1
9D074ED8  24020001   ADDIU V0, ZERO, 1
9D074EDC  A102001C   SB V0, 28(T0)
9D074EE0  0B41D356   J 0x9D074D58
9D074EE4  00006021   ADDU T4, ZERO, ZERO
198:                 
199:                         if (spi1Obj.rxSize > spi1Obj.txSize)
9D074D44  10400003   BEQ V0, ZERO, 0x9D074D54
9D074D48  A103001C   SB V1, 28(T0)
200:                         {
201:                             spi1Obj.dummySize = spi1Obj.rxSize - spi1Obj.txSize;
9D074D4C  00E51023   SUBU V0, A3, A1
9D074D50  AD020010   SW V0, 16(T0)
9D074D54  00E06021   ADDU T4, A3, ZERO
202:                         }
203:                 
204:                         /* Clear the receive overflow error if any */
205:                         SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
9D074D58  3C02BF82   LUI V0, -16510
9D074D5C  24030040   ADDIU V1, ZERO, 64
9D074D60  AC437014   SW V1, 28692(V0)
206:                 
207:                         /* Make sure there is no data pending in the RX FIFO */
208:                         /* Depending on 8/16/32 bit mode, there may be 16/8/4 bytes in the FIFO */
209:                         while ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
9D074D64  8C437010   LW V1, 28688(V0)
9D074D68  30630020   ANDI V1, V1, 32
9D074D6C  14600006   BNE V1, ZERO, 0x9D074D88
9D074D70  3C03BF81   LUI V1, -16511
9D074D78  8C437010   LW V1, 28688(V0)
9D074D7C  30630020   ANDI V1, V1, 32
9D074D80  1060FFFC   BEQ V1, ZERO, 0x9D074D74
9D074D84  3C03BF81   LUI V1, -16511
210:                         {
211:                             dummyData = SPI1BUF;
9D074D74  8C437020   LW V1, 28704(V0)
212:                             (void)dummyData;
213:                         }
214:                 
215:                         /* Configure SPI to generate receive interrupt when receive buffer is empty (SRXISEL = '01') */
216:                         SPI1CONCLR = _SPI1CON_SRXISEL_MASK;
9D074D94  240B0003   ADDIU T3, ZERO, 3
9D074D98  AC4B7004   SW T3, 28676(V0)
217:                         SPI1CONSET = 0x00000001;
9D074D90  240A0001   ADDIU T2, ZERO, 1
9D074D9C  AC4A7008   SW T2, 28680(V0)
218:                 
219:                         /* Configure SPI to generate transmit interrupt when the transmit shift register is empty (STXISEL = '00')*/
220:                         SPI1CONCLR = _SPI1CON_STXISEL_MASK;
9D074DA0  240B000C   ADDIU T3, ZERO, 12
9D074DA4  AC4B7004   SW T3, 28676(V0)
221:                 
222:                         /* Disable the receive interrupt */
223:                         IEC1CLR = 0x10;
9D074D88  24090010   ADDIU T1, ZERO, 16
9D074DA8  AC6900D4   SW T1, 212(V1)
224:                 
225:                         /* Disable the transmit interrupt */
226:                         IEC1CLR = 0x20;
9D074D8C  24060020   ADDIU A2, ZERO, 32
9D074DAC  AC6600D4   SW A2, 212(V1)
227:                 
228:                         /* Clear the receive interrupt flag */
229:                         IFS1CLR = 0x10;
9D074DB0  AC690054   SW T1, 84(V1)
230:                 
231:                         /* Clear the transmit interrupt flag */
232:                         IFS1CLR = 0x20;
9D074DB4  AC660054   SW A2, 84(V1)
233:                 
234:                         /* Start the first write here itself, rest will happen in ISR context */
235:                         if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
9D074DB8  8C497000   LW T1, 28672(V0)
9D074DBC  31290800   ANDI T1, T1, 2048
9D074DC0  11200024   BEQ T1, ZERO, .LVL19, .LBB10
9D074DC4  3C06BF82   LUI A2, -16510
236:                         {
237:                             spi1Obj.txSize >>= 2;
9D074DCC  00052882   SRL A1, A1, 2
9D074DD8  AD050008   SW A1, 8(T0)
238:                             spi1Obj.dummySize >>= 2;
9D074DC8  8D090010   LW T1, 16(T0)
9D074DD4  00094882   SRL T1, T1, 2
9D074DDC  AD090010   SW T1, 16(T0)
239:                             spi1Obj.rxSize >>= 2;
9D074DD0  000C6082   SRL T4, T4, 2
240:                 
241:                             if(spi1Obj.txCount < spi1Obj.txSize)
9D074DE0  14A00030   BNE A1, ZERO, .LVL21, .LBB11
9D074DE4  AD0C000C   SW T4, 12(T0)
242:                             {
243:                                 SPI1BUF = *((uint32_t*)spi1Obj.txBuffer);
9D074EA4  8C840000   LW A0, 0(A0)
9D074EAC  ACC47020   SW A0, 28704(A2)
9D074EB0  0B41D37F   J 0x9D074DFC
9D074EB4  00000000   NOP
244:                                 spi1Obj.txCount++;
9D074EA8  AD0A0018   SW T2, 24(T0)
245:                             }
246:                             else if (spi1Obj.dummySize > 0)
247:                             {
248:                                 SPI1BUF = (uint32_t)(0xff);
249:                                 spi1Obj.dummySize--;
250:                             }
251:                         }
252:                         else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
9D074E54  8CC97000   LW T1, 28672(A2)
9D074E58  31290400   ANDI T1, T1, 1024
9D074E5C  11200016   BEQ T1, ZERO, .LVL23
9D074E60  000C6042   SRL T4, T4, 1
253:                         {
254:                             spi1Obj.txSize >>= 1;
9D074E68  00052842   SRL A1, A1, 1
9D074E70  AD050008   SW A1, 8(T0)
255:                             spi1Obj.dummySize >>= 1;
9D074E64  8D090010   LW T1, 16(T0)
9D074E6C  00094842   SRL T1, T1, 1
9D074E74  AD090010   SW T1, 16(T0)
256:                             spi1Obj.rxSize >>= 1;
257:                 
258:                             if (spi1Obj.txCount < spi1Obj.txSize)
9D074E78  10A0FFDB   BEQ A1, ZERO, 0x9D074DE8
9D074E7C  AD0C000C   SW T4, 12(T0)
259:                             {
260:                                 SPI1BUF = *((uint16_t*)spi1Obj.txBuffer);
9D074E80  94840000   LHU A0, 0(A0)
9D074E88  ACC47020   SW A0, 28704(A2)
261:                                 spi1Obj.txCount++;
9D074E84  AD0A0018   SW T2, 24(T0)
262:                             }
263:                             else if (spi1Obj.dummySize > 0)
9D074DE8  11200004   BEQ T1, ZERO, 0x9D074DFC
9D074DEC  2529FFFF   ADDIU T1, T1, -1
264:                             {
265:                                 SPI1BUF = (uint16_t)(0xff);
9D074DF0  240400FF   ADDIU A0, ZERO, 255
9D074DF4  ACC47020   SW A0, 28704(A2)
266:                                 spi1Obj.dummySize--;
9D074DF8  AD090010   SW T1, 16(T0)
267:                             }
268:                         }
269:                         else
270:                         {
271:                             if (spi1Obj.txCount < spi1Obj.txSize)
9D074EB8  50A0000E   BEQL A1, ZERO, .LVL28, .LBB13
9D074EBC  8D040010   LW A0, 16(T0)
272:                             {
273:                                 SPI1BUF = *((uint8_t*)spi1Obj.txBuffer);
9D074EC0  90840000   LBU A0, 0(A0)
9D074EC8  ACC47020   SW A0, 28704(A2)
9D074ECC  0B41D37F   J 0x9D074DFC
9D074ED0  00000000   NOP
274:                                 spi1Obj.txCount++;
9D074EC4  AD0A0018   SW T2, 24(T0)
275:                             }
276:                             else if (spi1Obj.dummySize > 0)
9D074EF4  1080FFC1   BEQ A0, ZERO, 0x9D074DFC
9D074EF8  2484FFFF   ADDIU A0, A0, -1
277:                             {
278:                                 SPI1BUF = (uint8_t)(0xff);
9D074EFC  240500FF   ADDIU A1, ZERO, 255
9D074F00  ACC57020   SW A1, 28704(A2)
279:                                 spi1Obj.dummySize--;
9D074F04  0B41D37F   J 0x9D074DFC
9D074F08  AD040010   SW A0, 16(T0)
280:                             }
281:                         }
282:                 
283:                         if (rxSize > 0)
9D074DFC  54E00026   BNEL A3, ZERO, 0x9D074E98
9D074E00  24020010   ADDIU V0, ZERO, 16
9D074E8C  50E0FFDE   BEQL A3, ZERO, 0x9D074E08
9D074E90  8D050018   LW A1, 24(T0)
284:                         {
285:                             /* Enable receive interrupt to complete the transfer in ISR context.
286:                              * Keep the transmit interrupt disabled. Transmit interrupt will be
287:                              * enabled later if txCount < txSize, when rxCount = rxSize.
288:                              */
289:                             IEC1SET = 0x10;
9D074E94  24020010   ADDIU V0, ZERO, 16
9D074E98  AC6200D8   SW V0, 216(V1)
9D074E9C  03E00008   JR RA
9D074EA0  24020001   ADDIU V0, ZERO, 1
290:                         }
291:                         else
292:                         {
293:                             if (spi1Obj.txCount != spi1Obj.txSize)
9D074E04  8D050018   LW A1, 24(T0)
9D074E08  8D040008   LW A0, 8(T0)
9D074E0C  10A40002   BEQ A1, A0, 0x9D074E18
9D074E10  24040004   ADDIU A0, ZERO, 4
294:                             {
295:                                 /* Configure SPI to generate transmit buffer empty interrupt only if more than
296:                                  * data is pending (STXISEL = '01')  */
297:                                 SPI1CONSET = 0x00000004;
9D074E14  AC447008   SW A0, 28680(V0)
298:                             }
299:                             /* Enable transmit interrupt to complete the transfer in ISR context */
300:                             IEC1SET = 0x20;
9D074E18  24020020   ADDIU V0, ZERO, 32
9D074E1C  AC6200D8   SW V0, 216(V1)
9D074E20  24020001   ADDIU V0, ZERO, 1
301:                         }
302:                     }
303:                 
304:                     return isRequestAccepted;
305:                 }
9D074E24  03E00008   JR RA
9D074E28  00000000   NOP
9D074E2C  10E0FFFD   BEQ A3, ZERO, .LVL17, .LBE4
9D074E30  00001021   ADDU V0, ZERO, ZERO
9D074E34  10C0FFFB   BEQ A2, ZERO, .LVL17, .LBE4
9D074E38  3C038000   LUI V1, -32768
9D074E3C  2468011C   ADDIU T0, V1, 284
9D074E40  9109001C   LBU T1, 28(T0)
9D074E44  5120FFB5   BEQL T1, ZERO, 0x9D074D1C
9D074E48  AC64011C   SW A0, 284(V1)
9D074E4C  0B41D389   J .LVL17, .LBE4
9D074E50  00000000   NOP
9D074E54  8CC97000   LW T1, 28672(A2)
9D074E58  31290400   ANDI T1, T1, 1024
9D074E5C  11200016   BEQ T1, ZERO, .LVL23
9D074E60  000C6042   SRL T4, T4, 1
9D074E64  8D090010   LW T1, 16(T0)
9D074E68  00052842   SRL A1, A1, 1
9D074E6C  00094842   SRL T1, T1, 1
9D074E70  AD050008   SW A1, 8(T0)
9D074E74  AD090010   SW T1, 16(T0)
9D074E78  10A0FFDB   BEQ A1, ZERO, 0x9D074DE8
9D074E7C  AD0C000C   SW T4, 12(T0)
9D074E80  94840000   LHU A0, 0(A0)
9D074E84  AD0A0018   SW T2, 24(T0)
9D074E88  ACC47020   SW A0, 28704(A2)
9D074E8C  50E0FFDE   BEQL A3, ZERO, 0x9D074E08
9D074E90  8D050018   LW A1, 24(T0)
9D074E94  24020010   ADDIU V0, ZERO, 16
9D074E98  AC6200D8   SW V0, 216(V1)
9D074E9C  03E00008   JR RA
9D074EA0  24020001   ADDIU V0, ZERO, 1
9D074EA4  8C840000   LW A0, 0(A0)
9D074EA8  AD0A0018   SW T2, 24(T0)
9D074EAC  ACC47020   SW A0, 28704(A2)
9D074EB0  0B41D37F   J 0x9D074DFC
9D074EB4  00000000   NOP
9D074EB8  50A0000E   BEQL A1, ZERO, .LVL28, .LBB13
9D074EBC  8D040010   LW A0, 16(T0)
9D074EC0  90840000   LBU A0, 0(A0)
9D074EC4  AD0A0018   SW T2, 24(T0)
9D074EC8  ACC47020   SW A0, 28704(A2)
9D074ECC  0B41D37F   J 0x9D074DFC
9D074ED0  00000000   NOP
9D074ED4  AD00000C   SW ZERO, 12(T0)
9D074ED8  24020001   ADDIU V0, ZERO, 1
9D074EDC  A102001C   SB V0, 28(T0)
9D074EE0  0B41D356   J 0x9D074D58
9D074EE4  00006021   ADDU T4, ZERO, ZERO
9D074EE8  AD000008   SW ZERO, 8(T0)
9D074EEC  0B41D34D   J .LVL14
9D074EF0  00002821   ADDU A1, ZERO, ZERO
9D074EF4  1080FFC1   BEQ A0, ZERO, 0x9D074DFC
9D074EF8  2484FFFF   ADDIU A0, A0, -1
9D074EFC  240500FF   ADDIU A1, ZERO, 255
9D074F00  ACC57020   SW A1, 28704(A2)
9D074F04  0B41D37F   J 0x9D074DFC
9D074F08  AD040010   SW A0, 16(T0)
306:                 
307:                 bool SPI1_IsBusy (void)
308:                 {
309:                     return ( (spi1Obj.transferIsBusy) || ((SPI1STAT & _SPI1STAT_SRMT_MASK) == 0));
9D079010  3C028000   LUI V0, -32768
9D079014  90420138   LBU V0, 312(V0)
9D079018  14400005   BNE V0, ZERO, 0x9D079030
9D07901C  00000000   NOP
9D079020  3C02BF82   LUI V0, -16510
9D079024  8C427010   LW V0, 28688(V0)
9D079028  38420080   XORI V0, V0, 128
9D07902C  7C4201C0   EXT V0, V0, 7, 1
310:                 }
9D079030  03E00008   JR RA
9D079034  00000000   NOP
311:                 
312:                 void SPI1_CallbackRegister (SPI_CALLBACK callback, uintptr_t context)
313:                 {
314:                     spi1Obj.callback = callback;
00000000  00000000   NOP
315:                 
316:                     spi1Obj.context = context;
0000000C  00000000   NOP
317:                 }
318:                 
319:                 void SPI1_RX_InterruptHandler (void)
320:                 {
9D07463C  27BDFFE8   ADDIU SP, SP, -24
9D074640  AFBF0014   SW RA, 20(SP)
9D074644  AFB00010   SW S0, 16(SP)
321:                     uint32_t receivedData = 0;
322:                 
323:                     /* Check if the receive buffer is empty or not */
324:                     if ((bool)(SPI1STAT & _SPI1STAT_SPIRBE_MASK) == false)
9D074648  3C03BF82   LUI V1, -16510
9D07464C  8C627010   LW V0, 28688(V1)
9D074650  30420020   ANDI V0, V0, 32
9D074654  14400044   BNE V0, ZERO, 0x9D074768
9D074658  3C028000   LUI V0, -32768
325:                     {
326:                         /* Receive buffer is not empty. Read the received data. */
327:                         receivedData = SPI1BUF;
9D074668  8C677020   LW A3, 28704(V1)
328:                 
329:                         if (spi1Obj.rxCount < spi1Obj.rxSize)
9D07465C  2442011C   ADDIU V0, V0, 284
9D074660  8C440014   LW A0, 20(V0)
9D074664  8C45000C   LW A1, 12(V0)
9D07466C  0085302B   SLTU A2, A0, A1
9D074670  10C0002B   BEQ A2, ZERO, .LVL38
9D074674  00000000   NOP
330:                         {
331:                             /* Copy the received data to the user buffer */
332:                             if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
9D074678  8C667000   LW A2, 28672(V1)
9D07467C  30C60800   ANDI A2, A2, 2048
9D074680  54C00040   BNEL A2, ZERO, .LVL40
9D074684  8C480004   LW T0, 4(V0)
333:                             {
334:                                 ((uint32_t*)spi1Obj.rxBuffer)[spi1Obj.rxCount++] = receivedData;
9D074784  00043080   SLL A2, A0, 2
9D074788  24840001   ADDIU A0, A0, 1
9D07478C  01063021   ADDU A2, T0, A2
9D074790  AC440014   SW A0, 20(V0)
9D074794  0B41D1AC   J 0x9D0746B0
9D074798  ACC70000   SW A3, 0(A2)
335:                             }
336:                             else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
9D074688  8C667000   LW A2, 28672(V1)
9D07468C  30C60400   ANDI A2, A2, 1024
9D074690  50C00052   BEQL A2, ZERO, 0x9D0747DC
9D074694  8C450004   LW A1, 4(V0)
337:                             {
338:                                 ((uint16_t*)spi1Obj.rxBuffer)[spi1Obj.rxCount++] = receivedData;
9D074698  8C480004   LW T0, 4(V0)
9D07469C  00043040   SLL A2, A0, 1
9D0746A0  24840001   ADDIU A0, A0, 1
9D0746A4  01063021   ADDU A2, T0, A2
9D0746A8  AC440014   SW A0, 20(V0)
9D0746AC  A4C70000   SH A3, 0(A2)
339:                             }
340:                             else
341:                             {
342:                                 ((uint8_t*)spi1Obj.rxBuffer)[spi1Obj.rxCount++] = receivedData;
9D0747DC  24860001   ADDIU A2, A0, 1
9D0747E0  AC460014   SW A2, 20(V0)
9D0747E4  00A42021   ADDU A0, A1, A0
9D0747E8  A0870000   SB A3, 0(A0)
9D0747EC  8C440014   LW A0, 20(V0)
9D0747F0  0B41D1AC   J 0x9D0746B0
9D0747F4  8C45000C   LW A1, 12(V0)
343:                             }
344:                             if ((spi1Obj.rxCount == spi1Obj.rxSize) && (spi1Obj.txCount < spi1Obj.txSize))
9D0746B0  1085003A   BEQ A0, A1, 0x9D07479C
9D0746B4  0085202B   SLTU A0, A0, A1
9D07479C  8C450018   LW A1, 24(V0)
9D0747A0  8C440008   LW A0, 8(V0)
9D0747A4  00A4302B   SLTU A2, A1, A0
9D0747A8  10C0FFE1   BEQ A2, ZERO, 0x9D074730
9D0747AC  3C10BF81   LUI S0, -16511
345:                             {
346:                                 /* Reception of all bytes is complete. However, there are few more
347:                                  * bytes to be transmitted as txCount != txSize. Finish the
348:                                  * transmission of the remaining bytes from the transmit interrupt. */
349:                 
350:                                 /* Disable the receive interrupt */
351:                                 IEC1CLR = 0x10;
9D0747B0  24040010   ADDIU A0, ZERO, 16
9D0747B4  AE0400D4   SW A0, 212(S0)
352:                 
353:                                 /* Generate TX interrupt when buffer is completely empty (STXISEL = '00') */
354:                                 SPI1CONCLR = _SPI1CON_STXISEL_MASK;
9D0747B8  2404000C   ADDIU A0, ZERO, 12
9D0747BC  AC647004   SW A0, 28676(V1)
355:                                 SPI1CONSET = 0x00000004;
9D0747C0  24040004   ADDIU A0, ZERO, 4
9D0747C4  AC647008   SW A0, 28680(V1)
356:                 
357:                                 /* Enable the transmit interrupt. Callback will be given from the
358:                                  * transmit interrupt, when all bytes are shifted out. */
359:                                 IEC1SET = 0x20;
9D0747C8  24040020   ADDIU A0, ZERO, 32
9D0747CC  AE0400D8   SW A0, 216(S0)
9D0747D0  8C450018   LW A1, 24(V0)
9D0747D4  0B41D1CC   J 0x9D074730
9D0747D8  8C440008   LW A0, 8(V0)
360:                             }
361:                         }
362:                         if (spi1Obj.rxCount < spi1Obj.rxSize)
9D0746B8  1080002C   BEQ A0, ZERO, 0x9D07476C
9D0746BC  3C10BF81   LUI S0, -16511
363:                         {
364:                             /* More bytes pending to be received .. */
365:                             if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
9D0746C0  8C667000   LW A2, 28672(V1)
9D0746C4  3C078000   LUI A3, -32768
9D0746C8  8C450008   LW A1, 8(V0)
9D0746CC  30C60800   ANDI A2, A2, 2048
9D0746D0  8C430018   LW V1, 24(V0)
9D0746D4  10C00048   BEQ A2, ZERO, .LVL41
9D0746D8  3C04BF82   LUI A0, -16510
366:                             {
367:                                 if (spi1Obj.txCount < spi1Obj.txSize)
9D0746DC  0065282B   SLTU A1, V1, A1
9D0746E0  14A0005F   BNE A1, ZERO, 0x9D074860
9D0746E4  8CE6011C   LW A2, 284(A3)
368:                                 {
369:                                     SPI1BUF = ((uint32_t*)spi1Obj.txBuffer)[spi1Obj.txCount++];
9D074860  00032880   SLL A1, V1, 2
9D074864  24630001   ADDIU V1, V1, 1
9D074868  7CC5280A   LWX A1, A1(A2)
9D07486C  AC430018   SW V1, 24(V0)
9D074870  3C10BF81   LUI S0, -16511
9D074874  AC857020   SW A1, 28704(A0)
9D074878  0B41D1C3   J 0x9D07470C
9D07487C  24020010   ADDIU V0, ZERO, 16
370:                                 }
371:                                 else if (spi1Obj.dummySize > 0)
372:                                 {
373:                                     SPI1BUF = (uint32_t)(0xff);
374:                                     spi1Obj.dummySize--;
375:                                 }
376:                             }
377:                             else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
9D0747F8  8C867000   LW A2, 28672(A0)
9D0747FC  30C60400   ANDI A2, A2, 1024
9D074800  10C0000D   BEQ A2, ZERO, 0x9D074838
9D074804  0065282B   SLTU A1, V1, A1
378:                             {
379:                                 if (spi1Obj.txCount < spi1Obj.txSize)
9D074808  50A0FFB8   BEQL A1, ZERO, 0x9D0746EC
9D07480C  8C430010   LW V1, 16(V0)
380:                                 {
381:                                     SPI1BUF = ((uint16_t*)spi1Obj.txBuffer)[spi1Obj.txCount++];
9D074810  8CE6011C   LW A2, 284(A3)
9D074814  00032840   SLL A1, V1, 1
9D074818  24630001   ADDIU V1, V1, 1
9D07481C  00C52821   ADDU A1, A2, A1
9D074820  94A50000   LHU A1, 0(A1)
9D074824  AC430018   SW V1, 24(V0)
9D074828  3C10BF81   LUI S0, -16511
9D07482C  AC857020   SW A1, 28704(A0)
9D074830  0B41D1C3   J 0x9D07470C
9D074834  24020010   ADDIU V0, ZERO, 16
382:                                 }
383:                                 else if (spi1Obj.dummySize > 0)
384:                                 {
385:                                     SPI1BUF = (uint16_t)(0xff);
386:                                     spi1Obj.dummySize--;
387:                                 }
388:                             }
389:                             else
390:                             {
391:                                 if (spi1Obj.txCount < spi1Obj.txSize)
9D074838  50A0FFAC   BEQL A1, ZERO, 0x9D0746EC
9D07483C  8C430010   LW V1, 16(V0)
392:                                 {
393:                                     SPI1BUF = ((uint8_t*)spi1Obj.txBuffer)[spi1Obj.txCount++];
9D074840  8CE5011C   LW A1, 284(A3)
9D074844  24660001   ADDIU A2, V1, 1
9D074848  AC460018   SW A2, 24(V0)
9D07484C  7CA3198A   LBUX V1, V1(A1)
9D074850  3C10BF81   LUI S0, -16511
9D074854  AC837020   SW V1, 28704(A0)
9D074858  0B41D1C3   J 0x9D07470C
9D07485C  24020010   ADDIU V0, ZERO, 16
394:                                 }
395:                                 else if (spi1Obj.dummySize > 0)
9D0746E8  8C430010   LW V1, 16(V0)
9D0746EC  1060001F   BEQ V1, ZERO, 0x9D07476C
9D0746F0  3C10BF81   LUI S0, -16511
396:                                 {
397:                                     SPI1BUF = (uint8_t)(0xff);
9D0746F8  240500FF   ADDIU A1, ZERO, 255
9D0746FC  AC857020   SW A1, 28704(A0)
398:                                     spi1Obj.dummySize--;
9D0746F4  2463FFFF   ADDIU V1, V1, -1
9D074700  AC430010   SW V1, 16(V0)
9D074704  3C10BF81   LUI S0, -16511
399:                                 }
400:                             }
401:                         }
402:                         else
403:                         {
404:                             if((spi1Obj.rxCount == spi1Obj.rxSize) && (spi1Obj.txCount == spi1Obj.txSize))
9D074720  1485FFF9   BNE A0, A1, 0x9D074708
9D074724  3C10BF81   LUI S0, -16511
9D074728  8C450018   LW A1, 24(V0)
9D07472C  8C440008   LW A0, 8(V0)
9D074730  54A4FFF6   BNEL A1, A0, 0x9D07470C
9D074734  24020010   ADDIU V0, ZERO, 16
405:                             {
406:                                 /* Clear receiver overflow error if any */
407:                                 SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
9D07473C  24040040   ADDIU A0, ZERO, 64
9D074740  AC647014   SW A0, 28692(V1)
408:                 
409:                                 /* Disable receive interrupt */
410:                                 IEC1CLR = 0x10;
9D074748  24030010   ADDIU V1, ZERO, 16
9D07474C  AE0300D4   SW V1, 212(S0)
411:                 
412:                                 /* Transfer complete. Give a callback */
413:                                 spi1Obj.transferIsBusy = false;
9D074744  A040001C   SB ZERO, 28(V0)
414:                 
415:                                 if(spi1Obj.callback != NULL)
9D074738  8C450020   LW A1, 32(V0)
9D074750  50A0FFEE   BEQL A1, ZERO, 0x9D07470C
9D074754  24020010   ADDIU V0, ZERO, 16
416:                                 {
417:                                     spi1Obj.callback(spi1Obj.context);
9D074758  00A0F809   JALR A1
9D07475C  8C440024   LW A0, 36(V0)
418:                                 }
419:                             }
420:                         }
421:                     }
422:                 
423:                     /* Clear SPI1 RX Interrupt flag */
424:                     /* This flag should cleared only after reading buffer */
425:                     IFS1CLR = 0x10;
9D074708  24020010   ADDIU V0, ZERO, 16
9D07470C  AE020054   SW V0, 84(S0)
9D074760  0B41D1C3   J 0x9D07470C
9D074764  24020010   ADDIU V0, ZERO, 16
9D074768  3C10BF81   LUI S0, -16511
9D07476C  24020010   ADDIU V0, ZERO, 16
9D074770  AE020054   SW V0, 84(S0)
426:                 }
9D074710  8FBF0014   LW RA, 20(SP)
9D074714  8FB00010   LW S0, 16(SP)
9D074718  03E00008   JR RA
9D07471C  27BD0018   ADDIU SP, SP, 24
9D074774  8FBF0014   LW RA, 20(SP)
9D074778  8FB00010   LW S0, 16(SP)
9D07477C  03E00008   JR RA
9D074780  27BD0018   ADDIU SP, SP, 24
9D074784  00043080   SLL A2, A0, 2
9D074788  24840001   ADDIU A0, A0, 1
9D07478C  01063021   ADDU A2, T0, A2
9D074790  AC440014   SW A0, 20(V0)
9D074794  0B41D1AC   J 0x9D0746B0
9D074798  ACC70000   SW A3, 0(A2)
9D07479C  8C450018   LW A1, 24(V0)
9D0747A0  8C440008   LW A0, 8(V0)
9D0747A4  00A4302B   SLTU A2, A1, A0
9D0747A8  10C0FFE1   BEQ A2, ZERO, 0x9D074730
9D0747AC  3C10BF81   LUI S0, -16511
9D0747B0  24040010   ADDIU A0, ZERO, 16
9D0747B4  AE0400D4   SW A0, 212(S0)
9D0747B8  2404000C   ADDIU A0, ZERO, 12
9D0747BC  AC647004   SW A0, 28676(V1)
9D0747C0  24040004   ADDIU A0, ZERO, 4
9D0747C4  AC647008   SW A0, 28680(V1)
9D0747C8  24040020   ADDIU A0, ZERO, 32
9D0747CC  AE0400D8   SW A0, 216(S0)
9D0747D0  8C450018   LW A1, 24(V0)
9D0747D4  0B41D1CC   J 0x9D074730
9D0747D8  8C440008   LW A0, 8(V0)
9D0747DC  24860001   ADDIU A2, A0, 1
9D0747E0  AC460014   SW A2, 20(V0)
9D0747E4  00A42021   ADDU A0, A1, A0
9D0747E8  A0870000   SB A3, 0(A0)
9D0747EC  8C440014   LW A0, 20(V0)
9D0747F0  0B41D1AC   J 0x9D0746B0
9D0747F4  8C45000C   LW A1, 12(V0)
9D0747F8  8C867000   LW A2, 28672(A0)
9D0747FC  30C60400   ANDI A2, A2, 1024
9D074800  10C0000D   BEQ A2, ZERO, 0x9D074838
9D074804  0065282B   SLTU A1, V1, A1
9D074808  50A0FFB8   BEQL A1, ZERO, 0x9D0746EC
9D07480C  8C430010   LW V1, 16(V0)
9D074810  8CE6011C   LW A2, 284(A3)
9D074814  00032840   SLL A1, V1, 1
9D074818  24630001   ADDIU V1, V1, 1
9D07481C  00C52821   ADDU A1, A2, A1
9D074820  94A50000   LHU A1, 0(A1)
9D074824  AC430018   SW V1, 24(V0)
9D074828  3C10BF81   LUI S0, -16511
9D07482C  AC857020   SW A1, 28704(A0)
9D074830  0B41D1C3   J 0x9D07470C
9D074834  24020010   ADDIU V0, ZERO, 16
9D074838  50A0FFAC   BEQL A1, ZERO, 0x9D0746EC
9D07483C  8C430010   LW V1, 16(V0)
9D074840  8CE5011C   LW A1, 284(A3)
9D074844  24660001   ADDIU A2, V1, 1
9D074848  AC460018   SW A2, 24(V0)
9D07484C  7CA3198A   LBUX V1, V1(A1)
9D074850  3C10BF81   LUI S0, -16511
9D074854  AC837020   SW V1, 28704(A0)
9D074858  0B41D1C3   J 0x9D07470C
9D07485C  24020010   ADDIU V0, ZERO, 16
9D074860  00032880   SLL A1, V1, 2
9D074864  24630001   ADDIU V1, V1, 1
9D074868  7CC5280A   LWX A1, A1(A2)
9D07486C  AC430018   SW V1, 24(V0)
9D074870  3C10BF81   LUI S0, -16511
9D074874  AC857020   SW A1, 28704(A0)
9D074878  0B41D1C3   J 0x9D07470C
9D07487C  24020010   ADDIU V0, ZERO, 16
427:                 
428:                 void SPI1_TX_InterruptHandler (void)
429:                 {
9D077074  27BDFFE8   ADDIU SP, SP, -24
9D077078  AFBF0014   SW RA, 20(SP)
9D07707C  AFB00010   SW S0, 16(SP)
430:                     /* If there are more words to be transmitted, then transmit them here and keep track of the count */
431:                     if((SPI1STAT & _SPI1STAT_SPITBE_MASK) == _SPI1STAT_SPITBE_MASK)
9D077080  3C02BF82   LUI V0, -16510
9D077084  8C437010   LW V1, 28688(V0)
9D077088  30630008   ANDI V1, V1, 8
9D07708C  10600019   BEQ V1, ZERO, 0x9D0770F4
9D077090  3C068000   LUI A2, -32768
432:                     {
433:                         if (spi1Obj.txCount < spi1Obj.txSize)
9D077094  24C3011C   ADDIU V1, A2, 284
9D077098  8C640018   LW A0, 24(V1)
9D07709C  8C650008   LW A1, 8(V1)
9D0770A0  0085382B   SLTU A3, A0, A1
9D0770A4  10E0001A   BEQ A3, ZERO, 0x9D077110
9D0770A8  00000000   NOP
434:                         {
435:                             if((_SPI1CON_MODE32_MASK) == (SPI1CON & (_SPI1CON_MODE32_MASK)))
9D0770AC  8C477000   LW A3, 28672(V0)
9D0770B0  30E70800   ANDI A3, A3, 2048
9D0770B4  14E00027   BNE A3, ZERO, 0x9D077154
9D0770B8  8CC7011C   LW A3, 284(A2)
436:                             {
437:                                 SPI1BUF = ((uint32_t*)spi1Obj.txBuffer)[spi1Obj.txCount++];
9D077154  00043080   SLL A2, A0, 2
9D077158  24840001   ADDIU A0, A0, 1
9D07715C  7CE6300A   LWX A2, A2(A3)
9D077160  AC640018   SW A0, 24(V1)
9D077164  AC467020   SW A2, 28704(V0)
9D077168  0B41DC39   J 0x9D0770E4
9D07716C  00000000   NOP
438:                             }
439:                             else if((_SPI1CON_MODE16_MASK) == (SPI1CON & (_SPI1CON_MODE16_MASK)))
9D0770BC  8C477000   LW A3, 28672(V0)
9D0770C0  30E70400   ANDI A3, A3, 1024
9D0770C4  10E0002A   BEQ A3, ZERO, 0x9D077170
9D0770C8  8CC7011C   LW A3, 284(A2)
440:                             {
441:                                 SPI1BUF = ((uint16_t*)spi1Obj.txBuffer)[spi1Obj.txCount++];
9D0770CC  00043040   SLL A2, A0, 1
9D0770D0  24840001   ADDIU A0, A0, 1
9D0770D4  00E63021   ADDU A2, A3, A2
9D0770D8  94C60000   LHU A2, 0(A2)
9D0770DC  AC640018   SW A0, 24(V1)
9D0770E0  AC467020   SW A2, 28704(V0)
442:                             }
443:                             else
444:                             {
445:                                 SPI1BUF = ((uint8_t*)spi1Obj.txBuffer)[spi1Obj.txCount++];
9D077170  24860001   ADDIU A2, A0, 1
9D077174  AC660018   SW A2, 24(V1)
9D077178  7CE4198A   LBUX V1, A0(A3)
9D07717C  00C02021   ADDU A0, A2, ZERO
9D077180  AC437020   SW V1, 28704(V0)
9D077184  0B41DC39   J 0x9D0770E4
9D077188  00000000   NOP
446:                             }
447:                 
448:                             if (spi1Obj.txCount == spi1Obj.txSize)
9D0770E4  14A40004   BNE A1, A0, 0x9D0770F8
9D0770E8  3C10BF81   LUI S0, -16511
449:                             {
450:                                 /* All bytes are submitted to the SPI module. Now, enable transmit
451:                                  * interrupt when the shift register is empty (STXISEL = '00')*/
452:                                 SPI1CONCLR = _SPI1CON_STXISEL_MASK;
9D0770EC  2403000C   ADDIU V1, ZERO, 12
9D0770F0  AC437004   SW V1, 28676(V0)
9D0770F4  3C10BF81   LUI S0, -16511
453:                             }
454:                         }
455:                         else if ((spi1Obj.txCount == spi1Obj.txSize) && (SPI1STAT & _SPI1STAT_SRMT_MASK))
9D077110  1485FFF9   BNE A0, A1, 0x9D0770F8
9D077114  3C10BF81   LUI S0, -16511
9D077118  8C447010   LW A0, 28688(V0)
9D07711C  30840080   ANDI A0, A0, 128
9D077120  1080FFF5   BEQ A0, ZERO, 0x9D0770F8
9D077124  24040040   ADDIU A0, ZERO, 64
456:                         {
457:                             /* This part of code is executed when the shift register is empty. */
458:                 
459:                             /* Clear receiver overflow error if any */
460:                             SPI1STATCLR = _SPI1STAT_SPIROV_MASK;
9D07712C  AC447014   SW A0, 28692(V0)
461:                 
462:                             /* Disable transmit interrupt */
463:                             IEC1CLR = 0x20;
9D077134  24020020   ADDIU V0, ZERO, 32
9D077138  AE0200D4   SW V0, 212(S0)
464:                 
465:                             /* Transfer complete. Give a callback */
466:                             spi1Obj.transferIsBusy = false;
9D077130  A060001C   SB ZERO, 28(V1)
467:                 
468:                             if(spi1Obj.callback != NULL)
9D077128  8C650020   LW A1, 32(V1)
9D07713C  50A0FFEF   BEQL A1, ZERO, 0x9D0770FC
9D077140  24020020   ADDIU V0, ZERO, 32
469:                             {
470:                                 spi1Obj.callback(spi1Obj.context);
9D077144  00A0F809   JALR A1
9D077148  8C640024   LW A0, 36(V1)
471:                             }
472:                         }
473:                     }
474:                     /* Clear the transmit interrupt flag */
475:                     IFS1CLR = 0x20;
9D0770F8  24020020   ADDIU V0, ZERO, 32
9D0770FC  AE020054   SW V0, 84(S0)
9D07714C  0B41DC3F   J 0x9D0770FC
9D077150  24020020   ADDIU V0, ZERO, 32
476:                 }
9D077100  8FBF0014   LW RA, 20(SP)
9D077104  8FB00010   LW S0, 16(SP)
9D077108  03E00008   JR RA
9D07710C  27BD0018   ADDIU SP, SP, 24
9D077110  1485FFF9   BNE A0, A1, 0x9D0770F8
9D077114  3C10BF81   LUI S0, -16511
9D077118  8C447010   LW A0, 28688(V0)
9D07711C  30840080   ANDI A0, A0, 128
9D077120  1080FFF5   BEQ A0, ZERO, 0x9D0770F8
9D077124  24040040   ADDIU A0, ZERO, 64
9D077128  8C650020   LW A1, 32(V1)
9D07712C  AC447014   SW A0, 28692(V0)
9D077130  A060001C   SB ZERO, 28(V1)
9D077134  24020020   ADDIU V0, ZERO, 32
9D077138  AE0200D4   SW V0, 212(S0)
9D07713C  50A0FFEF   BEQL A1, ZERO, 0x9D0770FC
9D077140  24020020   ADDIU V0, ZERO, 32
9D077144  00A0F809   JALR A1
9D077148  8C640024   LW A0, 36(V1)
9D07714C  0B41DC3F   J 0x9D0770FC
9D077150  24020020   ADDIU V0, ZERO, 32
9D077154  00043080   SLL A2, A0, 2
9D077158  24840001   ADDIU A0, A0, 1
9D07715C  7CE6300A   LWX A2, A2(A3)
9D077160  AC640018   SW A0, 24(V1)
9D077164  AC467020   SW A2, 28704(V0)
9D077168  0B41DC39   J 0x9D0770E4
9D07716C  00000000   NOP
9D077170  24860001   ADDIU A2, A0, 1
9D077174  AC660018   SW A2, 24(V1)
9D077178  7CE4198A   LBUX V1, A0(A3)
9D07717C  00C02021   ADDU A0, A2, ZERO
9D077180  AC437020   SW V1, 28704(V0)
9D077184  0B41DC39   J 0x9D0770E4
9D077188  00000000   NOP
477:                 
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/gpio/plib_gpio.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_gpio.c
9:                   
10:                    Summary:
11:                      GPIO function implementations for the GPIO PLIB.
12:                  
13:                    Description:
14:                      The GPIO PLIB provides a simple interface to manage peripheral
15:                      input-output controller.
16:                  
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #include "plib_gpio.h"
45:                  
46:                  
47:                  
48:                  /******************************************************************************
49:                    Function:
50:                      GPIO_Initialize ( void )
51:                  
52:                    Summary:
53:                      Initialize the GPIO library.
54:                  
55:                    Remarks:
56:                      See plib_gpio.h for more details.
57:                  */
58:                  void GPIO_Initialize ( void )
59:                  {
60:                      /* PORTA Initialization */
61:                      LATA = 0x10; /* Initial Latch Value */
9D0772A4  3C03BF86   LUI V1, -16506
9D0772B0  24060010   ADDIU A2, ZERO, 16
9D0772B4  AC660030   SW A2, 48(V1)
62:                      TRISACLR = 0x410; /* Direction Control */
9D0772B8  24060410   ADDIU A2, ZERO, 1040
9D0772BC  AC660014   SW A2, 20(V1)
63:                      ANSELACLR = 0xc011; /* Digital Mode Enable */
9D0772C0  3406C011   ORI A2, ZERO, -16367
9D0772C4  AC660004   SW A2, 4(V1)
64:                  
65:                      /* PORTB Initialization */
66:                      ANSELBCLR = 0x80; /* Digital Mode Enable */
9D0772C8  24060080   ADDIU A2, ZERO, 128
9D0772CC  AC660104   SW A2, 260(V1)
67:                      CNPUBSET = 0x100; /* Pull-Up Enable */
9D0772D0  24060100   ADDIU A2, ZERO, 256
9D0772D4  AC660158   SW A2, 344(V1)
68:                  
69:                      /* PORTC Initialization */
70:                      LATC = 0x406; /* Initial Latch Value */
9D0772A8  24040406   ADDIU A0, ZERO, 1030
9D0772D8  AC640230   SW A0, 560(V1)
71:                      TRISCCLR = 0x406; /* Direction Control */
9D0772DC  AC640214   SW A0, 532(V1)
72:                      ANSELCCLR = 0x407; /* Digital Mode Enable */
9D0772E0  24060407   ADDIU A2, ZERO, 1031
9D0772E4  AC660204   SW A2, 516(V1)
73:                      CNPUCSET = 0x406; /* Pull-Up Enable */
9D0772E8  AC640258   SW A0, 600(V1)
74:                  
75:                      /* PORTD Initialization */
76:                  
77:                      /* PORTE Initialization */
78:                      LATE = 0xa002; /* Initial Latch Value */
9D0772AC  3405A002   ORI A1, ZERO, -24574
9D0772EC  AC650430   SW A1, 1072(V1)
79:                      TRISECLR = 0xa002; /* Direction Control */
9D0772F0  AC650414   SW A1, 1044(V1)
80:                      ANSELECLR = 0xe003; /* Digital Mode Enable */
9D0772F4  3404E003   ORI A0, ZERO, -8189
9D0772F8  AC640404   SW A0, 1028(V1)
81:                      CNPUESET = 0x8002; /* Pull-Up Enable */
9D0772FC  34048002   ORI A0, ZERO, -32766
9D077300  AC640458   SW A0, 1112(V1)
82:                  
83:                      /* PORTF Initialization */
84:                  
85:                      /* PORTG Initialization */
86:                      ANSELGCLR = 0x300; /* Digital Mode Enable */
9D077304  24040300   ADDIU A0, ZERO, 768
9D077308  AC640604   SW A0, 1540(V1)
87:                  
88:                  
89:                      /* Unlock system for PPS configuration */
90:                      SYSKEY = 0x00000000;
9D0772A0  3C02BF80   LUI V0, -16512
9D07730C  AC400030   SW ZERO, 48(V0)
91:                      SYSKEY = 0xAA996655;
9D077310  3C03AA99   LUI V1, -21863
9D077314  24636655   ADDIU V1, V1, 26197
9D077318  AC430030   SW V1, 48(V0)
92:                      SYSKEY = 0x556699AA;
9D07731C  3C035566   LUI V1, 21862
9D077320  346399AA   ORI V1, V1, -26198
9D077324  AC430030   SW V1, 48(V0)
93:                      CFGCONbits.IOLOCK = 0;
9D077328  8C450000   LW A1, 0(V0)
9D077334  7C056B44   INS A1, ZERO, 13, 1
9D077338  AC450000   SW A1, 0(V0)
94:                  
95:                      /* PPS Input Remapping */
96:                      SDI2R = 9;
9D07733C  24050009   ADDIU A1, ZERO, 9
9D077340  AC4514A4   SW A1, 5284(V0)
97:                      SDI1R = 6;
9D077344  24050006   ADDIU A1, ZERO, 6
9D077348  AC451498   SW A1, 5272(V0)
98:                      C1RXR = 8;
9D07734C  24050008   ADDIU A1, ZERO, 8
9D077350  AC4514C4   SW A1, 5316(V0)
99:                      U1RXR = 10;
9D077354  2405000A   ADDIU A1, ZERO, 10
9D077358  AC451464   SW A1, 5220(V0)
100:                     U2RXR = 13;
9D07735C  2405000D   ADDIU A1, ZERO, 13
9D077360  AC45146C   SW A1, 5228(V0)
101:                 
102:                     /* PPS Output Remapping */
103:                     RPB11R = 18;
9D077364  24050012   ADDIU A1, ZERO, 18
9D077368  AC45166C   SW A1, 5740(V0)
104:                     RPF0R = 4;
9D07732C  24030004   ADDIU V1, ZERO, 4
9D07736C  AC431740   SW V1, 5952(V0)
105:                     RPC7R = 4;
9D077370  AC43169C   SW V1, 5788(V0)
106:                     RPA0R = 3;
9D077374  24030003   ADDIU V1, ZERO, 3
9D077378  AC431600   SW V1, 5632(V0)
107:                     RPA15R = 12;
9D07737C  2403000C   ADDIU V1, ZERO, 12
9D077380  AC43163C   SW V1, 5692(V0)
108:                     RPE0R = 1;
9D077330  24040001   ADDIU A0, ZERO, 1
9D077384  AC441700   SW A0, 5888(V0)
109:                     RPG9R = 2;
9D077388  24030002   ADDIU V1, ZERO, 2
9D07738C  AC4317A4   SW V1, 6052(V0)
110:                 
111:                     /* Lock back the system after PPS configuration */
112:                     CFGCONbits.IOLOCK = 1;
9D077390  8C430000   LW V1, 0(V0)
9D077394  7C836B44   INS V1, A0, 13, 1
9D077398  AC430000   SW V1, 0(V0)
113:                     SYSKEY = 0x00000000;
9D07739C  AC400030   SW ZERO, 48(V0)
9D0773A0  03E00008   JR RA
9D0773A4  00000000   NOP
114:                 
115:                 }
116:                 
117:                 // *****************************************************************************
118:                 // *****************************************************************************
119:                 // Section: GPIO APIs which operates on multiple pins of a port
120:                 // *****************************************************************************
121:                 // *****************************************************************************
122:                 
123:                 // *****************************************************************************
124:                 /* Function:
125:                     uint32_t GPIO_PortRead ( GPIO_PORT port )
126:                 
127:                   Summary:
128:                     Read all the I/O lines of the selected port.
129:                 
130:                   Description:
131:                     This function reads the live data values on all the I/O lines of the
132:                     selected port.  Bit values returned in each position indicate corresponding
133:                     pin levels.
134:                     1 = Pin is high.
135:                     0 = Pin is low.
136:                 
137:                     This function reads the value regardless of pin configuration, whether it is
138:                     set as as an input, driven by the GPIO Controller, or driven by a peripheral.
139:                 
140:                   Remarks:
141:                     If the port has less than 32-bits, unimplemented pins will read as
142:                     low (0).
143:                     Implemented pins are Right aligned in the 32-bit return value.
144:                 */
145:                 uint32_t GPIO_PortRead(GPIO_PORT port)
146:                 {
147:                     return (*(volatile uint32_t *)(&PORTA + (port * 0x40)));
00000000  00000000   NOP
148:                 }
0000000C  00000000   NOP
149:                 
150:                 // *****************************************************************************
151:                 /* Function:
152:                     void GPIO_PortWrite (GPIO_PORT port, uint32_t mask, uint32_t value);
153:                 
154:                   Summary:
155:                     Write the value on the masked I/O lines of the selected port.
156:                 
157:                   Remarks:
158:                     See plib_gpio.h for more details.
159:                 */
160:                 void GPIO_PortWrite(GPIO_PORT port, uint32_t mask, uint32_t value)
161:                 {
162:                     *(volatile uint32_t *)(&LATA + (port * 0x40)) = (*(volatile uint32_t *)(&LATA + (port * 0x40)) & (~mask)) | (mask & value);
163:                 }
164:                 
165:                 // *****************************************************************************
166:                 /* Function:
167:                     uint32_t GPIO_PortLatchRead ( GPIO_PORT port )
168:                 
169:                   Summary:
170:                     Read the latched value on all the I/O lines of the selected port.
171:                 
172:                   Remarks:
173:                     See plib_gpio.h for more details.
174:                 */
175:                 uint32_t GPIO_PortLatchRead(GPIO_PORT port)
176:                 {
177:                     return (*(volatile uint32_t *)(&LATA + (port * 0x40)));
00000000  00000000   NOP
178:                 }
0000000C  00000000   NOP
179:                 
180:                 // *****************************************************************************
181:                 /* Function:
182:                     void GPIO_PortSet ( GPIO_PORT port, uint32_t mask )
183:                 
184:                   Summary:
185:                     Set the selected IO pins of a port.
186:                 
187:                   Remarks:
188:                     See plib_gpio.h for more details.
189:                 */
190:                 void GPIO_PortSet(GPIO_PORT port, uint32_t mask)
191:                 {
192:                     *(volatile uint32_t *)(&LATASET + (port * 0x40)) = mask;
193:                 }
194:                 
195:                 // *****************************************************************************
196:                 /* Function:
197:                     void GPIO_PortClear ( GPIO_PORT port, uint32_t mask )
198:                 
199:                   Summary:
200:                     Clear the selected IO pins of a port.
201:                 
202:                   Remarks:
203:                     See plib_gpio.h for more details.
204:                 */
205:                 void GPIO_PortClear(GPIO_PORT port, uint32_t mask)
206:                 {
207:                     *(volatile uint32_t *)(&LATACLR + (port * 0x40)) = mask;
208:                 }
209:                 
210:                 // *****************************************************************************
211:                 /* Function:
212:                     void GPIO_PortToggle ( GPIO_PORT port, uint32_t mask )
213:                 
214:                   Summary:
215:                     Toggles the selected IO pins of a port.
216:                 
217:                   Remarks:
218:                     See plib_gpio.h for more details.
219:                 */
220:                 void GPIO_PortToggle(GPIO_PORT port, uint32_t mask)
221:                 {
222:                     *(volatile uint32_t *)(&LATAINV + (port * 0x40))= mask;
223:                 }
224:                 
225:                 // *****************************************************************************
226:                 /* Function:
227:                     void GPIO_PortInputEnable ( GPIO_PORT port, uint32_t mask )
228:                 
229:                   Summary:
230:                     Enables selected IO pins of a port as input.
231:                 
232:                   Remarks:
233:                     See plib_gpio.h for more details.
234:                 */
235:                 void GPIO_PortInputEnable(GPIO_PORT port, uint32_t mask)
236:                 {
237:                     *(volatile uint32_t *)(&TRISASET + (port * 0x40)) = mask;
238:                 }
239:                 
240:                 // *****************************************************************************
241:                 /* Function:
242:                     void GPIO_PortOutputEnable ( GPIO_PORT port, uint32_t mask )
243:                 
244:                   Summary:
245:                     Enables selected IO pins of a port as output(s).
246:                 
247:                   Remarks:
248:                     See plib_gpio.h for more details.
249:                 */
250:                 void GPIO_PortOutputEnable(GPIO_PORT port, uint32_t mask)
251:                 {
252:                     *(volatile uint32_t *)(&TRISACLR + (port * 0x40)) = mask;
00000000  00000000   NOP
253:                 }
254:                 
255:                 
256:                 
257:                 
258:                 /*******************************************************************************
259:                  End of File
260:                 */
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/evic/plib_evic.c
1:                   /*******************************************************************************
2:                     EVIC PLIB Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_evic.c
9:                   
10:                    Summary:
11:                      EVIC PLIB Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
21:                  *
22:                  * Subject to your compliance with these terms, you may use Microchip software
23:                  * and any derivatives exclusively with Microchip products. It is your
24:                  * responsibility to comply with third party license terms applicable to your
25:                  * use of third party software (including open source software) that may
26:                  * accompany Microchip software.
27:                  *
28:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                  * PARTICULAR PURPOSE.
32:                  *
33:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "device.h"
44:                  #include "plib_evic.h"
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: IRQ Implementation
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  void EVIC_Initialize( void )
54:                  {
55:                      INTCONSET = _INTCON_MVEC_MASK;
9D078A78  3C02BF81   LUI V0, -16511
9D078A8C  24071000   ADDIU A3, ZERO, 4096
9D078A90  AC470008   SW A3, 8(V0)
56:                  
57:                      /* Set up priority and subpriority of enabled interrupts */
58:                      IPC0SET = 0x4 | 0x0;  /* CORE_TIMER:  Priority 1 / Subpriority 0 */
9D078A7C  24030004   ADDIU V1, ZERO, 4
9D078A94  AC430148   SW V1, 328(V0)
59:                      IPC9SET = 0x4 | 0x0;  /* SPI1_RX:  Priority 1 / Subpriority 0 */
9D078A98  AC4301D8   SW V1, 472(V0)
60:                      IPC9SET = 0x400 | 0x0;  /* SPI1_TX:  Priority 1 / Subpriority 0 */
9D078A80  24060400   ADDIU A2, ZERO, 1024
9D078A9C  AC4601D8   SW A2, 472(V0)
61:                      IPC9SET = 0x40000 | 0x0;  /* UART1_FAULT:  Priority 1 / Subpriority 0 */
9D078A84  3C050004   LUI A1, 4
9D078AA0  AC4501D8   SW A1, 472(V0)
62:                      IPC9SET = 0x4000000 | 0x0;  /* UART1_RX:  Priority 1 / Subpriority 0 */
9D078A88  3C040400   LUI A0, 1024
9D078AA4  AC4401D8   SW A0, 472(V0)
63:                      IPC10SET = 0x4 | 0x0;  /* UART1_TX:  Priority 1 / Subpriority 0 */
9D078AA8  AC4301E8   SW V1, 488(V0)
64:                      IPC14SET = 0x4 | 0x0;  /* UART2_FAULT:  Priority 1 / Subpriority 0 */
9D078AAC  AC430228   SW V1, 552(V0)
65:                      IPC14SET = 0x400 | 0x0;  /* UART2_RX:  Priority 1 / Subpriority 0 */
9D078AB0  AC460228   SW A2, 552(V0)
66:                      IPC14SET = 0x40000 | 0x0;  /* UART2_TX:  Priority 1 / Subpriority 0 */
9D078AB4  AC450228   SW A1, 552(V0)
67:                      IPC41SET = 0x4000000 | 0x0;  /* CAN1:  Priority 1 / Subpriority 0 */
9D078AB8  AC4403D8   SW A0, 984(V0)
68:                  
69:                  
70:                  
71:                      /* Configure Shadow Register Set */
72:                      PRISS = 0x76543210;
9D078ABC  3C037654   LUI V1, 30292
9D078AC0  24633210   ADDIU V1, V1, 12816
9D078AC4  AC430010   SW V1, 16(V0)
9D078AC8  03E00008   JR RA
9D078ACC  00000000   NOP
73:                  }
74:                  
75:                  void EVIC_SourceEnable( INT_SOURCE source )
76:                  {
77:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
00000000  00000000   NOP
78:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
79:                  
80:                      *IECxSET = 1 << (source & 0x1f);
00000014  00000000   NOP
81:                  }
82:                  
83:                  void EVIC_SourceDisable( INT_SOURCE source )
84:                  {
85:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
00000000  00000000   NOP
86:                      volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
87:                  
88:                      *IECxCLR = 1 << (source & 0x1f);
00000014  00000000   NOP
89:                  }
90:                  
91:                  bool EVIC_SourceIsEnabled( INT_SOURCE source )
92:                  {
93:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
00000000  00000000   NOP
94:                  
95:                      return (bool)((*IECx >> (source & 0x1f)) & 0x01);
00000010  00000000   NOP
96:                  }
00000018  00000000   NOP
97:                  
98:                  bool EVIC_SourceStatusGet( INT_SOURCE source )
99:                  {
100:                     volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
00000000  00000000   NOP
101:                 
102:                     return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
00000010  00000000   NOP
103:                 }
00000018  00000000   NOP
104:                 
105:                 void EVIC_SourceStatusSet( INT_SOURCE source )
106:                 {
107:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
00000000  00000000   NOP
108:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
109:                 
110:                     *IFSxSET = 1 << (source & 0x1f);
00000014  00000000   NOP
111:                 }
112:                 
113:                 void EVIC_SourceStatusClear( INT_SOURCE source )
114:                 {
115:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
00000000  00000000   NOP
116:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
117:                 
118:                     *IFSxCLR = 1 << (source & 0x1f);
00000014  00000000   NOP
119:                 }
120:                 
121:                 
122:                 /* End of file */
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/coretimer/plib_coretimer.c
1:                   /*******************************************************************************
2:                     Core Timer Peripheral Library
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_coretimer.c
9:                   
10:                    Summary:
11:                      Core timer Source File
12:                  
13:                    Description:
14:                      None
15:                  
16:                  *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  
41:                  #include "device.h"
42:                  #include "peripheral/coretimer/plib_coretimer.h"
43:                  
44:                  CORETIMER_OBJECT coreTmr;
45:                  void CORETIMER_Initialize()
46:                  {
9D078C60  27BDFFF8   ADDIU SP, SP, -8
9D078C64  AFBF0004   SW RA, 4(SP)
47:                      // Disable Timer by setting Disable Count (DC) bit
48:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
9D078C68  40026800   MFC0 V0, Cause
9D078C6C  3C030800   LUI V1, 2048
9D078C70  00431025   OR V0, V0, V1
9D078C74  40826800   MTC0 V0, Cause
9D078C78  000000C0   EHB
49:                      coreTmr.period=CORE_TIMER_INTERRUPT_PERIOD_VALUE;
9D078C7C  3C028000   LUI V0, -32768
9D078C80  2443010C   ADDIU V1, V0, 268
9D078C84  3404EA60   ORI A0, ZERO, -5536
9D078C88  AC64000C   SW A0, 12(V1)
50:                      coreTmr.tickCounter = 0;
9D078C8C  AC600008   SW ZERO, 8(V1)
51:                      coreTmr.callback = NULL;
9D078C90  AC40010C   SW ZERO, 268(V0)
52:                  }
9D078C94  8FBF0004   LW RA, 4(SP)
9D078C98  03E00008   JR RA
9D078C9C  27BD0008   ADDIU SP, SP, 8
53:                  void CORETIMER_CallbackSet ( CORETIMER_CALLBACK callback, uintptr_t context )
54:                  {
55:                      coreTmr.callback = callback;
00000000  00000000   NOP
00000008  00000000   NOP
56:                      coreTmr.context = context;
00000004  00000000   NOP
0000000C  00000000   NOP
57:                  }
58:                  void CORETIMER_PeriodSet ( uint32_t period )
59:                  {
60:                      coreTmr.period=period;
00000000  00000000   NOP
61:                  }
62:                  void CORETIMER_Start()
63:                  {
9D0786F0  27BDFFF8   ADDIU SP, SP, -8
9D0786F4  AFBF0004   SW RA, 4(SP)
64:                      // Disable Timer by setting Disable Count (DC) bit
65:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
9D0786F8  40026800   MFC0 V0, Cause
9D0786FC  3C030800   LUI V1, 2048
9D078700  00431025   OR V0, V0, V1
9D078704  40826800   MTC0 V0, Cause
9D078708  000000C0   EHB
66:                      // Disable Interrupt
67:                      IEC0CLR=0x1;
9D07870C  24030001   ADDIU V1, ZERO, 1
9D078710  3C02BF81   LUI V0, -16511
9D078714  AC4300C4   SW V1, 196(V0)
68:                      // Clear Core Timer
69:                      _CP0_SET_COUNT(0);
9D078718  00001021   ADDU V0, ZERO, ZERO
9D07871C  40824800   MTC0 V0, Count
9D078720  000000C0   EHB
70:                      _CP0_SET_COMPARE(coreTmr.period);
9D078724  3C028000   LUI V0, -32768
9D078728  8C420118   LW V0, 280(V0)
9D07872C  40825800   MTC0 V0, Compare
9D078730  000000C0   EHB
71:                      // Enable Timer by clearing Disable Count (DC) bit
72:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() & (~_CP0_CAUSE_DC_MASK));
9D078734  40026800   MFC0 V0, Cause
9D078738  7C02DEC4   INS V0, ZERO, 27, 1
9D07873C  40826800   MTC0 V0, Cause
9D078740  000000C0   EHB
73:                      // Enable Interrupt
74:                      IEC0SET=0x1;
9D078744  3C02BF81   LUI V0, -16511
9D078748  AC4300C8   SW V1, 200(V0)
75:                  }
9D07874C  8FBF0004   LW RA, 4(SP)
9D078750  03E00008   JR RA
9D078754  27BD0008   ADDIU SP, SP, 8
76:                  void CORETIMER_Stop()
77:                  {
00000000  00000000   NOP
78:                      // Disable Timer by setting Disable Count (DC) bit
79:                      _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);
00000008  00000000   NOP
80:                      // Disable Interrupt
81:                      IEC0CLR=0x1;
0000001C  00000000   NOP
82:                  }
00000028  00000000   NOP
83:                  uint32_t CORETIMER_FrequencyGet ( void )
84:                  {
85:                      return (CORE_TIMER_FREQUENCY);
00000000  00000000   NOP
86:                  }
00000004  00000000   NOP
87:                  void CORETIMER_DelayMs ( uint32_t delay)
88:                  {
89:                      uint32_t tickStart, delayTicks;
90:                      tickStart=coreTmr.tickCounter;
9D078BF0  3C038000   LUI V1, -32768
9D078BF4  2463010C   ADDIU V1, V1, 268
9D078BF8  8C650008   LW A1, 8(V1)
91:                      delayTicks=(1000 * delay)/CORE_TIMER_INTERRUPT_PERIOD_IN_US;  // Number of tick interrupts to wait for the delay
9D078BCC  00041080   SLL V0, A0, 2
9D078BD0  000419C0   SLL V1, A0, 7
9D078BD4  00621023   SUBU V0, V1, V0
9D078BD8  00442021   ADDU A0, V0, A0
9D078BDC  000420C0   SLL A0, A0, 3
9D078BE0  3C021062   LUI V0, 4194
9D078BE4  24424DD3   ADDIU V0, V0, 19923
9D078BE8  00820019   MULTU 0, A0, V0
9D078BEC  00002010   MFHI A0
9D078BFC  00042182   SRL A0, A0, 6
92:                      while((coreTmr.tickCounter-tickStart)<delayTicks)
9D078C00  8C620008   LW V0, 8(V1)
9D078C04  00451023   SUBU V0, V0, A1
9D078C08  0044102B   SLTU V0, V0, A0
9D078C0C  1440FFFC   BNE V0, ZERO, 0x9D078C00
9D078C10  00000000   NOP
93:                      {
94:                      }
95:                  }
9D078C14  03E00008   JR RA
9D078C18  00000000   NOP
96:                  void CORE_TIMER_InterruptHandler (void)
97:                  {
9D077E88  27BDFFF8   ADDIU SP, SP, -8
9D077E8C  AFBF0004   SW RA, 4(SP)
98:                      uint32_t count, newCompare;
99:                      uint32_t status = IFS0bits.CTIF;
9D077E90  3C02BF81   LUI V0, -16511
9D077E94  8C440040   LW A0, 64(V0)
9D077EA0  30840001   ANDI A0, A0, 1
100:                     IFS0CLR = 0x1;
9D077E98  24030001   ADDIU V1, ZERO, 1
9D077E9C  AC430044   SW V1, 68(V0)
101:                     // Start Critical Section
102:                     __builtin_disable_interrupts();
9D077EA4  41626000   DI V0
9D077EA8  000000C0   EHB
103:                     count=_CP0_GET_COUNT();
9D077EAC  40054800   MFC0 A1, Count
104:                     newCompare=_CP0_GET_COMPARE() + coreTmr.period;
9D077EB0  40065800   MFC0 A2, Compare
9D077EB4  3C038000   LUI V1, -32768
9D077EB8  2462010C   ADDIU V0, V1, 268
9D077EBC  8C47000C   LW A3, 12(V0)
9D077EC0  00C73021   ADDU A2, A2, A3
105:                     if (count<newCompare-50)
9D077EC4  24C7FFCE   ADDIU A3, A2, -50
9D077EC8  00A7382B   SLTU A3, A1, A3
9D077ECC  10E0000E   BEQ A3, ZERO, .LVL10
9D077ED0  24A50032   ADDIU A1, A1, 50
106:                         _CP0_SET_COMPARE(newCompare);
9D077ED4  40865800   MTC0 A2, Compare
9D077ED8  000000C0   EHB
107:                     else
108:                         _CP0_SET_COMPARE(count+50);
9D077F08  40855800   MTC0 A1, Compare
9D077F0C  000000C0   EHB
109:                     // End Critical Section
110:                     __builtin_enable_interrupts();
9D077EDC  41656020   EI A1
9D077F10  41656020   EI A1
111:                     coreTmr.tickCounter++;
9D077EE0  8C450008   LW A1, 8(V0)
9D077EE8  24A30001   ADDIU V1, A1, 1
9D077EEC  AC430008   SW V1, 8(V0)
9D077F14  8C450008   LW A1, 8(V0)
9D077F1C  24A30001   ADDIU V1, A1, 1
9D077F20  AC430008   SW V1, 8(V0)
112:                     if(coreTmr.callback != NULL)
9D077EE4  8C79010C   LW T9, 268(V1)
9D077EF0  1320000F   BEQ T9, ZERO, 0x9D077F30
9D077EF4  8FBF0004   LW RA, 4(SP)
9D077F18  8C79010C   LW T9, 268(V1)
9D077F24  5720FFF5   BNEL T9, ZERO, 0x9D077EFC
9D077F28  8C450004   LW A1, 4(V0)
113:                     {
114:                         coreTmr.callback(status, coreTmr.context);
9D077EF8  8C450004   LW A1, 4(V0)
9D077F00  03200008   JR T9
9D077F04  27BD0008   ADDIU SP, SP, 8
115:                     }
116:                 }
9D077EFC  8FBF0004   LW RA, 4(SP)
9D077F2C  8FBF0004   LW RA, 4(SP)
9D077F30  03E00008   JR RA
9D077F34  27BD0008   ADDIU SP, SP, 8
117:                 
118:                 
119:                 
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/clk/plib_clk.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_clk.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the
15:                      oscillators on Microchip microcontrollers. This file defines the static
16:                      implementation for the Clock System Service.
17:                  
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.
21:                      It provides static version of the routines, eliminating the need for an
22:                      object ID or object handle.
23:                  
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  
26:                  *******************************************************************************/
27:                  
28:                  /*******************************************************************************
29:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
30:                  *
31:                  * Subject to your compliance with these terms, you may use Microchip software
32:                  * and any derivatives exclusively with Microchip products. It is your
33:                  * responsibility to comply with third party license terms applicable to your
34:                  * use of third party software (including open source software) that may
35:                  * accompany Microchip software.
36:                  *
37:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
38:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
39:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
40:                  * PARTICULAR PURPOSE.
41:                  *
42:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
43:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
44:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
45:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
46:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
47:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
48:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
49:                  *******************************************************************************/
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Include Files
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  #include "device.h"
58:                  #include "plib_clk.h"
59:                  
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  // Section: File Scope Functions
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  
66:                  // *****************************************************************************
67:                  /* Function:
68:                      void CLK_Initialize( void )
69:                  
70:                    Summary:
71:                      Initializes hardware and internal data structure of the System Clock.
72:                  
73:                    Description:
74:                      This function initializes the hardware and internal data structure of System
75:                      Clock Service.
76:                  
77:                    Remarks:
78:                      This is configuration values for the static version of the Clock System
79:                      Service module is determined by the user via the MHC GUI.
80:                  
81:                      The objective is to eliminate the user's need to be knowledgeable in the
82:                      function of the 'configuration bits' to configure the system oscillators.
83:                  */
84:                  
85:                  void CLK_Initialize( void )
86:                  {
87:                      /* unlock system for clock configuration */
88:                      SYSKEY = 0x00000000;
9D077FE4  3C02BF80   LUI V0, -16512
9D077FEC  AC400030   SW ZERO, 48(V0)
89:                      SYSKEY = 0xAA996655;
9D077FF0  3C05AA99   LUI A1, -21863
9D077FF4  24A56655   ADDIU A1, A1, 26197
9D077FF8  AC450030   SW A1, 48(V0)
90:                      SYSKEY = 0x556699AA;
9D077FFC  3C055566   LUI A1, 21862
9D078000  34A599AA   ORI A1, A1, -26198
9D078004  AC450030   SW A1, 48(V0)
91:                  
92:                      /* Set up Reference Clock 3 */
93:                      /* REFO3CON register */
94:                      /* ROSEL =  SYSCLK */
95:                      /* DIVSWEN = 1 */
96:                      /* RODIV = 15 */
97:                      REFO3CON = 0xf0200;
9D078008  3C05000F   LUI A1, 15
9D07800C  24A50200   ADDIU A1, A1, 512
9D078010  AC4512C0   SW A1, 4800(V0)
98:                  
99:                      /* REFO3TRIM register */
100:                     /* ROTRIM = 0 */
101:                     REFO3TRIM = 0x0;
9D078014  AC4012D0   SW ZERO, 4816(V0)
102:                 
103:                     /* Enable oscillator (ON bit) and Enable Output (OE bit) */
104:                     REFO3CONSET = 0x00001000 | 0x00008000;
9D077FE0  34039000   ORI V1, ZERO, -28672
9D078018  AC4312C8   SW V1, 4808(V0)
105:                 
106:                     /* Set up Reference Clock 4 */
107:                     /* REFO4CON register */
108:                     /* ROSEL =  SYSCLK */
109:                     /* DIVSWEN = 1 */
110:                     /* RODIV = 1 */
111:                     REFO4CON = 0x10200;
9D077FE8  24647200   ADDIU A0, V1, 29184
9D07801C  AC4412E0   SW A0, 4832(V0)
112:                 
113:                     /* REFO4TRIM register */
114:                     /* ROTRIM = 256 */
115:                     REFO4TRIM = 0x80000000;
9D078020  3C048000   LUI A0, -32768
9D078024  AC4412F0   SW A0, 4848(V0)
116:                 
117:                     /* Enable oscillator (ON bit) and Enable Output (OE bit) */
118:                     REFO4CONSET = 0x00001000 | 0x00008000;
9D078028  AC4312E8   SW V1, 4840(V0)
119:                 
120:                   
121:                 
122:                     /* Peripheral Module Disable Configuration */
123:                     PMD1 = 0xfffffffe;
9D07802C  2403FFFE   ADDIU V1, ZERO, -2
9D078030  AC430040   SW V1, 64(V0)
124:                     PMD2 = 0x17001f;
9D078034  3C030017   LUI V1, 23
9D078038  2463001F   ADDIU V1, V1, 31
9D07803C  AC430050   SW V1, 80(V0)
125:                     PMD3 = 0xffffffff;
9D078040  2403FFFF   ADDIU V1, ZERO, -1
9D078044  AC430060   SW V1, 96(V0)
126:                     PMD4 = 0xfff01ff;
9D078048  3C030FFF   LUI V1, 4095
9D07804C  246301FF   ADDIU V1, V1, 511
9D078050  AC430070   SW V1, 112(V0)
127:                     PMD5 = 0xeffffcfc;
9D078054  3C03EFFF   LUI V1, -4097
9D078058  3463FCFC   ORI V1, V1, -772
9D07805C  AC430080   SW V1, 128(V0)
128:                     PMD6 = 0xfffff0ff;
9D078060  2403F0FF   ADDIU V1, ZERO, -3841
9D078064  AC430090   SW V1, 144(V0)
129:                     PMD7 = 0xffffffef;
9D078068  2403FFEF   ADDIU V1, ZERO, -17
9D07806C  AC4300A0   SW V1, 160(V0)
130:                 
131:                     /* Lock system since done with clock configuration */
132:                     SYSKEY = 0x33333333;
9D078070  3C033333   LUI V1, 13107
9D078074  24633333   ADDIU V1, V1, 13107
9D078078  AC430030   SW V1, 48(V0)
9D07807C  03E00008   JR RA
9D078080  00000000   NOP
133:                 }
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/peripheral/can/plib_can1.c
1:                   /*******************************************************************************
2:                     Controller Area Network (CAN) Peripheral Library Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       plib_can1.c
9:                   
10:                    Summary:
11:                      CAN peripheral library interface.
12:                  
13:                    Description:
14:                      This file defines the interface to the CAN peripheral library. This
15:                      library provides access to and control of the associated peripheral
16:                      instance.
17:                  
18:                    Remarks:
19:                      None.
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  * Copyright (C) 2019 Microchip Technology Inc. and its subsidiaries.
25:                  *
26:                  * Subject to your compliance with these terms, you may use Microchip software
27:                  * and any derivatives exclusively with Microchip products. It is your
28:                  * responsibility to comply with third party license terms applicable to your
29:                  * use of third party software (including open source software) that may
30:                  * accompany Microchip software.
31:                  *
32:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
33:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
34:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
35:                  * PARTICULAR PURPOSE.
36:                  *
37:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
38:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
39:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
40:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
41:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
42:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
43:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
44:                  *******************************************************************************/
45:                  //DOM-IGNORE-END
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Header Includes
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  #include <sys/kmem.h>
52:                  #include "plib_can1.h"
53:                  
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Global Data
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  /* CAN1 Message memory size */
61:                  #define CAN_MESSAGE_RAM_CONFIG_SIZE 224
62:                  /* Number of configured FIFO */
63:                  #define CAN_NUM_OF_FIFO             2
64:                  /* Maximum number of CAN Message buffers in each FIFO */
65:                  #define CAN_FIFO_MESSAGE_BUFFER_MAX 32
66:                  
67:                  #define CAN_CONFIGURATION_MODE      0x4
68:                  #define CAN_OPERATION_MODE          0x0
69:                  #define CAN_NUM_OF_FILTER           1
70:                  /* FIFO Offset in word (4 bytes) */
71:                  #define CAN_FIFO_OFFSET             0xc
72:                  /* Filter Offset in word (4 bytes) */
73:                  #define CAN_FILTER_OFFSET           0x4
74:                  #define CAN_FILTER_OBJ_OFFSET       0x8
75:                  /* Acceptance Mask Offset in word (4 bytes) */
76:                  #define CAN_ACCEPTANCE_MASK_OFFSET  0x8
77:                  #define CAN_MSG_SID_MASK            0x7FF
78:                  #define CAN_MSG_EID_MASK            0x1FFFFFFF
79:                  #define CAN_MSG_DLC_MASK            0x0000000F
80:                  #define CAN_MSG_IDE_MASK            0x00000010
81:                  #define CAN_MSG_RTR_MASK            0x00000020
82:                  #define CAN_MSG_BRS_MASK            0x00000040
83:                  #define CAN_MSG_FDF_MASK            0x00000080
84:                  #define CAN_MSG_SEQ_MASK            0xFFFFFE00
85:                  #define CAN_MSG_TX_EXT_SID_MASK     0x1FFC0000
86:                  #define CAN_MSG_TX_EXT_EID_MASK     0x0003FFFF
87:                  #define CAN_MSG_RX_EXT_SID_MASK     0x000007FF
88:                  #define CAN_MSG_RX_EXT_EID_MASK     0x1FFFF800
89:                  #define CAN_MSG_FLT_EXT_SID_MASK    0x1FFC0000
90:                  #define CAN_MSG_FLT_EXT_EID_MASK    0x0003FFFF
91:                  
92:                  static CAN_OBJ can1Obj;
93:                  static CAN_RX_MSG can1RxMsg[CAN_NUM_OF_FIFO][CAN_FIFO_MESSAGE_BUFFER_MAX];
94:                  static CAN_CALLBACK_OBJ can1CallbackObj[CAN_NUM_OF_FIFO + 1];
95:                  static CAN_CALLBACK_OBJ can1ErrorCallbackObj;
96:                  static uint8_t __attribute__((coherent, aligned(16))) can_message_buffer[CAN_MESSAGE_RAM_CONFIG_SIZE];
97:                  static const uint8_t dlcToLength[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, 64};
98:                  
99:                  /******************************************************************************
100:                 Local Functions
101:                 ******************************************************************************/
102:                 static void CANLengthToDlcGet(uint8_t length, uint8_t *dlc)
103:                 {
104:                     if (length <= 8)
00000048  00000000   NOP
105:                     {
106:                         *dlc = length;
107:                     }
108:                     else if (length <= 12)
00000214  00000000   NOP
109:                     {
110:                         *dlc = 0x9;
111:                     }
112:                     else if (length <= 16)
0000021C  00000000   NOP
113:                     {
114:                         *dlc = 0xA;
115:                     }
116:                     else if (length <= 20)
00000228  00000000   NOP
117:                     {
118:                         *dlc = 0xB;
119:                     }
120:                     else if (length <= 24)
00000234  00000000   NOP
121:                     {
122:                         *dlc = 0xC;
123:                     }
124:                     else if (length <= 32)
00000240  00000000   NOP
125:                     {
126:                         *dlc = 0xD;
127:                     }
128:                     else if (length <= 48)
0000024C  00000000   NOP
129:                     {
130:                         *dlc = 0xE;
131:                     }
132:                     else
133:                     {
134:                         *dlc = 0xF;
135:                     }
136:                 }
137:                 
138:                 // *****************************************************************************
139:                 // *****************************************************************************
140:                 // CAN1 PLib Interface Routines
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 // *****************************************************************************
144:                 /* Function:
145:                     void CAN1_Initialize(void)
146:                 
147:                    Summary:
148:                     Initializes given instance of the CAN peripheral.
149:                 
150:                    Precondition:
151:                     None.
152:                 
153:                    Parameters:
154:                     None.
155:                 
156:                    Returns:
157:                     None
158:                 */
159:                 void CAN1_Initialize(void)
160:                 {
9D07718C  27BDFFE0   ADDIU SP, SP, -32
9D077190  AFBF001C   SW RA, 28(SP)
9D077194  AFB10018   SW S1, 24(SP)
9D077198  AFB00014   SW S0, 20(SP)
161:                     /* Switch the CAN module ON */
162:                     CFD1CON |= _CFD1CON_ON_MASK | _CFD1CON_CLKSEL0_MASK;
9D07719C  3C11BF88   LUI S1, -16504
9D0771A0  8E220000   LW V0, 0(S1)
9D0771A8  34428080   ORI V0, V0, -32640
9D0771AC  AE220000   SW V0, 0(S1)
163:                 
164:                     /* Switch the CAN module to Configuration mode. Wait until the switch is complete */
165:                     CFD1CON = (CFD1CON & ~_CFD1CON_REQOP_MASK) | ((CAN_CONFIGURATION_MODE << _CFD1CON_REQOP_POSITION) & _CFD1CON_REQOP_MASK);
9D0771B0  8E220000   LW V0, 0(S1)
9D0771B4  7C02D604   INS V0, ZERO, 24, 3
9D0771B8  3C040400   LUI A0, 1024
9D0771BC  00441025   OR V0, V0, A0
9D0771C0  AE220000   SW V0, 0(S1)
166:                     while(((CFD1CON & _CFD1CON_OPMOD_MASK) >> _CFD1CON_OPMOD_POSITION) != CAN_CONFIGURATION_MODE);
9D0771A4  24030004   ADDIU V1, ZERO, 4
9D0771C4  8E220000   LW V0, 0(S1)
9D0771C8  7C421540   EXT V0, V0, 21, 3
9D0771CC  1443FFFD   BNE V0, V1, 0x9D0771C4
9D0771D0  3C10BF88   LUI S0, -16504
167:                 
168:                     /* Set the Data bitrate to 500 Kbps */
169:                     CFD1DBTCFG = ((14 << _CFD1DBTCFG_BRP_POSITION) & _CFD1DBTCFG_BRP_MASK)
9D0771D4  3C020E01   LUI V0, 3585
9D0771D8  24420101   ADDIU V0, V0, 257
9D0771E8  AE020020   SW V0, 32(S0)
170:                                | ((1 << _CFD1DBTCFG_TSEG1_POSITION) & _CFD1DBTCFG_TSEG1_MASK)
171:                                | ((1 << _CFD1DBTCFG_TSEG2_POSITION) & _CFD1DBTCFG_TSEG2_MASK)
172:                                | ((1 << _CFD1DBTCFG_SJW_POSITION) & _CFD1DBTCFG_SJW_MASK);
173:                 
174:                     /* Set the Nominal bitrate to 500 Kbps */
175:                     CFD1NBTCFG = ((14 << _CFD1NBTCFG_BRP_POSITION) & _CFD1NBTCFG_BRP_MASK)
9D0771EC  AE020010   SW V0, 16(S0)
176:                                | ((1 << _CFD1NBTCFG_TSEG1_POSITION) & _CFD1NBTCFG_TSEG1_MASK)
177:                                | ((1 << _CFD1NBTCFG_TSEG2_POSITION) & _CFD1NBTCFG_TSEG2_MASK)
178:                                | ((1 << _CFD1NBTCFG_SJW_POSITION) & _CFD1NBTCFG_SJW_MASK);
179:                 
180:                     /* Set Message memory base address for all FIFOs/Queue */
181:                     CFD1FIFOBA = (uint32_t)KVA_TO_PA(can_message_buffer);
9D0771DC  3C03A000   LUI V1, -24576
9D0771E0  246311E0   ADDIU V1, V1, 4576
9D0771E4  7C63E000   EXT V1, V1, 0, 29
9D0771F0  AE030130   SW V1, 304(S0)
182:                 
183:                     /* Tx Event FIFO Configuration */
184:                     CFD1TEFCON = (((1 - 1) << _CFD1TEFCON_FSIZE_POSITION) & _CFD1TEFCON_FSIZE_MASK);
9D0771F4  AE000100   SW ZERO, 256(S0)
185:                     CFD1CON |= _CFD1CON_STEF_MASK;
9D0771F8  8E040000   LW A0, 0(S0)
9D077200  3C030008   LUI V1, 8
9D077204  00831825   OR V1, A0, V1
9D077208  AE030000   SW V1, 0(S0)
186:                 
187:                     /* Tx Queue Configuration */
188:                     CFD1TXQCON = (((1 - 1) << _CFD1TXQCON_FSIZE_POSITION) & _CFD1TXQCON_FSIZE_MASK)
9D0771FC  3C02E000   LUI V0, -8192
9D07720C  AE020140   SW V0, 320(S0)
189:                                | ((0x7 << _CFD1TXQCON_PLSIZE_POSITION) & _CFD1TXQCON_PLSIZE_MASK)
190:                                | ((0x0 << _CFD1TXQCON_TXPRI_POSITION) & _CFD1TXQCON_TXPRI_MASK);
191:                     CFD1CON |= _CFD1CON_TXQEN_MASK;
9D077210  8E050000   LW A1, 0(S0)
9D077218  3C040010   LUI A0, 16
9D07721C  00A42025   OR A0, A1, A0
9D077220  AE040000   SW A0, 0(S0)
192:                 
193:                 
194:                     /* Configure CAN FIFOs */
195:                     CFD1FIFOCON1 = (((1 - 1) << _CFD1FIFOCON1_FSIZE_POSITION) & _CFD1FIFOCON1_FSIZE_MASK) | _CFD1FIFOCON1_TXEN_MASK | ((0x0 << _CFD1FIFOCON1_TXPRI_POSITION) & _CFD1FIFOCON1_TXPRI_MASK) | ((0x0 << _CFD1FIFOCON1_RTREN_POSITION) & _CFD1FIFOCON1_RTREN_MASK) | ((0x7 << _CFD1FIFOCON1_PLSIZE_POSITION) & _CFD1FIFOCON1_PLSIZE_MASK);
9D077214  24430080   ADDIU V1, V0, 128
9D077224  AE030170   SW V1, 368(S0)
196:                     CFD1FIFOCON2 = (((1 - 1) << _CFD1FIFOCON2_FSIZE_POSITION) & _CFD1FIFOCON2_FSIZE_MASK) | ((0x7 << _CFD1FIFOCON2_PLSIZE_POSITION) & _CFD1FIFOCON2_PLSIZE_MASK);
9D077228  AE0201A0   SW V0, 416(S0)
197:                 
198:                     /* Configure CAN Filters */
199:                     /* Filter 0 configuration */
200:                     CFD1FLTOBJ0 = (0 & CAN_MSG_SID_MASK);
9D07722C  AE0007C0   SW ZERO, 1984(S0)
201:                     CFD1MASK0 = (0 & CAN_MSG_SID_MASK);
9D077230  AE0007D0   SW ZERO, 2000(S0)
202:                     CFD1FLTCON0 |= (((0x2 << _CFD1FLTCON0_F0BP_POSITION) & _CFD1FLTCON0_F0BP_MASK)| _CFD1FLTCON0_FLTEN0_MASK);
9D077234  8E020740   LW V0, 1856(S0)
9D077238  34420082   ORI V0, V0, 130
9D07723C  AE020740   SW V0, 1856(S0)
203:                 
204:                     /* Set Interrupts */
205:                     IEC5SET = _IEC5_CAN1IE_MASK;
9D077240  24030080   ADDIU V1, ZERO, 128
9D077244  3C02BF81   LUI V0, -16511
9D077248  AC430118   SW V1, 280(V0)
206:                     CFD1INT |= _CFD1INT_SERRIE_MASK | _CFD1INT_CERRIE_MASK | _CFD1INT_IVMIE_MASK;
9D07724C  8E030070   LW V1, 112(S0)
9D077250  3C02B000   LUI V0, -20480
9D077254  00621025   OR V0, V1, V0
9D077268  AE020070   SW V0, 112(S0)
207:                 
208:                     /* Initialize the CAN PLib Object */
209:                     memset((void *)can1RxMsg, 0x00, sizeof(can1RxMsg));
9D077258  3C048000   LUI A0, -32768
9D07725C  248412C0   ADDIU A0, A0, 4800
9D077260  00002821   ADDU A1, ZERO, ZERO
9D077264  24060500   ADDIU A2, ZERO, 1280
9D07726C  0F41DFCE   JAL .LFE11, memset
9D077270  00000000   NOP
210:                 
211:                     /* Switch the CAN module to CAN_OPERATION_MODE. Wait until the switch is complete */
212:                     CFD1CON = (CFD1CON & ~_CFD1CON_REQOP_MASK) | ((CAN_OPERATION_MODE << _CFD1CON_REQOP_POSITION) & _CFD1CON_REQOP_MASK);
9D077274  8E020000   LW V0, 0(S0)
9D077278  7C02D604   INS V0, ZERO, 24, 3
9D07727C  AE020000   SW V0, 0(S0)
213:                     while(((CFD1CON & _CFD1CON_OPMOD_MASK) >> _CFD1CON_OPMOD_POSITION) != CAN_OPERATION_MODE);
9D077280  8E220000   LW V0, 0(S1)
9D077284  7C421540   EXT V0, V0, 21, 3
9D077288  1440FFFD   BNE V0, ZERO, 0x9D077280
9D07728C  8FBF001C   LW RA, 28(SP)
214:                 }
9D077290  8FB10018   LW S1, 24(SP)
9D077294  8FB00014   LW S0, 20(SP)
9D077298  03E00008   JR RA
9D07729C  27BD0020   ADDIU SP, SP, 32
215:                 
216:                 // *****************************************************************************
217:                 /* Function:
218:                     bool CAN1_MessageTransmit(uint32_t id, uint8_t length, uint8_t* data, uint8_t fifoQueueNum, CAN_MODE mode, CAN_MSG_TX_ATTRIBUTE msgAttr)
219:                 
220:                    Summary:
221:                     Transmits a message into CAN bus.
222:                 
223:                    Precondition:
224:                     CAN1_Initialize must have been called for the associated CAN instance.
225:                 
226:                    Parameters:
227:                     id           - 11-bit / 29-bit identifier (ID).
228:                     length       - Length of data buffer in number of bytes.
229:                     data         - Pointer to source data buffer
230:                     fifoQueueNum - If fifoQueueNum is 0 then Transmit Queue otherwise FIFO
231:                     mode         - CAN mode Classic CAN or CAN FD without BRS or CAN FD with BRS
232:                     msgAttr      - Data frame or Remote frame to be transmitted
233:                 
234:                    Returns:
235:                     Request status.
236:                     true  - Request was successful.
237:                     false - Request has failed.
238:                 */
239:                 bool CAN1_MessageTransmit(uint32_t id, uint8_t length, uint8_t* data, uint8_t fifoQueueNum, CAN_MODE mode, CAN_MSG_TX_ATTRIBUTE msgAttr)
240:                 {
241:                     CAN_TX_MSG_OBJECT *txMessage = NULL;
242:                     static uint32_t sequence = 0;
243:                     uint8_t count = 0;
244:                     uint8_t dlc = 0;
245:                     bool status = false;
246:                 
247:                     if (fifoQueueNum == 0)
00000000  00000000   NOP
248:                     {
249:                         if ((CFD1TXQSTA & _CFD1TXQSTA_TXQNIF_MASK) == _CFD1TXQSTA_TXQNIF_MASK)
00000008  00000000   NOP
250:                         {
251:                             txMessage = (CAN_TX_MSG_OBJECT *)PA_TO_KVA1(CFD1TXQUA);
0000001C  00000000   NOP
252:                             status = true;
253:                         }
254:                     }
255:                     else if (fifoQueueNum <= CAN_NUM_OF_FIFO)
00000110  00000000   NOP
256:                     {
257:                         if ((*(volatile uint32_t *)(&CFD1FIFOSTA1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)) & _CFD1FIFOSTA1_TFNRFNIF_MASK) == _CFD1FIFOSTA1_TFNRFNIF_MASK)
0000011C  00000000   NOP
258:                         {
259:                             txMessage = (CAN_TX_MSG_OBJECT *)PA_TO_KVA1(*(volatile uint32_t *)(&CFD1FIFOUA1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)));
00000260  00000000   NOP
260:                             status = true;
261:                         }
262:                     }
263:                 
264:                     if (status)
265:                     {
266:                         /* Check the id whether it falls under SID or EID,
267:                          * SID max limit is 0x7FF, so anything beyond that is EID */
268:                         if (id > CAN_MSG_SID_MASK)
00000028  00000000   NOP
269:                         {
270:                             txMessage->t0 = (((id & CAN_MSG_TX_EXT_SID_MASK) >> 18) | ((id & CAN_MSG_TX_EXT_EID_MASK) << 11)) & CAN_MSG_EID_MASK;
0000014C  00000000   NOP
271:                             txMessage->t1 = CAN_MSG_IDE_MASK;
0000015C  00000000   NOP
272:                         }
273:                         else
274:                         {
275:                             txMessage->t0 = id;
00000034  00000000   NOP
276:                             txMessage->t1 = 0;
00000038  00000000   NOP
277:                         }
278:                         if (length > 64)
0000003C  00000000   NOP
00000164  00000000   NOP
279:                             length = 64;
280:                 
281:                         CANLengthToDlcGet(length, &dlc);
282:                 
283:                         txMessage->t1 |= (dlc & CAN_MSG_DLC_MASK);
00000058  00000000   NOP
00000174  00000000   NOP
284:                 
285:                         if(mode == CAN_MODE_FD_WITH_BRS)
0000005C  00000000   NOP
00000178  00000000   NOP
286:                         {
287:                             txMessage->t1 |= CAN_MSG_FDF_MASK | CAN_MSG_BRS_MASK;
00000184  00000000   NOP
288:                         }
289:                         else if (mode == CAN_MODE_FD_WITHOUT_BRS)
00000068  00000000   NOP
290:                         {
291:                             txMessage->t1 |= CAN_MSG_FDF_MASK;
00000074  00000000   NOP
292:                         }
293:                         if (msgAttr == CAN_MSG_TX_REMOTE_FRAME)
00000078  00000000   NOP
0000018C  00000000   NOP
294:                         {
295:                             txMessage->t1 |= CAN_MSG_RTR_MASK;
0000019C  00000000   NOP
296:                         }
297:                         else
298:                         {
299:                             while(count < length)
00000088  00000000   NOP
000000AC  00000000   NOP
300:                             {
301:                                 txMessage->data[count++] = *data++;
000000A0  00000000   NOP
302:                             }
303:                         }
304:                 
305:                         txMessage->t1 |= ((++sequence << 9) & CAN_MSG_SEQ_MASK);
000000B4  00000000   NOP
000001A0  00000000   NOP
306:                 
307:                         if (fifoQueueNum == 0)
000000C8  00000000   NOP
000001B4  00000000   NOP
308:                         {
309:                             CFD1TXQCON |= _CFD1TXQCON_TXQEIE_MASK;
000000D0  00000000   NOP
310:                 
311:                             /* Request the transmit */
312:                             CFD1TXQCON |= _CFD1TXQCON_UINC_MASK;
000000DC  00000000   NOP
313:                             CFD1TXQCON |= _CFD1TXQCON_TXREQ_MASK;
000000E8  00000000   NOP
314:                         }
315:                         else
316:                         {
317:                             *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)) |= _CFD1FIFOCON1_TFERFFIE_MASK;
000001BC  00000000   NOP
318:                 
319:                             /* Request the transmit */
320:                             *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)) |= _CFD1FIFOCON1_UINC_MASK;
000001E0  00000000   NOP
321:                             *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)) |= _CFD1FIFOCON1_TXREQ_MASK;
000001EC  00000000   NOP
322:                         }
323:                         CFD1INT |= _CFD1INT_TXIE_MASK;
000000F4  00000000   NOP
000001F8  00000000   NOP
324:                     }
325:                     return status;
326:                 }
00000144  00000000   NOP
327:                 
328:                 // *****************************************************************************
329:                 /* Function:
330:                     bool CAN1_MessageReceive(uint32_t *id, uint8_t *length, uint8_t *data, uint32_t *timestamp, uint8_t fifoNum, CAN_MSG_RX_ATTRIBUTE *msgAttr)
331:                 
332:                    Summary:
333:                     Receives a message from CAN bus.
334:                 
335:                    Precondition:
336:                     CAN1_Initialize must have been called for the associated CAN instance.
337:                 
338:                    Parameters:
339:                     id          - Pointer to 11-bit / 29-bit identifier (ID) to be received.
340:                     length      - Pointer to data length in number of bytes to be received.
341:                     data        - Pointer to destination data buffer
342:                     timestamp   - Pointer to Rx message timestamp, timestamp value is 0 if Timestamp is disabled in CFD1TSCON
343:                     fifoNum     - FIFO number
344:                     msgAttr     - Data frame or Remote frame to be received
345:                 
346:                    Returns:
347:                     Request status.
348:                     true  - Request was successful.
349:                     false - Request has failed.
350:                 */
351:                 bool CAN1_MessageReceive(uint32_t *id, uint8_t *length, uint8_t *data, uint32_t *timestamp, uint8_t fifoNum, CAN_MSG_RX_ATTRIBUTE *msgAttr)
352:                 {
00000000  00000000   NOP
353:                     bool status = false;
354:                     uint8_t msgIndex = 0;
355:                 
356:                     if ((fifoNum > CAN_NUM_OF_FIFO) || (id == NULL))
00000004  00000000   NOP
357:                     {
358:                         return status;
359:                     }
360:                 
361:                     msgIndex = (uint8_t)((*(volatile uint32_t *)(&CFD1FIFOSTA1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) & _CFD1FIFOSTA1_FIFOCI_MASK) >> 8);
00000018  00000000   NOP
00000030  00000000   NOP
00000040  00000000   NOP
362:                     can1RxMsg[fifoNum-1][msgIndex].id = id;
0000003C  00000000   NOP
00000050  00000000   NOP
0000007C  00000000   NOP
363:                     can1RxMsg[fifoNum-1][msgIndex].buffer = data;
00000080  00000000   NOP
364:                     can1RxMsg[fifoNum-1][msgIndex].size = length;
00000084  00000000   NOP
365:                     can1RxMsg[fifoNum-1][msgIndex].timestamp = timestamp;
00000088  00000000   NOP
366:                     can1RxMsg[fifoNum-1][msgIndex].msgAttr = msgAttr;
0000008C  00000000   NOP
367:                     *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) |= _CFD1FIFOCON1_TFNRFNIE_MASK;
00000028  00000000   NOP
00000038  00000000   NOP
00000044  00000000   NOP
368:                     CFD1INT |= _CFD1INT_RXIE_MASK;
0000004C  00000000   NOP
00000074  00000000   NOP
00000094  00000000   NOP
369:                     status = true;
370:                 
371:                     return status;
00000098  00000000   NOP
372:                 }
0000009C  00000000   NOP
373:                 
374:                 // *****************************************************************************
375:                 /* Function:
376:                     void CAN1_MessageAbort(uint8_t fifoQueueNum)
377:                 
378:                    Summary:
379:                     Abort request for a Queue/FIFO.
380:                 
381:                    Precondition:
382:                     CAN1_Initialize must have been called for the associated CAN instance.
383:                 
384:                    Parameters:
385:                     fifoQueueNum - If fifoQueueNum is 0 then Transmit Queue otherwise FIFO
386:                 
387:                    Returns:
388:                     None.
389:                 */
390:                 void CAN1_MessageAbort(uint8_t fifoQueueNum)
391:                 {
392:                     if (fifoQueueNum == 0)
00000000  00000000   NOP
393:                     {
394:                         CFD1TXQCON &= ~_CFD1TXQCON_TXREQ_MASK;
0000003C  00000000   NOP
395:                     }
396:                     else if (fifoQueueNum <= CAN_NUM_OF_FIFO)
00000008  00000000   NOP
397:                     {
398:                         *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)) &= ~_CFD1FIFOCON1_TXREQ_MASK;
00000010  00000000   NOP
399:                     }
400:                 }
401:                 
402:                 // *****************************************************************************
403:                 /* Function:
404:                     void CAN1_MessageAcceptanceFilterSet(uint8_t filterNum, uint32_t id)
405:                 
406:                    Summary:
407:                     Set Message acceptance filter configuration.
408:                 
409:                    Precondition:
410:                     CAN1_Initialize must have been called for the associated CAN instance.
411:                 
412:                    Parameters:
413:                     filterNum - Filter number
414:                     id        - 11-bit or 29-bit identifier
415:                 
416:                    Returns:
417:                     None.
418:                 */
419:                 void CAN1_MessageAcceptanceFilterSet(uint8_t filterNum, uint32_t id)
420:                 {
421:                     uint32_t filterEnableBit = 0;
422:                     uint8_t filterRegIndex = 0;
423:                 
424:                     if (filterNum < CAN_NUM_OF_FILTER)
00000000  00000000   NOP
425:                     {
426:                         filterRegIndex = filterNum >> 2;
427:                         filterEnableBit = (filterNum % 4 == 0)? _CFD1FLTCON0_FLTEN0_MASK : 1 << ((((filterNum % 4) + 1) * 8) - 1);
428:                 
429:                         *(volatile uint32_t *)(&CFD1FLTCON0 + (filterRegIndex * CAN_FILTER_OFFSET)) &= ~filterEnableBit;
00000008  00000000   NOP
00000010  00000000   NOP
430:                 
431:                         if (id > CAN_MSG_SID_MASK)
0000000C  00000000   NOP
00000018  00000000   NOP
432:                         {
433:                             *(volatile uint32_t *)(&CFD1FLTOBJ0 + (filterNum * CAN_FILTER_OBJ_OFFSET)) = ((((id & CAN_MSG_FLT_EXT_SID_MASK) >> 18) | ((id & CAN_MSG_FLT_EXT_EID_MASK) << 11)) & CAN_MSG_EID_MASK) | _CFD1FLTOBJ0_EXIDE_MASK;
00000038  00000000   NOP
434:                         }
435:                         else
436:                         {
437:                             *(volatile uint32_t *)(&CFD1FLTOBJ0 + (filterNum * CAN_FILTER_OBJ_OFFSET)) = id & CAN_MSG_SID_MASK;
00000020  00000000   NOP
438:                         }
439:                         *(volatile uint32_t *)(&CFD1FLTCON0 + (filterRegIndex * CAN_FILTER_OFFSET)) |= filterEnableBit;
00000024  00000000   NOP
440:                     }
441:                 }
442:                 
443:                 // *****************************************************************************
444:                 /* Function:
445:                     uint32_t CAN1_MessageAcceptanceFilterGet(uint8_t filterNum)
446:                 
447:                    Summary:
448:                     Get Message acceptance filter configuration.
449:                 
450:                    Precondition:
451:                     CAN1_Initialize must have been called for the associated CAN instance.
452:                 
453:                    Parameters:
454:                     filterNum - Filter number
455:                 
456:                    Returns:
457:                     Returns Message acceptance filter identifier
458:                 */
459:                 uint32_t CAN1_MessageAcceptanceFilterGet(uint8_t filterNum)
460:                 {
461:                     uint32_t id = 0;
462:                 
463:                     if (filterNum < CAN_NUM_OF_FILTER)
00000000  00000000   NOP
464:                     {
465:                         if (*(volatile uint32_t *)(&CFD1FLTOBJ0 + (filterNum * CAN_FILTER_OBJ_OFFSET)) & _CFD1FLTOBJ0_EXIDE_MASK)
00000008  00000000   NOP
466:                         {
467:                             id = (((*(volatile uint32_t *)(&CFD1FLTOBJ0 + (filterNum * CAN_FILTER_OBJ_OFFSET)) & CAN_MSG_RX_EXT_SID_MASK) << 18)
0000002C  00000000   NOP
00000034  00000000   NOP
0000003C  00000000   NOP
468:                                | ((*(volatile uint32_t *)(&CFD1FLTOBJ0 + (filterNum * CAN_FILTER_OBJ_OFFSET)) & CAN_MSG_RX_EXT_EID_MASK) >> 11))
00000030  00000000   NOP
00000038  00000000   NOP
469:                                & CAN_MSG_EID_MASK;
470:                         }
471:                         else
472:                         {
473:                             id = (*(volatile uint32_t *)(&CFD1FLTOBJ0 + (filterNum * CAN_FILTER_OBJ_OFFSET)) & CAN_MSG_SID_MASK);
0000001C  00000000   NOP
474:                         }
475:                     }
476:                     return id;
477:                 }
00000024  00000000   NOP
478:                 
479:                 // *****************************************************************************
480:                 /* Function:
481:                     void CAN1_MessageAcceptanceFilterMaskSet(uint8_t acceptanceFilterMaskNum, uint32_t id)
482:                 
483:                    Summary:
484:                     Set Message acceptance filter mask configuration.
485:                 
486:                    Precondition:
487:                     CAN1_Initialize must have been called for the associated CAN instance.
488:                 
489:                    Parameters:
490:                     acceptanceFilterMaskNum - Acceptance Filter Mask number
491:                     id                      - 11-bit or 29-bit identifier
492:                 
493:                    Returns:
494:                     None.
495:                 */
496:                 void CAN1_MessageAcceptanceFilterMaskSet(uint8_t acceptanceFilterMaskNum, uint32_t id)
497:                 {
498:                     /* Switch the CAN module to Configuration mode. Wait until the switch is complete */
499:                     CFD1CON = (CFD1CON & ~_CFD1CON_REQOP_MASK) | ((CAN_CONFIGURATION_MODE << _CFD1CON_REQOP_POSITION) & _CFD1CON_REQOP_MASK);
00000000  00000000   NOP
500:                     while(((CFD1CON & _CFD1CON_OPMOD_MASK) >> _CFD1CON_OPMOD_POSITION) != CAN_CONFIGURATION_MODE);
00000018  00000000   NOP
501:                 
502:                     if (id > CAN_MSG_SID_MASK)
0000002C  00000000   NOP
503:                     {
504:                         *(volatile uint32_t *)(&CFD1MASK0 + (acceptanceFilterMaskNum * CAN_ACCEPTANCE_MASK_OFFSET)) = ((((id & CAN_MSG_FLT_EXT_SID_MASK) >> 18) | ((id & CAN_MSG_FLT_EXT_EID_MASK) << 11)) & CAN_MSG_EID_MASK) | _CFD1MASK0_MIDE_MASK;
00000038  00000000   NOP
505:                     }
506:                     else
507:                     {
508:                         *(volatile uint32_t *)(&CFD1MASK0 + (acceptanceFilterMaskNum * CAN_ACCEPTANCE_MASK_OFFSET)) = id & CAN_MSG_SID_MASK;
00000080  00000000   NOP
509:                     }
510:                 
511:                     /* Switch the CAN module to CAN_OPERATION_MODE. Wait until the switch is complete */
512:                     CFD1CON = (CFD1CON & ~_CFD1CON_REQOP_MASK) | ((CAN_OPERATION_MODE << _CFD1CON_REQOP_POSITION) & _CFD1CON_REQOP_MASK);
0000005C  00000000   NOP
513:                     while(((CFD1CON & _CFD1CON_OPMOD_MASK) >> _CFD1CON_OPMOD_POSITION) != CAN_OPERATION_MODE);
00000068  00000000   NOP
514:                 }
00000078  00000000   NOP
515:                 
516:                 // *****************************************************************************
517:                 /* Function:
518:                     uint32_t CAN1_MessageAcceptanceFilterMaskGet(uint8_t acceptanceFilterMaskNum)
519:                 
520:                    Summary:
521:                     Get Message acceptance filter mask configuration.
522:                 
523:                    Precondition:
524:                     CAN1_Initialize must have been called for the associated CAN instance.
525:                 
526:                    Parameters:
527:                     acceptanceFilterMaskNum - Acceptance Filter Mask number
528:                 
529:                    Returns:
530:                     Returns Message acceptance filter mask.
531:                 */
532:                 uint32_t CAN1_MessageAcceptanceFilterMaskGet(uint8_t acceptanceFilterMaskNum)
533:                 {
534:                     uint32_t id = 0;
535:                 
536:                     if (*(volatile uint32_t *)(&CFD1MASK0 + (acceptanceFilterMaskNum * CAN_ACCEPTANCE_MASK_OFFSET)) & _CFD1MASK0_MIDE_MASK)
00000000  00000000   NOP
537:                     {
538:                         id = (((*(volatile uint32_t *)(&CFD1MASK0 + (acceptanceFilterMaskNum * CAN_ACCEPTANCE_MASK_OFFSET)) & CAN_MSG_RX_EXT_SID_MASK) << 18)
0000002C  00000000   NOP
00000034  00000000   NOP
0000003C  00000000   NOP
539:                            | ((*(volatile uint32_t *)(&CFD1MASK0 + (acceptanceFilterMaskNum * CAN_ACCEPTANCE_MASK_OFFSET)) & CAN_MSG_RX_EXT_EID_MASK) >> 11))
00000030  00000000   NOP
00000038  00000000   NOP
540:                            & CAN_MSG_EID_MASK;
541:                     }
542:                     else
543:                     {
544:                         id = (*(volatile uint32_t *)(&CFD1MASK0 + (acceptanceFilterMaskNum * CAN_ACCEPTANCE_MASK_OFFSET)) & CAN_MSG_SID_MASK);
00000020  00000000   NOP
545:                     }
546:                     return id;
547:                 }
00000024  00000000   NOP
548:                 
549:                 // *****************************************************************************
550:                 /* Function:
551:                     bool CAN1_TransmitEventFIFOElementGet(uint32_t *id, uint32_t *sequence, uint32_t *timestamp)
552:                 
553:                    Summary:
554:                     Get the Transmit Event FIFO Element for the transmitted message.
555:                 
556:                    Precondition:
557:                     CAN1_Initialize must have been called for the associated CAN instance.
558:                 
559:                    Parameters:
560:                     id          - Pointer to 11-bit / 29-bit identifier (ID) to be received.
561:                     sequence    - Pointer to Tx message sequence number to be received
562:                     timestamp   - Pointer to Tx message timestamp to be received, timestamp value is 0 if Timestamp is disabled in CFD1TSCON
563:                 
564:                    Returns:
565:                     Request status.
566:                     true  - Request was successful.
567:                     false - Request has failed.
568:                 */
569:                 bool CAN1_TransmitEventFIFOElementGet(uint32_t *id, uint32_t *sequence, uint32_t *timestamp)
570:                 {
571:                     CAN_TX_EVENT_FIFO_ELEMENT *txEventFIFOElement = NULL;
572:                     bool status = false;
573:                 
574:                     /* Check if there is a message available in Tx Event FIFO */
575:                     if ((CFD1TEFSTA & _CFD1TEFSTA_TEFNEIF_MASK) == _CFD1TEFSTA_TEFNEIF_MASK)
00000000  00000000   NOP
576:                     {
577:                         /* Get a pointer to Tx Event FIFO Element */
578:                         txEventFIFOElement = (CAN_TX_EVENT_FIFO_ELEMENT *)PA_TO_KVA1(CFD1TEFUA);
00000014  00000000   NOP
579:                 
580:                         /* Check if it's a extended message type */
581:                         if (txEventFIFOElement->te1 & CAN_MSG_IDE_MASK)
00000020  00000000   NOP
582:                         {
583:                             *id = txEventFIFOElement->te0 & CAN_MSG_EID_MASK;
0000005C  00000000   NOP
584:                         }
585:                         else
586:                         {
587:                             *id = txEventFIFOElement->te0 & CAN_MSG_SID_MASK;
00000030  00000000   NOP
588:                         }
589:                 
590:                         *sequence = ((txEventFIFOElement->te1 & CAN_MSG_SEQ_MASK) >> 9);
00000038  00000000   NOP
00000040  00000000   NOP
591:                 
592:                         if (timestamp != NULL)
593:                         {
594:                         }
595:                 
596:                         /* Tx Event FIFO Element read done, update the Tx Event FIFO tail */
597:                         CFD1TEFCON |= _CFD1TEFCON_UINC_MASK;
00000048  00000000   NOP
598:                 
599:                         /* Tx Event FIFO Element read successfully, so return true */
600:                         status = true;
0000003C  00000000   NOP
601:                     }
602:                     return status;
603:                 }
00000054  00000000   NOP
604:                 
605:                 // *****************************************************************************
606:                 /* Function:
607:                     CAN_ERROR CAN1_ErrorGet(void)
608:                 
609:                    Summary:
610:                     Returns the error during transfer.
611:                 
612:                    Precondition:
613:                     CAN1_Initialize must have been called for the associated CAN instance.
614:                 
615:                    Parameters:
616:                     None.
617:                 
618:                    Returns:
619:                     Error during transfer.
620:                 */
621:                 CAN_ERROR CAN1_ErrorGet(void)
622:                 {
623:                     return (CAN_ERROR)can1Obj.errorStatus;
624:                 }
625:                 
626:                 // *****************************************************************************
627:                 /* Function:
628:                     void CAN1_ErrorCountGet(uint8_t *txErrorCount, uint8_t *rxErrorCount)
629:                 
630:                    Summary:
631:                     Returns the transmit and receive error count during transfer.
632:                 
633:                    Precondition:
634:                     CAN1_Initialize must have been called for the associated CAN instance.
635:                 
636:                    Parameters:
637:                     txErrorCount - Transmit Error Count to be received
638:                     rxErrorCount - Receive Error Count to be received
639:                 
640:                    Returns:
641:                     None.
642:                 */
643:                 void CAN1_ErrorCountGet(uint8_t *txErrorCount, uint8_t *rxErrorCount)
644:                 {
645:                     *txErrorCount = (uint8_t)((CFD1TREC & _CFD1TREC_TERRCNT_MASK) >> _CFD1TREC_TERRCNT_POSITION);
00000000  00000000   NOP
646:                     *rxErrorCount = (uint8_t)(CFD1TREC & _CFD1TREC_RERRCNT_MASK);
00000010  00000000   NOP
647:                 }
648:                 
649:                 // *****************************************************************************
650:                 /* Function:
651:                     bool CAN1_InterruptGet(uint8_t fifoQueueNum, CAN_FIFO_INTERRUPT_FLAG_MASK fifoInterruptFlagMask)
652:                 
653:                    Summary:
654:                     Returns the FIFO Interrupt status.
655:                 
656:                    Precondition:
657:                     CAN1_Initialize must have been called for the associated CAN instance.
658:                 
659:                    Parameters:
660:                     fifoQueueNum          - FIFO number
661:                     fifoInterruptFlagMask - FIFO interrupt flag mask
662:                 
663:                    Returns:
664:                     true - Requested fifo interrupt is occurred.
665:                     false - Requested fifo interrupt is not occurred.
666:                 */
667:                 bool CAN1_InterruptGet(uint8_t fifoQueueNum, CAN_FIFO_INTERRUPT_FLAG_MASK fifoInterruptFlagMask)
668:                 {
669:                     if (fifoQueueNum == 0)
00000000  00000000   NOP
670:                     {
671:                         return ((CFD1TXQSTA & fifoInterruptFlagMask) != 0x0);
0000002C  00000000   NOP
672:                     }
673:                     else
674:                     {
675:                         return ((*(volatile uint32_t *)(&CFD1FIFOSTA1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)) & fifoInterruptFlagMask) != 0x0);
00000008  00000000   NOP
676:                     }
677:                 }
00000024  00000000   NOP
678:                 
679:                 // *****************************************************************************
680:                 /* Function:
681:                     bool CAN1_TxFIFOQueueIsFull(uint8_t fifoQueueNum)
682:                 
683:                    Summary:
684:                     Returns true if Tx FIFO/Queue is full otherwise false.
685:                 
686:                    Precondition:
687:                     CAN1_Initialize must have been called for the associated CAN instance.
688:                 
689:                    Parameters:
690:                     fifoQueueNum - FIFO/Queue number
691:                 
692:                    Returns:
693:                     true  - Tx FIFO/Queue is full.
694:                     false - Tx FIFO/Queue is not full.
695:                 */
696:                 bool CAN1_TxFIFOQueueIsFull(uint8_t fifoQueueNum)
697:                 {
698:                     if (fifoQueueNum == 0)
00000000  00000000   NOP
699:                     {
700:                         return ((CFD1TXQSTA & _CFD1TXQSTA_TXQNIF_MASK) != _CFD1TXQSTA_TXQNIF_MASK);
0000002C  00000000   NOP
701:                     }
702:                     else
703:                     {
704:                         return ((*(volatile uint32_t *)(&CFD1FIFOSTA1 + ((fifoQueueNum - 1) * CAN_FIFO_OFFSET)) & _CFD1FIFOSTA1_TFNRFNIF_MASK) != _CFD1FIFOSTA1_TFNRFNIF_MASK);
00000008  00000000   NOP
705:                     }
706:                 }
00000024  00000000   NOP
707:                 
708:                 // *****************************************************************************
709:                 /* Function:
710:                     bool CAN1_AutoRTRResponseSet(uint32_t id, uint8_t length, uint8_t* data, uint8_t fifoNum)
711:                 
712:                    Summary:
713:                     Set the Auto RTR response for remote transmit request.
714:                 
715:                    Precondition:
716:                     CAN1_Initialize must have been called for the associated CAN instance.
717:                     Auto RTR Enable must be set to 0x1 for the requested Transmit FIFO in MHC configuration.
718:                 
719:                    Parameters:
720:                     id           - 11-bit / 29-bit identifier (ID).
721:                     length       - Length of data buffer in number of bytes.
722:                     data         - Pointer to source data buffer
723:                     fifoNum      - FIFO Number
724:                 
725:                    Returns:
726:                     Request status.
727:                     true  - Request was successful.
728:                     false - Request has failed.
729:                 */
730:                 bool CAN1_AutoRTRResponseSet(uint32_t id, uint8_t length, uint8_t* data, uint8_t fifoNum)
731:                 {
732:                     CAN_TX_MSG_OBJECT *txMessage = NULL;
733:                     uint8_t count = 0;
734:                     bool status = false;
735:                 
736:                     if (fifoNum <= CAN_NUM_OF_FIFO)
00000000  00000000   NOP
737:                     {
738:                         if ((*(volatile uint32_t *)(&CFD1FIFOSTA1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) & _CFD1FIFOSTA1_TFNRFNIF_MASK) == _CFD1FIFOSTA1_TFNRFNIF_MASK)
0000000C  00000000   NOP
739:                         {
740:                             txMessage = (CAN_TX_MSG_OBJECT *)PA_TO_KVA1(*(volatile uint32_t *)(&CFD1FIFOUA1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)));
00000034  00000000   NOP
0000003C  00000000   NOP
741:                             status = true;
0000009C  00000000   NOP
742:                         }
743:                     }
744:                 
745:                     if (status)
746:                     {
747:                         /* Check the id whether it falls under SID or EID,
748:                          * SID max limit is 0x7FF, so anything beyond that is EID */
749:                         if (id > CAN_MSG_SID_MASK)
00000038  00000000   NOP
00000040  00000000   NOP
750:                         {
751:                             txMessage->t0 = (((id & CAN_MSG_TX_EXT_SID_MASK) >> 18) | ((id & CAN_MSG_TX_EXT_EID_MASK) << 11)) & CAN_MSG_EID_MASK;
000000CC  00000000   NOP
752:                             txMessage->t1 = CAN_MSG_IDE_MASK;
753:                         }
754:                         else
755:                         {
756:                             txMessage->t0 = id;
00000048  00000000   NOP
757:                             txMessage->t1 = 0;
758:                         }
759:                 
760:                         /* Limit length */
761:                         if (length > 8)
762:                             length = 8;
763:                         txMessage->t1 |= length;
00000060  00000000   NOP
764:                 
765:                         while(count < length)
00000064  00000000   NOP
00000088  00000000   NOP
766:                         {
767:                             txMessage->data[count++] = *data++;
0000007C  00000000   NOP
768:                         }
769:                 
770:                         *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) |= _CFD1FIFOCON1_TFERFFIE_MASK;
00000090  00000000   NOP
000000A0  00000000   NOP
771:                 
772:                         /* Set UINC to respond to RTR */
773:                         *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) |= _CFD1FIFOCON1_UINC_MASK;
000000A8  00000000   NOP
774:                         CFD1INT |= _CFD1INT_TXIE_MASK;
000000B4  00000000   NOP
775:                     }
776:                     return status;
777:                 }
778:                 
779:                 // *****************************************************************************
780:                 /* Function:
781:                     void CAN1_CallbackRegister(CAN_CALLBACK callback, uintptr_t contextHandle, uint8_t fifoQueueNum)
782:                 
783:                    Summary:
784:                     Sets the pointer to the function (and it's context) to be called when the
785:                     given CAN's transfer events occur.
786:                 
787:                    Precondition:
788:                     CAN1_Initialize must have been called for the associated CAN instance.
789:                 
790:                    Parameters:
791:                     callback - A pointer to a function with a calling signature defined
792:                     by the CAN_CALLBACK data type.
793:                     fifoQueueNum - Tx Queue or Tx/Rx FIFO number
794:                 
795:                     context - A value (usually a pointer) passed (unused) into the function
796:                     identified by the callback parameter.
797:                 
798:                    Returns:
799:                     None.
800:                 */
801:                 void CAN1_CallbackRegister(CAN_CALLBACK callback, uintptr_t contextHandle, uint8_t fifoQueueNum)
802:                 {
803:                     if (callback == NULL)
00000000  00000000   NOP
804:                     {
805:                         return;
806:                     }
807:                 
808:                     can1CallbackObj[fifoQueueNum].callback = callback;
00000008  00000000   NOP
809:                     can1CallbackObj[fifoQueueNum].context = contextHandle;
00000018  00000000   NOP
810:                 }
811:                 
812:                 // *****************************************************************************
813:                 /* Function:
814:                     void CAN1_ErrorCallbackRegister(CAN_CALLBACK callback, uintptr_t contextHandle)
815:                 
816:                    Summary:
817:                     Sets the pointer to the function (and it's context) to be called when the
818:                     given CAN's transfer events occur.
819:                 
820:                    Precondition:
821:                     CAN1_Initialize must have been called for the associated CAN instance.
822:                 
823:                    Parameters:
824:                     callback - A pointer to a function with a calling signature defined
825:                     by the CAN_CALLBACK data type.
826:                 
827:                     context - A value (usually a pointer) passed (unused) into the function
828:                     identified by the callback parameter.
829:                 
830:                    Returns:
831:                     None.
832:                 */
833:                 void CAN1_ErrorCallbackRegister(CAN_CALLBACK callback, uintptr_t contextHandle)
834:                 {
835:                     if (callback == NULL)
00000000  00000000   NOP
836:                     {
837:                         return;
838:                     }
839:                 
840:                     can1ErrorCallbackObj.callback = callback;
00000008  00000000   NOP
841:                     can1ErrorCallbackObj.context = contextHandle;
0000000C  00000000   NOP
842:                 }
843:                 
844:                 // *****************************************************************************
845:                 /* Function:
846:                     void CAN1_InterruptHandler(void)
847:                 
848:                    Summary:
849:                     CAN1 Peripheral Interrupt Handler.
850:                 
851:                    Description:
852:                     This function is CAN1 Peripheral Interrupt Handler and will
853:                     called on every CAN1 interrupt.
854:                 
855:                    Precondition:
856:                     None.
857:                 
858:                    Parameters:
859:                     None.
860:                 
861:                    Returns:
862:                     None.
863:                 
864:                    Remarks:
865:                     The function is called as peripheral instance's interrupt handler if the
866:                     instance interrupt is enabled. If peripheral instance's interrupt is not
867:                     enabled user need to call it from the main while loop of the application.
868:                 */
869:                 void CAN1_InterruptHandler(void)
870:                 {
9D073A9C  27BDFFE0   ADDIU SP, SP, -32
9D073AA0  AFBF001C   SW RA, 28(SP)
9D073AA4  AFB20018   SW S2, 24(SP)
9D073AA8  AFB10014   SW S1, 20(SP)
9D073AAC  AFB00010   SW S0, 16(SP)
871:                     uint8_t  msgIndex = 0;
872:                     uint8_t  fifoNum = 0;
873:                     uint8_t  fifoSize = 0;
874:                     uint8_t  count = 0;
9D073B84  00001021   ADDU V0, ZERO, ZERO
875:                     CAN_RX_MSG_OBJECT *rxMessage = NULL;
876:                     uint32_t interruptStatus = 0;
877:                     uint32_t errorStatus = 0;
878:                 
879:                     interruptStatus = CFD1INT;
9D073AB0  3C10BF88   LUI S0, -16504
9D073AB4  8E020070   LW V0, 112(S0)
880:                     /* Check if error occurred */
881:                     if (interruptStatus & (_CFD1INT_SERRIF_MASK | _CFD1INT_CERRIF_MASK | _CFD1INT_IVMIF_MASK))
9D073AB8  3042B000   ANDI V0, V0, -20480
9D073ABC  10400016   BEQ V0, ZERO, .LVL82
9D073AC0  00000000   NOP
882:                     {
883:                         CFD1INT &= ~(_CFD1INT_SERRIF_MASK | _CFD1INT_CERRIF_MASK | _CFD1INT_IVMIF_MASK);
9D073AC4  8E030070   LW V1, 112(S0)
9D073AC8  3C02FFFF   LUI V0, -1
9D073ACC  24424FFF   ADDIU V0, V0, 20479
9D073AD0  00621024   AND V0, V1, V0
9D073AD4  AE020070   SW V0, 112(S0)
884:                         IFS5CLR = _IFS5_CAN1IF_MASK;
9D073AD8  24030080   ADDIU V1, ZERO, 128
9D073ADC  3C02BF81   LUI V0, -16511
9D073AE0  AC430094   SW V1, 148(V0)
885:                         errorStatus = CFD1TREC;
9D073AE4  8E0300D0   LW V1, 208(S0)
886:                 
887:                         /* Check if error occurred */
888:                         can1Obj.errorStatus = ((errorStatus & _CFD1TREC_EWARN_MASK) |
889:                                                                           (errorStatus & _CFD1TREC_RXWARN_MASK) |
890:                                                                           (errorStatus & _CFD1TREC_TXWARN_MASK) |
891:                                                                           (errorStatus & _CFD1TREC_RXBP_MASK) |
892:                                                                           (errorStatus & _CFD1TREC_TXBP_MASK) |
9D073AEC  3C02003F   LUI V0, 63
9D073AF0  00621024   AND V0, V1, V0
893:                                                                           (errorStatus & _CFD1TREC_TXBO_MASK));
894:                 
895:                         /* Client must call CAN1_ErrorGet and CAN1_ErrorCountGet functions to get errors */
896:                         if (can1ErrorCallbackObj.callback != NULL)
9D073AE8  8F998048   LW T9, -32696(GP)
9D073AF4  1320009B   BEQ T9, ZERO, .LVL98
9D073AF8  AF828050   SW V0, -32688(GP)
897:                         {
898:                             can1ErrorCallbackObj.callback(can1ErrorCallbackObj.context);
9D073AFC  8F84804C   LW A0, -32692(GP)
899:                         }
900:                     }
901:                     else
902:                     {
903:                         can1Obj.errorStatus = 0;
904:                         if (CFD1INT & _CFD1INT_RXIF_MASK)
9D073B18  8E020070   LW V0, 112(S0)
9D073B1C  30420002   ANDI V0, V0, 2
9D073B20  1040006D   BEQ V0, ZERO, 0x9D073CD8
9D073B24  AF808050   SW ZERO, -32688(GP)
905:                         {
906:                             fifoNum = (uint8_t)CFD1VEC & _CFD1VEC_ICODE_MASK;
9D073B28  8E190060   LW T9, 96(S0)
9D073B2C  3339007F   ANDI T9, T9, 127
907:                             if (fifoNum <= CAN_NUM_OF_FIFO)
9D073B30  2F220003   SLTIU V0, T9, 3
9D073B34  5040005D   BEQL V0, ZERO, .LVL94
9D073B38  0019C8C0   SLL T9, T9, 3
908:                             {
909:                                 *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) &= ~_CFD1FIFOCON1_TFNRFNIE_MASK;
9D073B3C  2722FFFF   ADDIU V0, T9, -1
9D073B40  00021900   SLL V1, V0, 4
9D073B44  00022180   SLL A0, V0, 6
9D073B48  00831823   SUBU V1, A0, V1
9D073B4C  260B0170   ADDIU T3, S0, 368
9D073B50  01635821   ADDU T3, T3, V1
9D073B54  8D640000   LW A0, 0(T3)
9D073B58  7C040004   INS A0, ZERO, 0, 1
9D073B5C  AD640000   SW A0, 0(T3)
910:                                 IFS5CLR = _IFS5_CAN1IF_MASK;
9D073B60  24050080   ADDIU A1, ZERO, 128
9D073B64  3C04BF81   LUI A0, -16511
9D073B68  AC850094   SW A1, 148(A0)
911:                                 fifoSize = (*(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) & _CFD1FIFOCON1_FSIZE_MASK) >> _CFD1FIFOCON1_FSIZE_POSITION;
9D073B6C  8D6E0000   LW T6, 0(T3)
9D073B70  260D0190   ADDIU T5, S0, 400
9D073B74  000249C0   SLL T1, V0, 7
9D073B78  00022240   SLL A0, V0, 9
9D073B7C  7DCE2600   EXT T6, T6, 24, 5
9D073B80  01A36821   ADDU T5, T5, V1
912:                                 for (msgIndex = 0; msgIndex <= fifoSize; msgIndex++)
9D073B88  00004021   ADDU T0, ZERO, ZERO
9D073B8C  3C0A8000   LUI T2, -32768
9D073B90  254A12C0   ADDIU T2, T2, 4800
9D073C8C  25080001   ADDIU T0, T0, 1
9D073C90  310800FF   ANDI T0, T0, 255
9D073C98  01C8182B   SLTU V1, T6, T0
9D073CA0  1060FFC3   BEQ V1, ZERO, 0x9D073BB0
9D073CA4  00082080   SLL A0, T0, 2
913:                                 {
914:                                     /* Get a pointer to RX message buffer */
915:                                     rxMessage = (CAN_RX_MSG_OBJECT *)PA_TO_KVA1(*(volatile uint32_t *)(&CFD1FIFOUA1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)));
9D073B94  3C0CA000   LUI T4, -24576
9D073BC0  8DA70000   LW A3, 0(T5)
916:                 
917:                                     if (can1RxMsg[fifoNum-1][msgIndex].buffer != NULL)
9D073B98  01244821   ADDU T1, T1, A0
9D073BAC  00082080   SLL A0, T0, 2
9D073BB0  00081900   SLL V1, T0, 4
9D073BB4  00832821   ADDU A1, A0, V1
9D073BB8  00A92821   ADDU A1, A1, T1
9D073BBC  01452821   ADDU A1, T2, A1
9D073BC4  8CA60004   LW A2, 4(A1)
9D073BC8  10C0002F   BEQ A2, ZERO, 0x9D073C88
9D073BCC  00EC3825   OR A3, A3, T4
918:                                     {
919:                                         /* Check if it's a extended message type */
920:                                         if (rxMessage->r1 & CAN_MSG_IDE_MASK)
9D073BD0  8CE60004   LW A2, 4(A3)
9D073BD4  30C60010   ANDI A2, A2, 16
9D073BD8  10C00068   BEQ A2, ZERO, .LVL99
9D073BDC  8CE60000   LW A2, 0(A3)
921:                                         {
922:                                             *can1RxMsg[fifoNum-1][msgIndex].id = (((rxMessage->r0 & CAN_MSG_RX_EXT_SID_MASK) << 18) | ((rxMessage->r0 & CAN_MSG_RX_EXT_EID_MASK) >> 11)) & CAN_MSG_EID_MASK;
9D073BE0  8CA50000   LW A1, 0(A1)
9D073BE4  30D207FF   ANDI S2, A2, 2047
9D073BE8  7CC68AC0   EXT A2, A2, 11, 18
9D073BEC  00129480   SLL S2, S2, 18
9D073BF0  00D23025   OR A2, A2, S2
9D073BF4  ACA60000   SW A2, 0(A1)
923:                                         }
924:                                         else
925:                                         {
926:                                             *can1RxMsg[fifoNum-1][msgIndex].id = rxMessage->r0 & CAN_MSG_SID_MASK;
9D073D7C  8CA50000   LW A1, 0(A1)
9D073D80  30C607FF   ANDI A2, A2, 2047
9D073D84  ACA60000   SW A2, 0(A1)
927:                                         }
928:                 
929:                                         if ((rxMessage->r1 & CAN_MSG_RTR_MASK) && ((rxMessage->r1 & CAN_MSG_FDF_MASK) == 0))
9D073B9C  24180020   ADDIU T8, ZERO, 32
9D073BF8  8CE50004   LW A1, 4(A3)
9D073BFC  30A500A0   ANDI A1, A1, 160
9D073C00  10B80065   BEQ A1, T8, 0x9D073D98
9D073C04  00832821   ADDU A1, A0, V1
9D073D88  8CE50004   LW A1, 4(A3)
9D073D8C  30A500A0   ANDI A1, A1, 160
9D073D90  14B8FF9D   BNE A1, T8, 0x9D073C08
9D073D94  00832821   ADDU A1, A0, V1
930:                                         {
931:                                             *can1RxMsg[fifoNum-1][msgIndex].msgAttr = CAN_MSG_RX_REMOTE_FRAME;
9D073BA8  24110001   ADDIU S1, ZERO, 1
9D073D98  00A92821   ADDU A1, A1, T1
9D073D9C  01452821   ADDU A1, T2, A1
9D073DA0  8CA50010   LW A1, 16(A1)
9D073DA4  0B41CF06   J 0x9D073C18
9D073DA8  ACB10000   SW S1, 0(A1)
932:                                         }
933:                                         else
934:                                         {
935:                                             *can1RxMsg[fifoNum-1][msgIndex].msgAttr = CAN_MSG_RX_DATA_FRAME;
9D073C08  00A92821   ADDU A1, A1, T1
9D073C0C  01452821   ADDU A1, T2, A1
9D073C10  8CA50010   LW A1, 16(A1)
9D073C14  ACA00000   SW ZERO, 0(A1)
936:                                         }
937:                 
938:                                         *can1RxMsg[fifoNum-1][msgIndex].size = dlcToLength[(rxMessage->r1 & CAN_MSG_DLC_MASK)];
9D073BA0  3C0F9D08   LUI T7, -25336
9D073BA4  25EF9188   ADDIU T7, T7, -28280
9D073C18  8CE50004   LW A1, 4(A3)
9D073C1C  00831821   ADDU V1, A0, V1
9D073C20  00691821   ADDU V1, V1, T1
9D073C24  30A5000F   ANDI A1, A1, 15
9D073C28  01431821   ADDU V1, T2, V1
9D073C2C  00AF2821   ADDU A1, A1, T7
9D073C30  8C640008   LW A0, 8(V1)
9D073C34  90A50000   LBU A1, 0(A1)
9D073C38  A0850000   SB A1, 0(A0)
939:                 
940:                                         if (can1RxMsg[fifoNum-1][msgIndex].timestamp != NULL)
941:                                         {
942:                                         }
943:                 
944:                                         /* Copy the data into the payload */
945:                                         while (count < *can1RxMsg[fifoNum-1][msgIndex].size)
9D073C3C  8C640008   LW A0, 8(V1)
9D073C40  90840000   LBU A0, 0(A0)
9D073C44  0044202B   SLTU A0, V0, A0
9D073C48  1080000F   BEQ A0, ZERO, 0x9D073C88
9D073C4C  00000000   NOP
9D073C50  00402821   ADDU A1, V0, ZERO
9D073C74  8C640008   LW A0, 8(V1)
9D073C78  90840000   LBU A0, 0(A0)
9D073C7C  0044202B   SLTU A0, V0, A0
9D073C80  1480FFF4   BNE A0, ZERO, 0x9D073C54
9D073C84  00402821   ADDU A1, V0, ZERO
946:                                         {
947:                                             *can1RxMsg[fifoNum-1][msgIndex].buffer++ = rxMessage->data[count++];
9D073C54  8C640004   LW A0, 4(V1)
9D073C58  00E52821   ADDU A1, A3, A1
9D073C5C  24420001   ADDIU V0, V0, 1
9D073C60  24860001   ADDIU A2, A0, 1
9D073C64  AC660004   SW A2, 4(V1)
9D073C68  90A60008   LBU A2, 8(A1)
9D073C6C  304200FF   ANDI V0, V0, 255
9D073C70  A0860000   SB A2, 0(A0)
948:                                         }
949:                                     }
950:                                     /* Message processing is done, update the message buffer pointer. */
951:                                     *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) |= _CFD1FIFOCON1_UINC_MASK;
9D073C88  8D640000   LW A0, 0(T3)
9D073C94  34840100   ORI A0, A0, 256
9D073C9C  AD640000   SW A0, 0(T3)
952:                                 }
953:                             }
954:                             CFD1INT &= ~_CFD1INT_RXIE_MASK;
9D073CAC  8E030070   LW V1, 112(S0)
9D073CC0  7C038C44   INS V1, ZERO, 17, 1
9D073CC4  AE030070   SW V1, 112(S0)
955:                             if (can1CallbackObj[fifoNum].callback != NULL)
9D073CA8  0019C8C0   SLL T9, T9, 3
9D073CB0  3C028000   LUI V0, -32768
9D073CB4  24421B04   ADDIU V0, V0, 6916
9D073CB8  0322C821   ADDU T9, T9, V0
9D073CBC  8F220000   LW V0, 0(T9)
9D073CC8  10400003   BEQ V0, ZERO, 0x9D073CD8
9D073CCC  00000000   NOP
956:                             {
957:                                 can1CallbackObj[fifoNum].callback(can1CallbackObj[fifoNum].context);
9D073CD0  0040F809   JALR V0
9D073CD4  8F240004   LW A0, 4(T9)
958:                             }
959:                         }
960:                         if (CFD1INT & _CFD1INT_TXIF_MASK)
9D073CD8  8E030070   LW V1, 112(S0)
9D073CDC  30630001   ANDI V1, V1, 1
9D073CE0  10600020   BEQ V1, ZERO, .LVL98
9D073CE4  3C02BF88   LUI V0, -16504
961:                         {
962:                             fifoNum = (uint8_t)CFD1VEC & _CFD1VEC_ICODE_MASK;
9D073CE8  8C430060   LW V1, 96(V0)
9D073CEC  3063007F   ANDI V1, V1, 127
963:                             if (fifoNum <= CAN_NUM_OF_FIFO)
9D073CF0  2C640003   SLTIU A0, V1, 3
9D073CF4  10800007   BEQ A0, ZERO, 0x9D073D14
9D073CF8  24040080   ADDIU A0, ZERO, 128
964:                             {
965:                                 if (fifoNum == 0)
9D073CFC  1460002B   BNE V1, ZERO, .LVL100
9D073D00  2464FFFF   ADDIU A0, V1, -1
966:                                 {
967:                                     CFD1TXQCON &= ~_CFD1TXQCON_TXQEIE_MASK;
9D073D04  8C440140   LW A0, 320(V0)
9D073D08  7C041084   INS A0, ZERO, 2, 1
9D073D0C  AC440140   SW A0, 320(V0)
968:                                 }
969:                                 else
970:                                 {
971:                                     *(volatile uint32_t *)(&CFD1FIFOCON1 + ((fifoNum - 1) * CAN_FIFO_OFFSET)) &= ~_CFD1FIFOCON1_TFERFFIE_MASK;
9D073DAC  00042900   SLL A1, A0, 4
9D073DB0  00042180   SLL A0, A0, 6
9D073DB4  00852023   SUBU A0, A0, A1
9D073DB8  24420170   ADDIU V0, V0, 368
9D073DBC  00441021   ADDU V0, V0, A0
9D073DC0  8C440000   LW A0, 0(V0)
9D073DC4  7C041084   INS A0, ZERO, 2, 1
9D073DC8  AC440000   SW A0, 0(V0)
972:                                 }
973:                             }
974:                             IFS5CLR = _IFS5_CAN1IF_MASK;
9D073D10  24040080   ADDIU A0, ZERO, 128
9D073D14  3C02BF81   LUI V0, -16511
9D073D18  AC440094   SW A0, 148(V0)
9D073DCC  0B41CF45   J 0x9D073D14
9D073DD0  24040080   ADDIU A0, ZERO, 128
975:                             CFD1INT &= ~_CFD1INT_TXIE_MASK;
9D073D20  8E040070   LW A0, 112(S0)
9D073D34  3C05FFFE   LUI A1, -2
9D073D38  34A5FFFF   ORI A1, A1, -1
9D073D3C  00851824   AND V1, A0, A1
9D073D40  AE030070   SW V1, 112(S0)
976:                             if (can1CallbackObj[fifoNum].callback != NULL)
9D073D1C  000318C0   SLL V1, V1, 3
9D073D24  3C028000   LUI V0, -32768
9D073D28  24421B04   ADDIU V0, V0, 6916
9D073D2C  00621021   ADDU V0, V1, V0
9D073D30  8C590000   LW T9, 0(V0)
9D073D44  13200007   BEQ T9, ZERO, .LVL98
9D073D48  8FBF001C   LW RA, 28(SP)
977:                             {
978:                                 can1CallbackObj[fifoNum].callback(can1CallbackObj[fifoNum].context);
9D073B10  03200008   JR T9
9D073B14  27BD0020   ADDIU SP, SP, 32
9D073D4C  8C440004   LW A0, 4(V0)
9D073D5C  03200008   JR T9
9D073D60  27BD0020   ADDIU SP, SP, 32
979:                             }
980:                         }
981:                     }
982:                 }
9D073B00  8FBF001C   LW RA, 28(SP)
9D073B04  8FB20018   LW S2, 24(SP)
9D073B08  8FB10014   LW S1, 20(SP)
9D073B0C  8FB00010   LW S0, 16(SP)
9D073D50  8FB20018   LW S2, 24(SP)
9D073D54  8FB10014   LW S1, 20(SP)
9D073D58  8FB00010   LW S0, 16(SP)
9D073D64  8FBF001C   LW RA, 28(SP)
9D073D68  8FB20018   LW S2, 24(SP)
9D073D6C  8FB10014   LW S1, 20(SP)
9D073D70  8FB00010   LW S0, 16(SP)
9D073D74  03E00008   JR RA
9D073D78  27BD0020   ADDIU SP, SP, 32
9D073D7C  8CA50000   LW A1, 0(A1)
9D073D80  30C607FF   ANDI A2, A2, 2047
9D073D84  ACA60000   SW A2, 0(A1)
9D073D88  8CE50004   LW A1, 4(A3)
9D073D8C  30A500A0   ANDI A1, A1, 160
9D073D90  14B8FF9D   BNE A1, T8, 0x9D073C08
9D073D94  00832821   ADDU A1, A0, V1
9D073D98  00A92821   ADDU A1, A1, T1
9D073D9C  01452821   ADDU A1, T2, A1
9D073DA0  8CA50010   LW A1, 16(A1)
9D073DA4  0B41CF06   J 0x9D073C18
9D073DA8  ACB10000   SW S1, 0(A1)
9D073DAC  00042900   SLL A1, A0, 4
9D073DB0  00042180   SLL A0, A0, 6
9D073DB4  00852023   SUBU A0, A0, A1
9D073DB8  24420170   ADDIU V0, V0, 368
9D073DBC  00441021   ADDU V0, V0, A0
9D073DC0  8C440000   LW A0, 0(V0)
9D073DC4  7C041084   INS A0, ZERO, 2, 1
9D073DC8  AC440000   SW A0, 0(V0)
9D073DCC  0B41CF45   J 0x9D073D14
9D073DD0  24040080   ADDIU A0, ZERO, 128
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/interrupts.c
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       interrupt.c
9:                   
10:                    Summary:
11:                      Interrupt vectors mapping
12:                  
13:                    Description:
14:                      This file maps all the interrupt vectors to their corresponding
15:                      implementations. If a particular module interrupt is used, then its ISR
16:                      definition can be found in corresponding PLIB source file. If a module
17:                      interrupt is not used, then its ISR implementation is mapped to dummy
18:                      handler.
19:                   *******************************************************************************/
20:                  
21:                  // DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
24:                  *
25:                  * Subject to your compliance with these terms, you may use Microchip software
26:                  * and any derivatives exclusively with Microchip products. It is your
27:                  * responsibility to comply with third party license terms applicable to your
28:                  * use of third party software (including open source software) that may
29:                  * accompany Microchip software.
30:                  *
31:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
32:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
33:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
34:                  * PARTICULAR PURPOSE.
35:                  *
36:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:                   *******************************************************************************/
44:                  // DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "definitions.h"
53:                  
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  // Section: System Interrupt Vector Functions
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  
60:                  
61:                  void CORE_TIMER_InterruptHandler( void );
62:                  void SPI1_RX_InterruptHandler( void );
63:                  void SPI1_TX_InterruptHandler( void );
64:                  void UART1_FAULT_InterruptHandler( void );
65:                  void UART1_RX_InterruptHandler( void );
66:                  void UART1_TX_InterruptHandler( void );
67:                  void UART2_FAULT_InterruptHandler( void );
68:                  void UART2_RX_InterruptHandler( void );
69:                  void UART2_TX_InterruptHandler( void );
70:                  void CAN1_InterruptHandler( void );
71:                  
72:                  
73:                  
74:                  /* All the handlers are defined here.  Each will call its PLIB-specific function. */
75:                  void __ISR(_CORE_TIMER_VECTOR, ipl1SRS) CORE_TIMER_Handler (void)
76:                  {
9D074F0C  415DE800   RDPGPR SP, SP
9D074F10  401A7000   MFC0 K0, EPC
9D074F14  401B6000   MFC0 K1, Status
9D074F18  27BDFF18   ADDIU SP, SP, -232
9D074F1C  AFBA00E4   SW K0, 228(SP)
9D074F20  401A6002   MFC0 K0, SRSCtl
9D074F24  AFBB00E0   SW K1, 224(SP)
9D074F28  AFBA00DC   SW K0, 220(SP)
9D074F2C  7C1B7844   INS K1, ZERO, 1, 15
9D074F30  377B0400   ORI K1, K1, 1024
9D074F34  409B6000   MTC0 K1, Status
9D074F38  F7B300A8   SDC1 F19, 168(SP)
9D074F3C  F7B200A0   SDC1 F18, 160(SP)
9D074F40  F7B10098   SDC1 F17, 152(SP)
9D074F44  F7B00090   SDC1 F16, 144(SP)
9D074F48  F7AF0088   SDC1 F15, 136(SP)
9D074F4C  F7AE0080   SDC1 F14, 128(SP)
9D074F50  F7AD0078   SDC1 F13, 120(SP)
9D074F54  F7AC0070   SDC1 F12, 112(SP)
9D074F58  F7AB0068   SDC1 F11, 104(SP)
9D074F5C  F7AA0060   SDC1 F10, 96(SP)
9D074F60  F7A90058   SDC1 F9, 88(SP)
9D074F64  F7A80050   SDC1 F8, 80(SP)
9D074F68  F7A70048   SDC1 F7, 72(SP)
9D074F6C  F7A60040   SDC1 F6, 64(SP)
9D074F70  F7A50038   SDC1 F5, 56(SP)
9D074F74  F7A40030   SDC1 F4, 48(SP)
9D074F78  F7A30028   SDC1 F3, 40(SP)
9D074F7C  F7A20020   SDC1 F2, 32(SP)
9D074F80  F7A10018   SDC1 F1, 24(SP)
9D074F84  F7A00010   SDC1 F0, 16(SP)
9D074F88  00001012   MFLO V0
9D074F8C  AFA200D4   SW V0, 212(SP)
9D074F90  00001810   MFHI V1
9D074F94  AFA300D0   SW V1, 208(SP)
9D074F98  00201012   MFLO V0
9D074F9C  AFA200CC   SW V0, 204(SP)
9D074FA0  00201810   MFHI V1
9D074FA4  AFA300C8   SW V1, 200(SP)
9D074FA8  00401012   MFLO V0
9D074FAC  AFA200C4   SW V0, 196(SP)
9D074FB0  00401810   MFHI V1
9D074FB4  AFA300C0   SW V1, 192(SP)
9D074FB8  00601012   MFLO V0
9D074FBC  AFA200BC   SW V0, 188(SP)
9D074FC0  00601810   MFHI V1
9D074FC4  AFA300B8   SW V1, 184(SP)
9D074FC8  7C3F1CB8   RDDSP V1, 0x3F
9D074FCC  AFA300D8   SW V1, 216(SP)
9D074FD0  4442F800   CFC1 V0, F31
9D074FD4  AFA200B4   SW V0, 180(SP)
77:                      CORE_TIMER_InterruptHandler();
9D074FD8  0F41DFA2   JAL CORE_TIMER_InterruptHandler
9D074FDC  00000000   NOP
78:                  }
9D074FE0  8FA200B4   LW V0, 180(SP)
9D074FE4  44C2F800   CTC1 V0, F31
9D074FE8  8FA300D8   LW V1, 216(SP)
9D074FEC  7C61FCF8   WRDSP V1, 0x3F
9D074FF0  8FA200D4   LW V0, 212(SP)
9D074FF4  00400013   MTLO V0
9D074FF8  8FA300D0   LW V1, 208(SP)
9D074FFC  00600011   MTHI V1
9D075000  8FA500CC   LW A1, 204(SP)
9D075004  00A00813   MTLO A1
9D075008  8FA500C8   LW A1, 200(SP)
9D07500C  00A00811   MTHI A1
9D075010  8FA500C4   LW A1, 196(SP)
9D075014  00A01013   MTLO A1
9D075018  8FA500C0   LW A1, 192(SP)
9D07501C  00A01011   MTHI A1
9D075020  8FA500BC   LW A1, 188(SP)
9D075024  00A01813   MTLO A1
9D075028  8FA500B8   LW A1, 184(SP)
9D07502C  00A01811   MTHI A1
9D075030  D7B300A8   LDC1 F19, 168(SP)
9D075034  D7B200A0   LDC1 F18, 160(SP)
9D075038  D7B10098   LDC1 F17, 152(SP)
9D07503C  D7B00090   LDC1 F16, 144(SP)
9D075040  D7AF0088   LDC1 F15, 136(SP)
9D075044  D7AE0080   LDC1 F14, 128(SP)
9D075048  D7AD0078   LDC1 F13, 120(SP)
9D07504C  D7AC0070   LDC1 F12, 112(SP)
9D075050  D7AB0068   LDC1 F11, 104(SP)
9D075054  D7AA0060   LDC1 F10, 96(SP)
9D075058  D7A90058   LDC1 F9, 88(SP)
9D07505C  D7A80050   LDC1 F8, 80(SP)
9D075060  D7A70048   LDC1 F7, 72(SP)
9D075064  D7A60040   LDC1 F6, 64(SP)
9D075068  D7A50038   LDC1 F5, 56(SP)
9D07506C  D7A40030   LDC1 F4, 48(SP)
9D075070  D7A30028   LDC1 F3, 40(SP)
9D075074  D7A20020   LDC1 F2, 32(SP)
9D075078  D7A10018   LDC1 F1, 24(SP)
9D07507C  D7A00010   LDC1 F0, 16(SP)
9D075080  41606000   DI ZERO
9D075084  000000C0   EHB
9D075088  8FBB00DC   LW K1, 220(SP)
9D07508C  8FBA00E4   LW K0, 228(SP)
9D075090  409B6002   MTC0 K1, SRSCtl
9D075094  8FBB00E0   LW K1, 224(SP)
9D075098  409A7000   MTC0 K0, EPC
9D07509C  27BD00E8   ADDIU SP, SP, 232
9D0750A0  41DDE800   WRPGPR SP, SP
9D0750A4  409B6000   MTC0 K1, Status
9D0750A8  42000018   ERET
79:                  
80:                  void __ISR(_SPI1_RX_VECTOR, ipl1SRS) SPI1_RX_Handler (void)
81:                  {
9D0750AC  415DE800   RDPGPR SP, SP
9D0750B0  401A7000   MFC0 K0, EPC
9D0750B4  401B6000   MFC0 K1, Status
9D0750B8  27BDFF18   ADDIU SP, SP, -232
9D0750BC  AFBA00E4   SW K0, 228(SP)
9D0750C0  401A6002   MFC0 K0, SRSCtl
9D0750C4  AFBB00E0   SW K1, 224(SP)
9D0750C8  AFBA00DC   SW K0, 220(SP)
9D0750CC  7C1B7844   INS K1, ZERO, 1, 15
9D0750D0  377B0400   ORI K1, K1, 1024
9D0750D4  409B6000   MTC0 K1, Status
9D0750D8  F7B300A8   SDC1 F19, 168(SP)
9D0750DC  F7B200A0   SDC1 F18, 160(SP)
9D0750E0  F7B10098   SDC1 F17, 152(SP)
9D0750E4  F7B00090   SDC1 F16, 144(SP)
9D0750E8  F7AF0088   SDC1 F15, 136(SP)
9D0750EC  F7AE0080   SDC1 F14, 128(SP)
9D0750F0  F7AD0078   SDC1 F13, 120(SP)
9D0750F4  F7AC0070   SDC1 F12, 112(SP)
9D0750F8  F7AB0068   SDC1 F11, 104(SP)
9D0750FC  F7AA0060   SDC1 F10, 96(SP)
9D075100  F7A90058   SDC1 F9, 88(SP)
9D075104  F7A80050   SDC1 F8, 80(SP)
9D075108  F7A70048   SDC1 F7, 72(SP)
9D07510C  F7A60040   SDC1 F6, 64(SP)
9D075110  F7A50038   SDC1 F5, 56(SP)
9D075114  F7A40030   SDC1 F4, 48(SP)
9D075118  F7A30028   SDC1 F3, 40(SP)
9D07511C  F7A20020   SDC1 F2, 32(SP)
9D075120  F7A10018   SDC1 F1, 24(SP)
9D075124  F7A00010   SDC1 F0, 16(SP)
9D075128  00001012   MFLO V0
9D07512C  AFA200D4   SW V0, 212(SP)
9D075130  00001810   MFHI V1
9D075134  AFA300D0   SW V1, 208(SP)
9D075138  00201012   MFLO V0
9D07513C  AFA200CC   SW V0, 204(SP)
9D075140  00201810   MFHI V1
9D075144  AFA300C8   SW V1, 200(SP)
9D075148  00401012   MFLO V0
9D07514C  AFA200C4   SW V0, 196(SP)
9D075150  00401810   MFHI V1
9D075154  AFA300C0   SW V1, 192(SP)
9D075158  00601012   MFLO V0
9D07515C  AFA200BC   SW V0, 188(SP)
9D075160  00601810   MFHI V1
9D075164  AFA300B8   SW V1, 184(SP)
9D075168  7C3F1CB8   RDDSP V1, 0x3F
9D07516C  AFA300D8   SW V1, 216(SP)
9D075170  4442F800   CFC1 V0, F31
9D075174  AFA200B4   SW V0, 180(SP)
82:                      SPI1_RX_InterruptHandler();
9D075178  0F41D18F   JAL SPI1_RX_InterruptHandler
9D07517C  00000000   NOP
83:                  }
9D075180  8FA200B4   LW V0, 180(SP)
9D075184  44C2F800   CTC1 V0, F31
9D075188  8FA300D8   LW V1, 216(SP)
9D07518C  7C61FCF8   WRDSP V1, 0x3F
9D075190  8FA200D4   LW V0, 212(SP)
9D075194  00400013   MTLO V0
9D075198  8FA300D0   LW V1, 208(SP)
9D07519C  00600011   MTHI V1
9D0751A0  8FA500CC   LW A1, 204(SP)
9D0751A4  00A00813   MTLO A1
9D0751A8  8FA500C8   LW A1, 200(SP)
9D0751AC  00A00811   MTHI A1
9D0751B0  8FA500C4   LW A1, 196(SP)
9D0751B4  00A01013   MTLO A1
9D0751B8  8FA500C0   LW A1, 192(SP)
9D0751BC  00A01011   MTHI A1
9D0751C0  8FA500BC   LW A1, 188(SP)
9D0751C4  00A01813   MTLO A1
9D0751C8  8FA500B8   LW A1, 184(SP)
9D0751CC  00A01811   MTHI A1
9D0751D0  D7B300A8   LDC1 F19, 168(SP)
9D0751D4  D7B200A0   LDC1 F18, 160(SP)
9D0751D8  D7B10098   LDC1 F17, 152(SP)
9D0751DC  D7B00090   LDC1 F16, 144(SP)
9D0751E0  D7AF0088   LDC1 F15, 136(SP)
9D0751E4  D7AE0080   LDC1 F14, 128(SP)
9D0751E8  D7AD0078   LDC1 F13, 120(SP)
9D0751EC  D7AC0070   LDC1 F12, 112(SP)
9D0751F0  D7AB0068   LDC1 F11, 104(SP)
9D0751F4  D7AA0060   LDC1 F10, 96(SP)
9D0751F8  D7A90058   LDC1 F9, 88(SP)
9D0751FC  D7A80050   LDC1 F8, 80(SP)
9D075200  D7A70048   LDC1 F7, 72(SP)
9D075204  D7A60040   LDC1 F6, 64(SP)
9D075208  D7A50038   LDC1 F5, 56(SP)
9D07520C  D7A40030   LDC1 F4, 48(SP)
9D075210  D7A30028   LDC1 F3, 40(SP)
9D075214  D7A20020   LDC1 F2, 32(SP)
9D075218  D7A10018   LDC1 F1, 24(SP)
9D07521C  D7A00010   LDC1 F0, 16(SP)
9D075220  41606000   DI ZERO
9D075224  000000C0   EHB
9D075228  8FBB00DC   LW K1, 220(SP)
9D07522C  8FBA00E4   LW K0, 228(SP)
9D075230  409B6002   MTC0 K1, SRSCtl
9D075234  8FBB00E0   LW K1, 224(SP)
9D075238  409A7000   MTC0 K0, EPC
9D07523C  27BD00E8   ADDIU SP, SP, 232
9D075240  41DDE800   WRPGPR SP, SP
9D075244  409B6000   MTC0 K1, Status
9D075248  42000018   ERET
84:                  
85:                  void __ISR(_SPI1_TX_VECTOR, ipl1SRS) SPI1_TX_Handler (void)
86:                  {
9D07524C  415DE800   RDPGPR SP, SP
9D075250  401A7000   MFC0 K0, EPC
9D075254  401B6000   MFC0 K1, Status
9D075258  27BDFF18   ADDIU SP, SP, -232
9D07525C  AFBA00E4   SW K0, 228(SP)
9D075260  401A6002   MFC0 K0, SRSCtl
9D075264  AFBB00E0   SW K1, 224(SP)
9D075268  AFBA00DC   SW K0, 220(SP)
9D07526C  7C1B7844   INS K1, ZERO, 1, 15
9D075270  377B0400   ORI K1, K1, 1024
9D075274  409B6000   MTC0 K1, Status
9D075278  F7B300A8   SDC1 F19, 168(SP)
9D07527C  F7B200A0   SDC1 F18, 160(SP)
9D075280  F7B10098   SDC1 F17, 152(SP)
9D075284  F7B00090   SDC1 F16, 144(SP)
9D075288  F7AF0088   SDC1 F15, 136(SP)
9D07528C  F7AE0080   SDC1 F14, 128(SP)
9D075290  F7AD0078   SDC1 F13, 120(SP)
9D075294  F7AC0070   SDC1 F12, 112(SP)
9D075298  F7AB0068   SDC1 F11, 104(SP)
9D07529C  F7AA0060   SDC1 F10, 96(SP)
9D0752A0  F7A90058   SDC1 F9, 88(SP)
9D0752A4  F7A80050   SDC1 F8, 80(SP)
9D0752A8  F7A70048   SDC1 F7, 72(SP)
9D0752AC  F7A60040   SDC1 F6, 64(SP)
9D0752B0  F7A50038   SDC1 F5, 56(SP)
9D0752B4  F7A40030   SDC1 F4, 48(SP)
9D0752B8  F7A30028   SDC1 F3, 40(SP)
9D0752BC  F7A20020   SDC1 F2, 32(SP)
9D0752C0  F7A10018   SDC1 F1, 24(SP)
9D0752C4  F7A00010   SDC1 F0, 16(SP)
9D0752C8  00001012   MFLO V0
9D0752CC  AFA200D4   SW V0, 212(SP)
9D0752D0  00001810   MFHI V1
9D0752D4  AFA300D0   SW V1, 208(SP)
9D0752D8  00201012   MFLO V0
9D0752DC  AFA200CC   SW V0, 204(SP)
9D0752E0  00201810   MFHI V1
9D0752E4  AFA300C8   SW V1, 200(SP)
9D0752E8  00401012   MFLO V0
9D0752EC  AFA200C4   SW V0, 196(SP)
9D0752F0  00401810   MFHI V1
9D0752F4  AFA300C0   SW V1, 192(SP)
9D0752F8  00601012   MFLO V0
9D0752FC  AFA200BC   SW V0, 188(SP)
9D075300  00601810   MFHI V1
9D075304  AFA300B8   SW V1, 184(SP)
9D075308  7C3F1CB8   RDDSP V1, 0x3F
9D07530C  AFA300D8   SW V1, 216(SP)
9D075310  4442F800   CFC1 V0, F31
9D075314  AFA200B4   SW V0, 180(SP)
87:                      SPI1_TX_InterruptHandler();
9D075318  0F41DC1D   JAL SPI1_TX_InterruptHandler
9D07531C  00000000   NOP
88:                  }
9D075320  8FA200B4   LW V0, 180(SP)
9D075324  44C2F800   CTC1 V0, F31
9D075328  8FA300D8   LW V1, 216(SP)
9D07532C  7C61FCF8   WRDSP V1, 0x3F
9D075330  8FA200D4   LW V0, 212(SP)
9D075334  00400013   MTLO V0
9D075338  8FA300D0   LW V1, 208(SP)
9D07533C  00600011   MTHI V1
9D075340  8FA500CC   LW A1, 204(SP)
9D075344  00A00813   MTLO A1
9D075348  8FA500C8   LW A1, 200(SP)
9D07534C  00A00811   MTHI A1
9D075350  8FA500C4   LW A1, 196(SP)
9D075354  00A01013   MTLO A1
9D075358  8FA500C0   LW A1, 192(SP)
9D07535C  00A01011   MTHI A1
9D075360  8FA500BC   LW A1, 188(SP)
9D075364  00A01813   MTLO A1
9D075368  8FA500B8   LW A1, 184(SP)
9D07536C  00A01811   MTHI A1
9D075370  D7B300A8   LDC1 F19, 168(SP)
9D075374  D7B200A0   LDC1 F18, 160(SP)
9D075378  D7B10098   LDC1 F17, 152(SP)
9D07537C  D7B00090   LDC1 F16, 144(SP)
9D075380  D7AF0088   LDC1 F15, 136(SP)
9D075384  D7AE0080   LDC1 F14, 128(SP)
9D075388  D7AD0078   LDC1 F13, 120(SP)
9D07538C  D7AC0070   LDC1 F12, 112(SP)
9D075390  D7AB0068   LDC1 F11, 104(SP)
9D075394  D7AA0060   LDC1 F10, 96(SP)
9D075398  D7A90058   LDC1 F9, 88(SP)
9D07539C  D7A80050   LDC1 F8, 80(SP)
9D0753A0  D7A70048   LDC1 F7, 72(SP)
9D0753A4  D7A60040   LDC1 F6, 64(SP)
9D0753A8  D7A50038   LDC1 F5, 56(SP)
9D0753AC  D7A40030   LDC1 F4, 48(SP)
9D0753B0  D7A30028   LDC1 F3, 40(SP)
9D0753B4  D7A20020   LDC1 F2, 32(SP)
9D0753B8  D7A10018   LDC1 F1, 24(SP)
9D0753BC  D7A00010   LDC1 F0, 16(SP)
9D0753C0  41606000   DI ZERO
9D0753C4  000000C0   EHB
9D0753C8  8FBB00DC   LW K1, 220(SP)
9D0753CC  8FBA00E4   LW K0, 228(SP)
9D0753D0  409B6002   MTC0 K1, SRSCtl
9D0753D4  8FBB00E0   LW K1, 224(SP)
9D0753D8  409A7000   MTC0 K0, EPC
9D0753DC  27BD00E8   ADDIU SP, SP, 232
9D0753E0  41DDE800   WRPGPR SP, SP
9D0753E4  409B6000   MTC0 K1, Status
9D0753E8  42000018   ERET
89:                  
90:                  void __ISR(_UART1_FAULT_VECTOR, ipl1SRS) UART1_FAULT_Handler (void)
91:                  {
9D0753EC  415DE800   RDPGPR SP, SP
9D0753F0  401A7000   MFC0 K0, EPC
9D0753F4  401B6000   MFC0 K1, Status
9D0753F8  27BDFF18   ADDIU SP, SP, -232
9D0753FC  AFBA00E4   SW K0, 228(SP)
9D075400  401A6002   MFC0 K0, SRSCtl
9D075404  AFBB00E0   SW K1, 224(SP)
9D075408  AFBA00DC   SW K0, 220(SP)
9D07540C  7C1B7844   INS K1, ZERO, 1, 15
9D075410  377B0400   ORI K1, K1, 1024
9D075414  409B6000   MTC0 K1, Status
9D075418  F7B300A8   SDC1 F19, 168(SP)
9D07541C  F7B200A0   SDC1 F18, 160(SP)
9D075420  F7B10098   SDC1 F17, 152(SP)
9D075424  F7B00090   SDC1 F16, 144(SP)
9D075428  F7AF0088   SDC1 F15, 136(SP)
9D07542C  F7AE0080   SDC1 F14, 128(SP)
9D075430  F7AD0078   SDC1 F13, 120(SP)
9D075434  F7AC0070   SDC1 F12, 112(SP)
9D075438  F7AB0068   SDC1 F11, 104(SP)
9D07543C  F7AA0060   SDC1 F10, 96(SP)
9D075440  F7A90058   SDC1 F9, 88(SP)
9D075444  F7A80050   SDC1 F8, 80(SP)
9D075448  F7A70048   SDC1 F7, 72(SP)
9D07544C  F7A60040   SDC1 F6, 64(SP)
9D075450  F7A50038   SDC1 F5, 56(SP)
9D075454  F7A40030   SDC1 F4, 48(SP)
9D075458  F7A30028   SDC1 F3, 40(SP)
9D07545C  F7A20020   SDC1 F2, 32(SP)
9D075460  F7A10018   SDC1 F1, 24(SP)
9D075464  F7A00010   SDC1 F0, 16(SP)
9D075468  00001012   MFLO V0
9D07546C  AFA200D4   SW V0, 212(SP)
9D075470  00001810   MFHI V1
9D075474  AFA300D0   SW V1, 208(SP)
9D075478  00201012   MFLO V0
9D07547C  AFA200CC   SW V0, 204(SP)
9D075480  00201810   MFHI V1
9D075484  AFA300C8   SW V1, 200(SP)
9D075488  00401012   MFLO V0
9D07548C  AFA200C4   SW V0, 196(SP)
9D075490  00401810   MFHI V1
9D075494  AFA300C0   SW V1, 192(SP)
9D075498  00601012   MFLO V0
9D07549C  AFA200BC   SW V0, 188(SP)
9D0754A0  00601810   MFHI V1
9D0754A4  AFA300B8   SW V1, 184(SP)
9D0754A8  7C3F1CB8   RDDSP V1, 0x3F
9D0754AC  AFA300D8   SW V1, 216(SP)
9D0754B0  4442F800   CFC1 V0, F31
9D0754B4  AFA200B4   SW V0, 180(SP)
92:                      UART1_FAULT_InterruptHandler();
9D0754B8  0F41E368   JAL UART1_FAULT_InterruptHandler
9D0754BC  00000000   NOP
93:                  }
9D0754C0  8FA200B4   LW V0, 180(SP)
9D0754C4  44C2F800   CTC1 V0, F31
9D0754C8  8FA300D8   LW V1, 216(SP)
9D0754CC  7C61FCF8   WRDSP V1, 0x3F
9D0754D0  8FA200D4   LW V0, 212(SP)
9D0754D4  00400013   MTLO V0
9D0754D8  8FA300D0   LW V1, 208(SP)
9D0754DC  00600011   MTHI V1
9D0754E0  8FA500CC   LW A1, 204(SP)
9D0754E4  00A00813   MTLO A1
9D0754E8  8FA500C8   LW A1, 200(SP)
9D0754EC  00A00811   MTHI A1
9D0754F0  8FA500C4   LW A1, 196(SP)
9D0754F4  00A01013   MTLO A1
9D0754F8  8FA500C0   LW A1, 192(SP)
9D0754FC  00A01011   MTHI A1
9D075500  8FA500BC   LW A1, 188(SP)
9D075504  00A01813   MTLO A1
9D075508  8FA500B8   LW A1, 184(SP)
9D07550C  00A01811   MTHI A1
9D075510  D7B300A8   LDC1 F19, 168(SP)
9D075514  D7B200A0   LDC1 F18, 160(SP)
9D075518  D7B10098   LDC1 F17, 152(SP)
9D07551C  D7B00090   LDC1 F16, 144(SP)
9D075520  D7AF0088   LDC1 F15, 136(SP)
9D075524  D7AE0080   LDC1 F14, 128(SP)
9D075528  D7AD0078   LDC1 F13, 120(SP)
9D07552C  D7AC0070   LDC1 F12, 112(SP)
9D075530  D7AB0068   LDC1 F11, 104(SP)
9D075534  D7AA0060   LDC1 F10, 96(SP)
9D075538  D7A90058   LDC1 F9, 88(SP)
9D07553C  D7A80050   LDC1 F8, 80(SP)
9D075540  D7A70048   LDC1 F7, 72(SP)
9D075544  D7A60040   LDC1 F6, 64(SP)
9D075548  D7A50038   LDC1 F5, 56(SP)
9D07554C  D7A40030   LDC1 F4, 48(SP)
9D075550  D7A30028   LDC1 F3, 40(SP)
9D075554  D7A20020   LDC1 F2, 32(SP)
9D075558  D7A10018   LDC1 F1, 24(SP)
9D07555C  D7A00010   LDC1 F0, 16(SP)
9D075560  41606000   DI ZERO
9D075564  000000C0   EHB
9D075568  8FBB00DC   LW K1, 220(SP)
9D07556C  8FBA00E4   LW K0, 228(SP)
9D075570  409B6002   MTC0 K1, SRSCtl
9D075574  8FBB00E0   LW K1, 224(SP)
9D075578  409A7000   MTC0 K0, EPC
9D07557C  27BD00E8   ADDIU SP, SP, 232
9D075580  41DDE800   WRPGPR SP, SP
9D075584  409B6000   MTC0 K1, Status
9D075588  42000018   ERET
94:                  
95:                  void __ISR(_UART1_RX_VECTOR, ipl1SRS) UART1_RX_Handler (void)
96:                  {
9D07558C  415DE800   RDPGPR SP, SP
9D075590  401A7000   MFC0 K0, EPC
9D075594  401B6000   MFC0 K1, Status
9D075598  27BDFF18   ADDIU SP, SP, -232
9D07559C  AFBA00E4   SW K0, 228(SP)
9D0755A0  401A6002   MFC0 K0, SRSCtl
9D0755A4  AFBB00E0   SW K1, 224(SP)
9D0755A8  AFBA00DC   SW K0, 220(SP)
9D0755AC  7C1B7844   INS K1, ZERO, 1, 15
9D0755B0  377B0400   ORI K1, K1, 1024
9D0755B4  409B6000   MTC0 K1, Status
9D0755B8  F7B300A8   SDC1 F19, 168(SP)
9D0755BC  F7B200A0   SDC1 F18, 160(SP)
9D0755C0  F7B10098   SDC1 F17, 152(SP)
9D0755C4  F7B00090   SDC1 F16, 144(SP)
9D0755C8  F7AF0088   SDC1 F15, 136(SP)
9D0755CC  F7AE0080   SDC1 F14, 128(SP)
9D0755D0  F7AD0078   SDC1 F13, 120(SP)
9D0755D4  F7AC0070   SDC1 F12, 112(SP)
9D0755D8  F7AB0068   SDC1 F11, 104(SP)
9D0755DC  F7AA0060   SDC1 F10, 96(SP)
9D0755E0  F7A90058   SDC1 F9, 88(SP)
9D0755E4  F7A80050   SDC1 F8, 80(SP)
9D0755E8  F7A70048   SDC1 F7, 72(SP)
9D0755EC  F7A60040   SDC1 F6, 64(SP)
9D0755F0  F7A50038   SDC1 F5, 56(SP)
9D0755F4  F7A40030   SDC1 F4, 48(SP)
9D0755F8  F7A30028   SDC1 F3, 40(SP)
9D0755FC  F7A20020   SDC1 F2, 32(SP)
9D075600  F7A10018   SDC1 F1, 24(SP)
9D075604  F7A00010   SDC1 F0, 16(SP)
9D075608  00001012   MFLO V0
9D07560C  AFA200D4   SW V0, 212(SP)
9D075610  00001810   MFHI V1
9D075614  AFA300D0   SW V1, 208(SP)
9D075618  00201012   MFLO V0
9D07561C  AFA200CC   SW V0, 204(SP)
9D075620  00201810   MFHI V1
9D075624  AFA300C8   SW V1, 200(SP)
9D075628  00401012   MFLO V0
9D07562C  AFA200C4   SW V0, 196(SP)
9D075630  00401810   MFHI V1
9D075634  AFA300C0   SW V1, 192(SP)
9D075638  00601012   MFLO V0
9D07563C  AFA200BC   SW V0, 188(SP)
9D075640  00601810   MFHI V1
9D075644  AFA300B8   SW V1, 184(SP)
9D075648  7C3F1CB8   RDDSP V1, 0x3F
9D07564C  AFA300D8   SW V1, 216(SP)
9D075650  4442F800   CFC1 V0, F31
9D075654  AFA200B4   SW V0, 180(SP)
97:                      UART1_RX_InterruptHandler();
9D075658  0F41DA50   JAL UART1_RX_InterruptHandler
9D07565C  00000000   NOP
98:                  }
9D075660  8FA200B4   LW V0, 180(SP)
9D075664  44C2F800   CTC1 V0, F31
9D075668  8FA300D8   LW V1, 216(SP)
9D07566C  7C61FCF8   WRDSP V1, 0x3F
9D075670  8FA200D4   LW V0, 212(SP)
9D075674  00400013   MTLO V0
9D075678  8FA300D0   LW V1, 208(SP)
9D07567C  00600011   MTHI V1
9D075680  8FA500CC   LW A1, 204(SP)
9D075684  00A00813   MTLO A1
9D075688  8FA500C8   LW A1, 200(SP)
9D07568C  00A00811   MTHI A1
9D075690  8FA500C4   LW A1, 196(SP)
9D075694  00A01013   MTLO A1
9D075698  8FA500C0   LW A1, 192(SP)
9D07569C  00A01011   MTHI A1
9D0756A0  8FA500BC   LW A1, 188(SP)
9D0756A4  00A01813   MTLO A1
9D0756A8  8FA500B8   LW A1, 184(SP)
9D0756AC  00A01811   MTHI A1
9D0756B0  D7B300A8   LDC1 F19, 168(SP)
9D0756B4  D7B200A0   LDC1 F18, 160(SP)
9D0756B8  D7B10098   LDC1 F17, 152(SP)
9D0756BC  D7B00090   LDC1 F16, 144(SP)
9D0756C0  D7AF0088   LDC1 F15, 136(SP)
9D0756C4  D7AE0080   LDC1 F14, 128(SP)
9D0756C8  D7AD0078   LDC1 F13, 120(SP)
9D0756CC  D7AC0070   LDC1 F12, 112(SP)
9D0756D0  D7AB0068   LDC1 F11, 104(SP)
9D0756D4  D7AA0060   LDC1 F10, 96(SP)
9D0756D8  D7A90058   LDC1 F9, 88(SP)
9D0756DC  D7A80050   LDC1 F8, 80(SP)
9D0756E0  D7A70048   LDC1 F7, 72(SP)
9D0756E4  D7A60040   LDC1 F6, 64(SP)
9D0756E8  D7A50038   LDC1 F5, 56(SP)
9D0756EC  D7A40030   LDC1 F4, 48(SP)
9D0756F0  D7A30028   LDC1 F3, 40(SP)
9D0756F4  D7A20020   LDC1 F2, 32(SP)
9D0756F8  D7A10018   LDC1 F1, 24(SP)
9D0756FC  D7A00010   LDC1 F0, 16(SP)
9D075700  41606000   DI ZERO
9D075704  000000C0   EHB
9D075708  8FBB00DC   LW K1, 220(SP)
9D07570C  8FBA00E4   LW K0, 228(SP)
9D075710  409B6002   MTC0 K1, SRSCtl
9D075714  8FBB00E0   LW K1, 224(SP)
9D075718  409A7000   MTC0 K0, EPC
9D07571C  27BD00E8   ADDIU SP, SP, 232
9D075720  41DDE800   WRPGPR SP, SP
9D075724  409B6000   MTC0 K1, Status
9D075728  42000018   ERET
99:                  
100:                 void __ISR(_UART1_TX_VECTOR, ipl1SRS) UART1_TX_Handler (void)
101:                 {
9D07572C  415DE800   RDPGPR SP, SP
9D075730  401A7000   MFC0 K0, EPC
9D075734  401B6000   MFC0 K1, Status
9D075738  27BDFF18   ADDIU SP, SP, -232
9D07573C  AFBA00E4   SW K0, 228(SP)
9D075740  401A6002   MFC0 K0, SRSCtl
9D075744  AFBB00E0   SW K1, 224(SP)
9D075748  AFBA00DC   SW K0, 220(SP)
9D07574C  7C1B7844   INS K1, ZERO, 1, 15
9D075750  377B0400   ORI K1, K1, 1024
9D075754  409B6000   MTC0 K1, Status
9D075758  F7B300A8   SDC1 F19, 168(SP)
9D07575C  F7B200A0   SDC1 F18, 160(SP)
9D075760  F7B10098   SDC1 F17, 152(SP)
9D075764  F7B00090   SDC1 F16, 144(SP)
9D075768  F7AF0088   SDC1 F15, 136(SP)
9D07576C  F7AE0080   SDC1 F14, 128(SP)
9D075770  F7AD0078   SDC1 F13, 120(SP)
9D075774  F7AC0070   SDC1 F12, 112(SP)
9D075778  F7AB0068   SDC1 F11, 104(SP)
9D07577C  F7AA0060   SDC1 F10, 96(SP)
9D075780  F7A90058   SDC1 F9, 88(SP)
9D075784  F7A80050   SDC1 F8, 80(SP)
9D075788  F7A70048   SDC1 F7, 72(SP)
9D07578C  F7A60040   SDC1 F6, 64(SP)
9D075790  F7A50038   SDC1 F5, 56(SP)
9D075794  F7A40030   SDC1 F4, 48(SP)
9D075798  F7A30028   SDC1 F3, 40(SP)
9D07579C  F7A20020   SDC1 F2, 32(SP)
9D0757A0  F7A10018   SDC1 F1, 24(SP)
9D0757A4  F7A00010   SDC1 F0, 16(SP)
9D0757A8  00001012   MFLO V0
9D0757AC  AFA200D4   SW V0, 212(SP)
9D0757B0  00001810   MFHI V1
9D0757B4  AFA300D0   SW V1, 208(SP)
9D0757B8  00201012   MFLO V0
9D0757BC  AFA200CC   SW V0, 204(SP)
9D0757C0  00201810   MFHI V1
9D0757C4  AFA300C8   SW V1, 200(SP)
9D0757C8  00401012   MFLO V0
9D0757CC  AFA200C4   SW V0, 196(SP)
9D0757D0  00401810   MFHI V1
9D0757D4  AFA300C0   SW V1, 192(SP)
9D0757D8  00601012   MFLO V0
9D0757DC  AFA200BC   SW V0, 188(SP)
9D0757E0  00601810   MFHI V1
9D0757E4  AFA300B8   SW V1, 184(SP)
9D0757E8  7C3F1CB8   RDDSP V1, 0x3F
9D0757EC  AFA300D8   SW V1, 216(SP)
9D0757F0  4442F800   CFC1 V0, F31
9D0757F4  AFA200B4   SW V0, 180(SP)
102:                     UART1_TX_InterruptHandler();
9D0757F8  0F41D7D3   JAL UART1_TX_InterruptHandler
9D0757FC  00000000   NOP
103:                 }
9D075800  8FA200B4   LW V0, 180(SP)
9D075804  44C2F800   CTC1 V0, F31
9D075808  8FA300D8   LW V1, 216(SP)
9D07580C  7C61FCF8   WRDSP V1, 0x3F
9D075810  8FA200D4   LW V0, 212(SP)
9D075814  00400013   MTLO V0
9D075818  8FA300D0   LW V1, 208(SP)
9D07581C  00600011   MTHI V1
9D075820  8FA500CC   LW A1, 204(SP)
9D075824  00A00813   MTLO A1
9D075828  8FA500C8   LW A1, 200(SP)
9D07582C  00A00811   MTHI A1
9D075830  8FA500C4   LW A1, 196(SP)
9D075834  00A01013   MTLO A1
9D075838  8FA500C0   LW A1, 192(SP)
9D07583C  00A01011   MTHI A1
9D075840  8FA500BC   LW A1, 188(SP)
9D075844  00A01813   MTLO A1
9D075848  8FA500B8   LW A1, 184(SP)
9D07584C  00A01811   MTHI A1
9D075850  D7B300A8   LDC1 F19, 168(SP)
9D075854  D7B200A0   LDC1 F18, 160(SP)
9D075858  D7B10098   LDC1 F17, 152(SP)
9D07585C  D7B00090   LDC1 F16, 144(SP)
9D075860  D7AF0088   LDC1 F15, 136(SP)
9D075864  D7AE0080   LDC1 F14, 128(SP)
9D075868  D7AD0078   LDC1 F13, 120(SP)
9D07586C  D7AC0070   LDC1 F12, 112(SP)
9D075870  D7AB0068   LDC1 F11, 104(SP)
9D075874  D7AA0060   LDC1 F10, 96(SP)
9D075878  D7A90058   LDC1 F9, 88(SP)
9D07587C  D7A80050   LDC1 F8, 80(SP)
9D075880  D7A70048   LDC1 F7, 72(SP)
9D075884  D7A60040   LDC1 F6, 64(SP)
9D075888  D7A50038   LDC1 F5, 56(SP)
9D07588C  D7A40030   LDC1 F4, 48(SP)
9D075890  D7A30028   LDC1 F3, 40(SP)
9D075894  D7A20020   LDC1 F2, 32(SP)
9D075898  D7A10018   LDC1 F1, 24(SP)
9D07589C  D7A00010   LDC1 F0, 16(SP)
9D0758A0  41606000   DI ZERO
9D0758A4  000000C0   EHB
9D0758A8  8FBB00DC   LW K1, 220(SP)
9D0758AC  8FBA00E4   LW K0, 228(SP)
9D0758B0  409B6002   MTC0 K1, SRSCtl
9D0758B4  8FBB00E0   LW K1, 224(SP)
9D0758B8  409A7000   MTC0 K0, EPC
9D0758BC  27BD00E8   ADDIU SP, SP, 232
9D0758C0  41DDE800   WRPGPR SP, SP
9D0758C4  409B6000   MTC0 K1, Status
9D0758C8  42000018   ERET
104:                 
105:                 void __ISR(_UART2_FAULT_VECTOR, ipl1SRS) UART2_FAULT_Handler (void)
106:                 {
9D0758CC  415DE800   RDPGPR SP, SP
9D0758D0  401A7000   MFC0 K0, EPC
9D0758D4  401B6000   MFC0 K1, Status
9D0758D8  27BDFF18   ADDIU SP, SP, -232
9D0758DC  AFBA00E4   SW K0, 228(SP)
9D0758E0  401A6002   MFC0 K0, SRSCtl
9D0758E4  AFBB00E0   SW K1, 224(SP)
9D0758E8  AFBA00DC   SW K0, 220(SP)
9D0758EC  7C1B7844   INS K1, ZERO, 1, 15
9D0758F0  377B0400   ORI K1, K1, 1024
9D0758F4  409B6000   MTC0 K1, Status
9D0758F8  F7B300A8   SDC1 F19, 168(SP)
9D0758FC  F7B200A0   SDC1 F18, 160(SP)
9D075900  F7B10098   SDC1 F17, 152(SP)
9D075904  F7B00090   SDC1 F16, 144(SP)
9D075908  F7AF0088   SDC1 F15, 136(SP)
9D07590C  F7AE0080   SDC1 F14, 128(SP)
9D075910  F7AD0078   SDC1 F13, 120(SP)
9D075914  F7AC0070   SDC1 F12, 112(SP)
9D075918  F7AB0068   SDC1 F11, 104(SP)
9D07591C  F7AA0060   SDC1 F10, 96(SP)
9D075920  F7A90058   SDC1 F9, 88(SP)
9D075924  F7A80050   SDC1 F8, 80(SP)
9D075928  F7A70048   SDC1 F7, 72(SP)
9D07592C  F7A60040   SDC1 F6, 64(SP)
9D075930  F7A50038   SDC1 F5, 56(SP)
9D075934  F7A40030   SDC1 F4, 48(SP)
9D075938  F7A30028   SDC1 F3, 40(SP)
9D07593C  F7A20020   SDC1 F2, 32(SP)
9D075940  F7A10018   SDC1 F1, 24(SP)
9D075944  F7A00010   SDC1 F0, 16(SP)
9D075948  00001012   MFLO V0
9D07594C  AFA200D4   SW V0, 212(SP)
9D075950  00001810   MFHI V1
9D075954  AFA300D0   SW V1, 208(SP)
9D075958  00201012   MFLO V0
9D07595C  AFA200CC   SW V0, 204(SP)
9D075960  00201810   MFHI V1
9D075964  AFA300C8   SW V1, 200(SP)
9D075968  00401012   MFLO V0
9D07596C  AFA200C4   SW V0, 196(SP)
9D075970  00401810   MFHI V1
9D075974  AFA300C0   SW V1, 192(SP)
9D075978  00601012   MFLO V0
9D07597C  AFA200BC   SW V0, 188(SP)
9D075980  00601810   MFHI V1
9D075984  AFA300B8   SW V1, 184(SP)
9D075988  7C3F1CB8   RDDSP V1, 0x3F
9D07598C  AFA300D8   SW V1, 216(SP)
9D075990  4442F800   CFC1 V0, F31
9D075994  AFA200B4   SW V0, 180(SP)
107:                     UART2_FAULT_InterruptHandler();
9D075998  0F41E377   JAL UART2_FAULT_InterruptHandler
9D07599C  00000000   NOP
108:                 }
9D0759A0  8FA200B4   LW V0, 180(SP)
9D0759A4  44C2F800   CTC1 V0, F31
9D0759A8  8FA300D8   LW V1, 216(SP)
9D0759AC  7C61FCF8   WRDSP V1, 0x3F
9D0759B0  8FA200D4   LW V0, 212(SP)
9D0759B4  00400013   MTLO V0
9D0759B8  8FA300D0   LW V1, 208(SP)
9D0759BC  00600011   MTHI V1
9D0759C0  8FA500CC   LW A1, 204(SP)
9D0759C4  00A00813   MTLO A1
9D0759C8  8FA500C8   LW A1, 200(SP)
9D0759CC  00A00811   MTHI A1
9D0759D0  8FA500C4   LW A1, 196(SP)
9D0759D4  00A01013   MTLO A1
9D0759D8  8FA500C0   LW A1, 192(SP)
9D0759DC  00A01011   MTHI A1
9D0759E0  8FA500BC   LW A1, 188(SP)
9D0759E4  00A01813   MTLO A1
9D0759E8  8FA500B8   LW A1, 184(SP)
9D0759EC  00A01811   MTHI A1
9D0759F0  D7B300A8   LDC1 F19, 168(SP)
9D0759F4  D7B200A0   LDC1 F18, 160(SP)
9D0759F8  D7B10098   LDC1 F17, 152(SP)
9D0759FC  D7B00090   LDC1 F16, 144(SP)
9D075A00  D7AF0088   LDC1 F15, 136(SP)
9D075A04  D7AE0080   LDC1 F14, 128(SP)
9D075A08  D7AD0078   LDC1 F13, 120(SP)
9D075A0C  D7AC0070   LDC1 F12, 112(SP)
9D075A10  D7AB0068   LDC1 F11, 104(SP)
9D075A14  D7AA0060   LDC1 F10, 96(SP)
9D075A18  D7A90058   LDC1 F9, 88(SP)
9D075A1C  D7A80050   LDC1 F8, 80(SP)
9D075A20  D7A70048   LDC1 F7, 72(SP)
9D075A24  D7A60040   LDC1 F6, 64(SP)
9D075A28  D7A50038   LDC1 F5, 56(SP)
9D075A2C  D7A40030   LDC1 F4, 48(SP)
9D075A30  D7A30028   LDC1 F3, 40(SP)
9D075A34  D7A20020   LDC1 F2, 32(SP)
9D075A38  D7A10018   LDC1 F1, 24(SP)
9D075A3C  D7A00010   LDC1 F0, 16(SP)
9D075A40  41606000   DI ZERO
9D075A44  000000C0   EHB
9D075A48  8FBB00DC   LW K1, 220(SP)
9D075A4C  8FBA00E4   LW K0, 228(SP)
9D075A50  409B6002   MTC0 K1, SRSCtl
9D075A54  8FBB00E0   LW K1, 224(SP)
9D075A58  409A7000   MTC0 K0, EPC
9D075A5C  27BD00E8   ADDIU SP, SP, 232
9D075A60  41DDE800   WRPGPR SP, SP
9D075A64  409B6000   MTC0 K1, Status
9D075A68  42000018   ERET
109:                 
110:                 void __ISR(_UART2_RX_VECTOR, ipl1SRS) UART2_RX_Handler (void)
111:                 {
9D075A6C  415DE800   RDPGPR SP, SP
9D075A70  401A7000   MFC0 K0, EPC
9D075A74  401B6000   MFC0 K1, Status
9D075A78  27BDFF18   ADDIU SP, SP, -232
9D075A7C  AFBA00E4   SW K0, 228(SP)
9D075A80  401A6002   MFC0 K0, SRSCtl
9D075A84  AFBB00E0   SW K1, 224(SP)
9D075A88  AFBA00DC   SW K0, 220(SP)
9D075A8C  7C1B7844   INS K1, ZERO, 1, 15
9D075A90  377B0400   ORI K1, K1, 1024
9D075A94  409B6000   MTC0 K1, Status
9D075A98  F7B300A8   SDC1 F19, 168(SP)
9D075A9C  F7B200A0   SDC1 F18, 160(SP)
9D075AA0  F7B10098   SDC1 F17, 152(SP)
9D075AA4  F7B00090   SDC1 F16, 144(SP)
9D075AA8  F7AF0088   SDC1 F15, 136(SP)
9D075AAC  F7AE0080   SDC1 F14, 128(SP)
9D075AB0  F7AD0078   SDC1 F13, 120(SP)
9D075AB4  F7AC0070   SDC1 F12, 112(SP)
9D075AB8  F7AB0068   SDC1 F11, 104(SP)
9D075ABC  F7AA0060   SDC1 F10, 96(SP)
9D075AC0  F7A90058   SDC1 F9, 88(SP)
9D075AC4  F7A80050   SDC1 F8, 80(SP)
9D075AC8  F7A70048   SDC1 F7, 72(SP)
9D075ACC  F7A60040   SDC1 F6, 64(SP)
9D075AD0  F7A50038   SDC1 F5, 56(SP)
9D075AD4  F7A40030   SDC1 F4, 48(SP)
9D075AD8  F7A30028   SDC1 F3, 40(SP)
9D075ADC  F7A20020   SDC1 F2, 32(SP)
9D075AE0  F7A10018   SDC1 F1, 24(SP)
9D075AE4  F7A00010   SDC1 F0, 16(SP)
9D075AE8  00001012   MFLO V0
9D075AEC  AFA200D4   SW V0, 212(SP)
9D075AF0  00001810   MFHI V1
9D075AF4  AFA300D0   SW V1, 208(SP)
9D075AF8  00201012   MFLO V0
9D075AFC  AFA200CC   SW V0, 204(SP)
9D075B00  00201810   MFHI V1
9D075B04  AFA300C8   SW V1, 200(SP)
9D075B08  00401012   MFLO V0
9D075B0C  AFA200C4   SW V0, 196(SP)
9D075B10  00401810   MFHI V1
9D075B14  AFA300C0   SW V1, 192(SP)
9D075B18  00601012   MFLO V0
9D075B1C  AFA200BC   SW V0, 188(SP)
9D075B20  00601810   MFHI V1
9D075B24  AFA300B8   SW V1, 184(SP)
9D075B28  7C3F1CB8   RDDSP V1, 0x3F
9D075B2C  AFA300D8   SW V1, 216(SP)
9D075B30  4442F800   CFC1 V0, F31
9D075B34  AFA200B4   SW V0, 180(SP)
112:                     UART2_RX_InterruptHandler();
9D075B38  0F41DAA0   JAL UART2_RX_InterruptHandler
9D075B3C  00000000   NOP
113:                 }
9D075B40  8FA200B4   LW V0, 180(SP)
9D075B44  44C2F800   CTC1 V0, F31
9D075B48  8FA300D8   LW V1, 216(SP)
9D075B4C  7C61FCF8   WRDSP V1, 0x3F
9D075B50  8FA200D4   LW V0, 212(SP)
9D075B54  00400013   MTLO V0
9D075B58  8FA300D0   LW V1, 208(SP)
9D075B5C  00600011   MTHI V1
9D075B60  8FA500CC   LW A1, 204(SP)
9D075B64  00A00813   MTLO A1
9D075B68  8FA500C8   LW A1, 200(SP)
9D075B6C  00A00811   MTHI A1
9D075B70  8FA500C4   LW A1, 196(SP)
9D075B74  00A01013   MTLO A1
9D075B78  8FA500C0   LW A1, 192(SP)
9D075B7C  00A01011   MTHI A1
9D075B80  8FA500BC   LW A1, 188(SP)
9D075B84  00A01813   MTLO A1
9D075B88  8FA500B8   LW A1, 184(SP)
9D075B8C  00A01811   MTHI A1
9D075B90  D7B300A8   LDC1 F19, 168(SP)
9D075B94  D7B200A0   LDC1 F18, 160(SP)
9D075B98  D7B10098   LDC1 F17, 152(SP)
9D075B9C  D7B00090   LDC1 F16, 144(SP)
9D075BA0  D7AF0088   LDC1 F15, 136(SP)
9D075BA4  D7AE0080   LDC1 F14, 128(SP)
9D075BA8  D7AD0078   LDC1 F13, 120(SP)
9D075BAC  D7AC0070   LDC1 F12, 112(SP)
9D075BB0  D7AB0068   LDC1 F11, 104(SP)
9D075BB4  D7AA0060   LDC1 F10, 96(SP)
9D075BB8  D7A90058   LDC1 F9, 88(SP)
9D075BBC  D7A80050   LDC1 F8, 80(SP)
9D075BC0  D7A70048   LDC1 F7, 72(SP)
9D075BC4  D7A60040   LDC1 F6, 64(SP)
9D075BC8  D7A50038   LDC1 F5, 56(SP)
9D075BCC  D7A40030   LDC1 F4, 48(SP)
9D075BD0  D7A30028   LDC1 F3, 40(SP)
9D075BD4  D7A20020   LDC1 F2, 32(SP)
9D075BD8  D7A10018   LDC1 F1, 24(SP)
9D075BDC  D7A00010   LDC1 F0, 16(SP)
9D075BE0  41606000   DI ZERO
9D075BE4  000000C0   EHB
9D075BE8  8FBB00DC   LW K1, 220(SP)
9D075BEC  8FBA00E4   LW K0, 228(SP)
9D075BF0  409B6002   MTC0 K1, SRSCtl
9D075BF4  8FBB00E0   LW K1, 224(SP)
9D075BF8  409A7000   MTC0 K0, EPC
9D075BFC  27BD00E8   ADDIU SP, SP, 232
9D075C00  41DDE800   WRPGPR SP, SP
9D075C04  409B6000   MTC0 K1, Status
9D075C08  42000018   ERET
114:                 
115:                 void __ISR(_UART2_TX_VECTOR, ipl1SRS) UART2_TX_Handler (void)
116:                 {
9D075C0C  415DE800   RDPGPR SP, SP
9D075C10  401A7000   MFC0 K0, EPC
9D075C14  401B6000   MFC0 K1, Status
9D075C18  27BDFF18   ADDIU SP, SP, -232
9D075C1C  AFBA00E4   SW K0, 228(SP)
9D075C20  401A6002   MFC0 K0, SRSCtl
9D075C24  AFBB00E0   SW K1, 224(SP)
9D075C28  AFBA00DC   SW K0, 220(SP)
9D075C2C  7C1B7844   INS K1, ZERO, 1, 15
9D075C30  377B0400   ORI K1, K1, 1024
9D075C34  409B6000   MTC0 K1, Status
9D075C38  F7B300A8   SDC1 F19, 168(SP)
9D075C3C  F7B200A0   SDC1 F18, 160(SP)
9D075C40  F7B10098   SDC1 F17, 152(SP)
9D075C44  F7B00090   SDC1 F16, 144(SP)
9D075C48  F7AF0088   SDC1 F15, 136(SP)
9D075C4C  F7AE0080   SDC1 F14, 128(SP)
9D075C50  F7AD0078   SDC1 F13, 120(SP)
9D075C54  F7AC0070   SDC1 F12, 112(SP)
9D075C58  F7AB0068   SDC1 F11, 104(SP)
9D075C5C  F7AA0060   SDC1 F10, 96(SP)
9D075C60  F7A90058   SDC1 F9, 88(SP)
9D075C64  F7A80050   SDC1 F8, 80(SP)
9D075C68  F7A70048   SDC1 F7, 72(SP)
9D075C6C  F7A60040   SDC1 F6, 64(SP)
9D075C70  F7A50038   SDC1 F5, 56(SP)
9D075C74  F7A40030   SDC1 F4, 48(SP)
9D075C78  F7A30028   SDC1 F3, 40(SP)
9D075C7C  F7A20020   SDC1 F2, 32(SP)
9D075C80  F7A10018   SDC1 F1, 24(SP)
9D075C84  F7A00010   SDC1 F0, 16(SP)
9D075C88  00001012   MFLO V0
9D075C8C  AFA200D4   SW V0, 212(SP)
9D075C90  00001810   MFHI V1
9D075C94  AFA300D0   SW V1, 208(SP)
9D075C98  00201012   MFLO V0
9D075C9C  AFA200CC   SW V0, 204(SP)
9D075CA0  00201810   MFHI V1
9D075CA4  AFA300C8   SW V1, 200(SP)
9D075CA8  00401012   MFLO V0
9D075CAC  AFA200C4   SW V0, 196(SP)
9D075CB0  00401810   MFHI V1
9D075CB4  AFA300C0   SW V1, 192(SP)
9D075CB8  00601012   MFLO V0
9D075CBC  AFA200BC   SW V0, 188(SP)
9D075CC0  00601810   MFHI V1
9D075CC4  AFA300B8   SW V1, 184(SP)
9D075CC8  7C3F1CB8   RDDSP V1, 0x3F
9D075CCC  AFA300D8   SW V1, 216(SP)
9D075CD0  4442F800   CFC1 V0, F31
9D075CD4  AFA200B4   SW V0, 180(SP)
117:                     UART2_TX_InterruptHandler();
9D075CD8  0F400000   JAL UART2_TX_InterruptHandler
9D075CDC  00000000   NOP
118:                 }
9D075CE0  8FA200B4   LW V0, 180(SP)
9D075CE4  44C2F800   CTC1 V0, F31
9D075CE8  8FA300D8   LW V1, 216(SP)
9D075CEC  7C61FCF8   WRDSP V1, 0x3F
9D075CF0  8FA200D4   LW V0, 212(SP)
9D075CF4  00400013   MTLO V0
9D075CF8  8FA300D0   LW V1, 208(SP)
9D075CFC  00600011   MTHI V1
9D075D00  8FA500CC   LW A1, 204(SP)
9D075D04  00A00813   MTLO A1
9D075D08  8FA500C8   LW A1, 200(SP)
9D075D0C  00A00811   MTHI A1
9D075D10  8FA500C4   LW A1, 196(SP)
9D075D14  00A01013   MTLO A1
9D075D18  8FA500C0   LW A1, 192(SP)
9D075D1C  00A01011   MTHI A1
9D075D20  8FA500BC   LW A1, 188(SP)
9D075D24  00A01813   MTLO A1
9D075D28  8FA500B8   LW A1, 184(SP)
9D075D2C  00A01811   MTHI A1
9D075D30  D7B300A8   LDC1 F19, 168(SP)
9D075D34  D7B200A0   LDC1 F18, 160(SP)
9D075D38  D7B10098   LDC1 F17, 152(SP)
9D075D3C  D7B00090   LDC1 F16, 144(SP)
9D075D40  D7AF0088   LDC1 F15, 136(SP)
9D075D44  D7AE0080   LDC1 F14, 128(SP)
9D075D48  D7AD0078   LDC1 F13, 120(SP)
9D075D4C  D7AC0070   LDC1 F12, 112(SP)
9D075D50  D7AB0068   LDC1 F11, 104(SP)
9D075D54  D7AA0060   LDC1 F10, 96(SP)
9D075D58  D7A90058   LDC1 F9, 88(SP)
9D075D5C  D7A80050   LDC1 F8, 80(SP)
9D075D60  D7A70048   LDC1 F7, 72(SP)
9D075D64  D7A60040   LDC1 F6, 64(SP)
9D075D68  D7A50038   LDC1 F5, 56(SP)
9D075D6C  D7A40030   LDC1 F4, 48(SP)
9D075D70  D7A30028   LDC1 F3, 40(SP)
9D075D74  D7A20020   LDC1 F2, 32(SP)
9D075D78  D7A10018   LDC1 F1, 24(SP)
9D075D7C  D7A00010   LDC1 F0, 16(SP)
9D075D80  41606000   DI ZERO
9D075D84  000000C0   EHB
9D075D88  8FBB00DC   LW K1, 220(SP)
9D075D8C  8FBA00E4   LW K0, 228(SP)
9D075D90  409B6002   MTC0 K1, SRSCtl
9D075D94  8FBB00E0   LW K1, 224(SP)
9D075D98  409A7000   MTC0 K0, EPC
9D075D9C  27BD00E8   ADDIU SP, SP, 232
9D075DA0  41DDE800   WRPGPR SP, SP
9D075DA4  409B6000   MTC0 K1, Status
9D075DA8  42000018   ERET
119:                 
120:                 void __ISR(_CAN1_VECTOR, ipl1SRS) CAN1_Handler (void)
121:                 {
9D075DAC  415DE800   RDPGPR SP, SP
9D075DB0  401A7000   MFC0 K0, EPC
9D075DB4  401B6000   MFC0 K1, Status
9D075DB8  27BDFF18   ADDIU SP, SP, -232
9D075DBC  AFBA00E4   SW K0, 228(SP)
9D075DC0  401A6002   MFC0 K0, SRSCtl
9D075DC4  AFBB00E0   SW K1, 224(SP)
9D075DC8  AFBA00DC   SW K0, 220(SP)
9D075DCC  7C1B7844   INS K1, ZERO, 1, 15
9D075DD0  377B0400   ORI K1, K1, 1024
9D075DD4  409B6000   MTC0 K1, Status
9D075DD8  F7B300A8   SDC1 F19, 168(SP)
9D075DDC  F7B200A0   SDC1 F18, 160(SP)
9D075DE0  F7B10098   SDC1 F17, 152(SP)
9D075DE4  F7B00090   SDC1 F16, 144(SP)
9D075DE8  F7AF0088   SDC1 F15, 136(SP)
9D075DEC  F7AE0080   SDC1 F14, 128(SP)
9D075DF0  F7AD0078   SDC1 F13, 120(SP)
9D075DF4  F7AC0070   SDC1 F12, 112(SP)
9D075DF8  F7AB0068   SDC1 F11, 104(SP)
9D075DFC  F7AA0060   SDC1 F10, 96(SP)
9D075E00  F7A90058   SDC1 F9, 88(SP)
9D075E04  F7A80050   SDC1 F8, 80(SP)
9D075E08  F7A70048   SDC1 F7, 72(SP)
9D075E0C  F7A60040   SDC1 F6, 64(SP)
9D075E10  F7A50038   SDC1 F5, 56(SP)
9D075E14  F7A40030   SDC1 F4, 48(SP)
9D075E18  F7A30028   SDC1 F3, 40(SP)
9D075E1C  F7A20020   SDC1 F2, 32(SP)
9D075E20  F7A10018   SDC1 F1, 24(SP)
9D075E24  F7A00010   SDC1 F0, 16(SP)
9D075E28  00001012   MFLO V0
9D075E2C  AFA200D4   SW V0, 212(SP)
9D075E30  00001810   MFHI V1
9D075E34  AFA300D0   SW V1, 208(SP)
9D075E38  00201012   MFLO V0
9D075E3C  AFA200CC   SW V0, 204(SP)
9D075E40  00201810   MFHI V1
9D075E44  AFA300C8   SW V1, 200(SP)
9D075E48  00401012   MFLO V0
9D075E4C  AFA200C4   SW V0, 196(SP)
9D075E50  00401810   MFHI V1
9D075E54  AFA300C0   SW V1, 192(SP)
9D075E58  00601012   MFLO V0
9D075E5C  AFA200BC   SW V0, 188(SP)
9D075E60  00601810   MFHI V1
9D075E64  AFA300B8   SW V1, 184(SP)
9D075E68  7C3F1CB8   RDDSP V1, 0x3F
9D075E6C  AFA300D8   SW V1, 216(SP)
9D075E70  4442F800   CFC1 V0, F31
9D075E74  AFA200B4   SW V0, 180(SP)
122:                     CAN1_InterruptHandler();
9D075E78  0F41CEA7   JAL CAN1_InterruptHandler
9D075E7C  00000000   NOP
123:                 }
9D075E80  8FA200B4   LW V0, 180(SP)
9D075E84  44C2F800   CTC1 V0, F31
9D075E88  8FA300D8   LW V1, 216(SP)
9D075E8C  7C61FCF8   WRDSP V1, 0x3F
9D075E90  8FA200D4   LW V0, 212(SP)
9D075E94  00400013   MTLO V0
9D075E98  8FA300D0   LW V1, 208(SP)
9D075E9C  00600011   MTHI V1
9D075EA0  8FA500CC   LW A1, 204(SP)
9D075EA4  00A00813   MTLO A1
9D075EA8  8FA500C8   LW A1, 200(SP)
9D075EAC  00A00811   MTHI A1
9D075EB0  8FA500C4   LW A1, 196(SP)
9D075EB4  00A01013   MTLO A1
9D075EB8  8FA500C0   LW A1, 192(SP)
9D075EBC  00A01011   MTHI A1
9D075EC0  8FA500BC   LW A1, 188(SP)
9D075EC4  00A01813   MTLO A1
9D075EC8  8FA500B8   LW A1, 184(SP)
9D075ECC  00A01811   MTHI A1
9D075ED0  D7B300A8   LDC1 F19, 168(SP)
9D075ED4  D7B200A0   LDC1 F18, 160(SP)
9D075ED8  D7B10098   LDC1 F17, 152(SP)
9D075EDC  D7B00090   LDC1 F16, 144(SP)
9D075EE0  D7AF0088   LDC1 F15, 136(SP)
9D075EE4  D7AE0080   LDC1 F14, 128(SP)
9D075EE8  D7AD0078   LDC1 F13, 120(SP)
9D075EEC  D7AC0070   LDC1 F12, 112(SP)
9D075EF0  D7AB0068   LDC1 F11, 104(SP)
9D075EF4  D7AA0060   LDC1 F10, 96(SP)
9D075EF8  D7A90058   LDC1 F9, 88(SP)
9D075EFC  D7A80050   LDC1 F8, 80(SP)
9D075F00  D7A70048   LDC1 F7, 72(SP)
9D075F04  D7A60040   LDC1 F6, 64(SP)
9D075F08  D7A50038   LDC1 F5, 56(SP)
9D075F0C  D7A40030   LDC1 F4, 48(SP)
9D075F10  D7A30028   LDC1 F3, 40(SP)
9D075F14  D7A20020   LDC1 F2, 32(SP)
9D075F18  D7A10018   LDC1 F1, 24(SP)
9D075F1C  D7A00010   LDC1 F0, 16(SP)
9D075F20  41606000   DI ZERO
9D075F24  000000C0   EHB
9D075F28  8FBB00DC   LW K1, 220(SP)
9D075F2C  8FBA00E4   LW K0, 228(SP)
9D075F30  409B6002   MTC0 K1, SRSCtl
9D075F34  8FBB00E0   LW K1, 224(SP)
9D075F38  409A7000   MTC0 K0, EPC
9D075F3C  27BD00E8   ADDIU SP, SP, 232
9D075F40  41DDE800   WRPGPR SP, SP
9D075F44  409B6000   MTC0 K1, Status
9D075F48  42000018   ERET
124:                 
125:                 
126:                 
127:                 
128:                 /*******************************************************************************
129:                  End of File
130:                 */
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/initialization.c
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       initialization.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources,
14:                   *******************************************************************************/
15:                  
16:                  // DOM-IGNORE-BEGIN
17:                  /*******************************************************************************
18:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
19:                  *
20:                  * Subject to your compliance with these terms, you may use Microchip software
21:                  * and any derivatives exclusively with Microchip products. It is your
22:                  * responsibility to comply with third party license terms applicable to your
23:                  * use of third party software (including open source software) that may
24:                  * accompany Microchip software.
25:                  *
26:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
27:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
28:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
29:                  * PARTICULAR PURPOSE.
30:                  *
31:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
32:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
33:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
34:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
35:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
36:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
37:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
38:                   *******************************************************************************/
39:                  // DOM-IGNORE-END
40:                  
41:                  // *****************************************************************************
42:                  // *****************************************************************************
43:                  // Section: Included Files
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  #include "definitions.h"
47:                  #include "device.h"
48:                  
49:                  
50:                  
51:                  // ****************************************************************************
52:                  // ****************************************************************************
53:                  // Section: Configuration Bits
54:                  // ****************************************************************************
55:                  // ****************************************************************************
56:                  
57:                  /*** DEVCFG0 ***/
58:                  #pragma config DEBUG =      OFF
59:                  #pragma config JTAGEN =     OFF
60:                  #pragma config ICESEL =     ICS_PGx2
61:                  #pragma config TRCEN =      OFF
62:                  #pragma config BOOTISA =    MIPS32
63:                  #pragma config FSLEEP =     OFF
64:                  #pragma config DBGPER =     PG_ALL
65:                  #pragma config SMCLR =      MCLR_NORM
66:                  #pragma config SOSCGAIN =   G2
67:                  #pragma config SOSCBOOST =  ON
68:                  #pragma config POSCGAIN =   G3
69:                  #pragma config POSCBOOST =  ON
70:                  #pragma config EJTAGBEN =   NORMAL
71:                  
72:                  /*** DEVCFG1 ***/
73:                  #pragma config FNOSC =      SPLL
74:                  #pragma config DMTINTV =    WIN_127_128
75:                  #pragma config FSOSCEN =    OFF
76:                  #pragma config IESO =       ON
77:                  #pragma config POSCMOD =    HS
78:                  #pragma config OSCIOFNC =   OFF
79:                  #pragma config FCKSM =      CSECME
80:                  #pragma config WDTPS =      PS1048576
81:                  #pragma config WDTSPGM =    STOP
82:                  #pragma config FWDTEN =     OFF
83:                  #pragma config WINDIS =     NORMAL
84:                  #pragma config FWDTWINSZ =  WINSZ_25
85:                  #pragma config DMTCNT =     DMT31
86:                  #pragma config FDMTEN =     OFF
87:                  
88:                  /*** DEVCFG2 ***/
89:                  #pragma config FPLLIDIV =   DIV_1
90:                  #pragma config FPLLRNG =    RANGE_8_16_MHZ
91:                  #pragma config FPLLICLK =   PLL_POSC
92:                  #pragma config FPLLMULT =   MUL_40
93:                  #pragma config FPLLODIV =   DIV_4
94:                  #pragma config BORSEL =     LOW
95:                  
96:                  /*** DEVCFG3 ***/
97:                  #pragma config USERID =     0xffff
98:                  #pragma config PGL1WAY =    OFF
99:                  #pragma config PMDL1WAY =   ON
100:                 #pragma config IOL1WAY =    ON
101:                 #pragma config PWMLOCK =  OFF
102:                 
103:                 /*** BF1SEQ ***/
104:                 #pragma config TSEQ =       0x0
105:                 #pragma config CSEQ =       0xffff
106:                 
107:                 
108:                 
109:                 
110:                 
111:                 // *****************************************************************************
112:                 // *****************************************************************************
113:                 // Section: Driver Initialization Data
114:                 // *****************************************************************************
115:                 // *****************************************************************************
116:                 
117:                 
118:                 // *****************************************************************************
119:                 // *****************************************************************************
120:                 // Section: System Data
121:                 // *****************************************************************************
122:                 // *****************************************************************************
123:                 
124:                 // *****************************************************************************
125:                 // *****************************************************************************
126:                 // Section: Library/Stack Initialization Data
127:                 // *****************************************************************************
128:                 // *****************************************************************************
129:                 
130:                 
131:                 // *****************************************************************************
132:                 // *****************************************************************************
133:                 // Section: System Initialization
134:                 // *****************************************************************************
135:                 // *****************************************************************************
136:                 
137:                 
138:                 
139:                 // *****************************************************************************
140:                 // *****************************************************************************
141:                 // Section: Local initialization functions
142:                 // *****************************************************************************
143:                 // *****************************************************************************
144:                 
145:                 
146:                 
147:                 /*******************************************************************************
148:                   Function:
149:                     void SYS_Initialize ( void *data )
150:                 
151:                   Summary:
152:                     Initializes the board, services, drivers, application and other modules.
153:                 
154:                   Remarks:
155:                  */
156:                 
157:                 void SYS_Initialize ( void* data )
158:                 {
9D078084  27BDFFE8   ADDIU SP, SP, -24
9D078088  AFBF0014   SW RA, 20(SP)
159:                     /* Start out with interrupts disabled before configuring any modules */
160:                     __builtin_disable_interrupts();
9D07808C  41626000   DI V0
9D078090  000000C0   EHB
161:                 
162:                   
163:                     CLK_Initialize();
9D078094  0F41DFF8   JAL CLK_Initialize
9D078098  00000000   NOP
164:                 
165:                     /* Configure CP0.K0 for optimal performance (cached instruction pre-fetch) */
166:                     __builtin_mtc0(16, 0,(__builtin_mfc0(16, 0) | 0x3));
9D07809C  40028000   MFC0 V0, Config
9D0780A0  34420003   ORI V0, V0, 3
9D0780A4  40828000   MTC0 V0, Config
9D0780A8  000000C0   EHB
167:                 
168:                     /* Configure Wait States and Prefetch */
169:                     CHECONbits.PFMWS = 2;
9D0780AC  3C02BF80   LUI V0, -16512
9D0780B0  8C430800   LW V1, 2048(V0)
9D0780B4  24040002   ADDIU A0, ZERO, 2
9D0780B8  7C831804   INS V1, A0, 0, 4
9D0780BC  AC430800   SW V1, 2048(V0)
170:                     CHECONbits.PREFEN = 1;
9D0780C0  8C430800   LW V1, 2048(V0)
9D0780C4  24040001   ADDIU A0, ZERO, 1
9D0780C8  7C832904   INS V1, A0, 4, 2
9D0780CC  AC430800   SW V1, 2048(V0)
171:                 
172:                 
173:                 
174:                 	GPIO_Initialize();
9D0780D0  0F41DCA8   JAL GPIO_Initialize
9D0780D4  00000000   NOP
175:                 
176:                     CORETIMER_Initialize();
9D0780D8  0F41E318   JAL CORETIMER_Initialize
9D0780DC  00000000   NOP
177:                 	UART1_Initialize();
9D0780E0  0F41E120   JAL UART1_Initialize
9D0780E4  00000000   NOP
178:                 
179:                 	UART2_Initialize();
9D0780E8  0F41E140   JAL UART2_Initialize
9D0780EC  00000000   NOP
180:                 
181:                     CAN1_Initialize();
9D0780F0  0F41DC63   JAL CAN1_Initialize
9D0780F4  00000000   NOP
182:                 
183:                 	SPI2_Initialize();
9D0780F8  0F41E1D6   JAL SPI2_Initialize
9D0780FC  00000000   NOP
184:                 
185:                 	SPI1_Initialize();
9D078100  0F41E19E   JAL SPI1_Initialize
9D078104  00000000   NOP
186:                 
187:                 	BSP_Initialize();
9D078108  0F41E43F   JAL BSP_Initialize
9D07810C  00000000   NOP
188:                 
189:                 
190:                 
191:                 
192:                     EVIC_Initialize();
9D078110  0F41E29E   JAL EVIC_Initialize
9D078114  00000000   NOP
193:                 
194:                 	/* Enable global interrupts */
195:                     __builtin_enable_interrupts();
9D078118  41626020   EI V0
196:                 
197:                 
198:                 }
9D07811C  8FBF0014   LW RA, 20(SP)
9D078120  03E00008   JR RA
9D078124  27BD0018   ADDIU SP, SP, 24
199:                 
200:                 
201:                 /*******************************************************************************
202:                  End of File
203:                 */
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the default _weak_ exception
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occurred.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
22:                  *
23:                  * Subject to your compliance with these terms, you may use Microchip software
24:                  * and any derivatives exclusively with Microchip products. It is your
25:                  * responsibility to comply with third party license terms applicable to your
26:                  * use of third party software (including open source software) that may
27:                  * accompany Microchip software.
28:                  *
29:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                  * PARTICULAR PURPOSE.
33:                  *
34:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include "definitions.h"
50:                  #include <stdio.h>
51:                  
52:                  
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  // Section: Global Data Definitions
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  
59:                  /*******************************************************************************
60:                    Exception Reason Data
61:                  
62:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
63:                  
64:                    Remarks:
65:                      These global static items are used instead of local variables in the
66:                      _general_exception_handler function because the stack may not be available
67:                      if an exception has occured.
68:                  */
69:                  
70:                  /* Address of instruction that caused the exception. */
71:                  static unsigned int _excep_addr;
72:                  
73:                  /* Enum identifying the cause */
74:                  typedef enum {
75:                      EXCEP_IRQ      =  0, // interrupt
76:                      EXCEP_AdEL     =  4, // address error exception (load or ifetch)
77:                      EXCEP_AdES     =  5, // address error exception (store)
78:                      EXCEP_IBE      =  6, // bus error (ifetch)
79:                      EXCEP_DBE      =  7, // bus error (load/store)
80:                      EXCEP_Sys      =  8, // syscall
81:                      EXCEP_Bp       =  9, // breakpoint
82:                      EXCEP_RI       = 10, // reserved instruction
83:                      EXCEP_CpU      = 11, // coprocessor unusable
84:                      EXCEP_Overflow = 12, // arithmetic overflow
85:                      EXCEP_Trap     = 13, // trap (possible divide by zero)
86:                      EXCEP_IS1      = 16, // implementation specfic 1
87:                      EXCEP_CEU      = 17, // CorExtend Unuseable
88:                      EXCEP_C2E      = 18, // coprocessor 2
89:                  } excep_code;
90:                  
91:                  /* Code identifying the cause of the exception (CP0 Cause register). */
92:                  static excep_code _excep_code;
93:                  
94:                  // </editor-fold>
95:                  
96:                  /*******************************************************************************
97:                    Function:
98:                      void _general_exception_handler ( void )
99:                  
100:                   Description:
101:                     A general exception is any non-interrupt exception which occurs during program
102:                     execution outside of bootstrap code.
103:                 
104:                   Remarks:
105:                     Refer to the XC32 User's Guide for additional information.
106:                  */
107:                 
108:                 void __attribute__((noreturn)) _general_exception_handler ( void )
109:                 {
9D079038  27BDFFF8   ADDIU SP, SP, -8
9D07903C  AFBF0004   SW RA, 4(SP)
110:                     /* Mask off the ExcCode Field from the Cause Register
111:                     Refer to the MIPs Software User's manual */
112:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D079040  40026800   MFC0 V0, Cause
9D079044  7C422080   EXT V0, V0, 2, 5
9D079048  AF828054   SW V0, -32684(GP)
113:                     _excep_addr = _CP0_GET_EPC();
9D07904C  40027000   MFC0 V0, EPC
9D079050  AF828058   SW V0, -32680(GP)
9D079054  0B41E415   J 0x9D079054
9D079058  00000000   NOP
114:                 
115:                     while (1)
116:                     {
117:                         #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
118:                             __builtin_software_breakpoint();
119:                         #endif
120:                     }
121:                 }
122:                 
123:                 /*******************************************************************************
124:                   Function:
125:                     void _bootstrap_exception_handler ( void )
126:                 
127:                   Description:
128:                     A bootstrap exception is any exception which occurs while bootstrap code is
129:                     running (STATUS.BEV bit is 1).
130:                 
131:                   Remarks:
132:                     Refer to the XC32 User's Guide for additional information.
133:                  */
134:                 
135:                 void __attribute__((noreturn)) _bootstrap_exception_handler(void)
136:                 {
9D07905C  27BDFFF8   ADDIU SP, SP, -8
9D079060  AFBF0004   SW RA, 4(SP)
137:                     /* Mask off the ExcCode Field from the Cause Register
138:                     Refer to the MIPs Software User's manual */
139:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D079064  40026800   MFC0 V0, Cause
9D079068  7C422080   EXT V0, V0, 2, 5
9D07906C  AF828054   SW V0, -32684(GP)
140:                     _excep_addr = _CP0_GET_EPC();
9D079070  40027000   MFC0 V0, EPC
9D079074  AF828058   SW V0, -32680(GP)
9D079078  0B41E41E   J 0x9D079078
9D07907C  00000000   NOP
141:                 
142:                     while (1)
143:                     {
144:                         #if defined(__DEBUG) || defined(__DEBUG_D) && defined(__XC32)
145:                             __builtin_software_breakpoint();
146:                         #endif
147:                     }
148:                 }
149:                 /*******************************************************************************
150:                  End of File
151:                 */
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/config/pic32mk_mcj_curiosity_pro/bsp/bsp.c
1:                   /*******************************************************************************
2:                     Board Support Package Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       bsp.c
9:                   
10:                    Summary:
11:                      Board Support Package implementation.
12:                  
13:                    Description:
14:                      This file contains routines that implement the board support package
15:                  *******************************************************************************/
16:                  
17:                  // DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                  * Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
20:                  *
21:                  * Subject to your compliance with these terms, you may use Microchip software
22:                  * and any derivatives exclusively with Microchip products. It is your
23:                  * responsibility to comply with third party license terms applicable to your
24:                  * use of third party software (including open source software) that may
25:                  * accompany Microchip software.
26:                  *
27:                  * THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                  * EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                  * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                  * PARTICULAR PURPOSE.
31:                  *
32:                  * IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
33:                  * INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
34:                  * WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
35:                  * BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
36:                  * FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
37:                  * ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
38:                  * THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
39:                  *******************************************************************************/
40:                  // DOM-IGNORE-END
41:                  
42:                  // *****************************************************************************
43:                  // *****************************************************************************
44:                  // Section: Included Files
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  
48:                  #include "bsp.h"
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Interface Routines
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  // *****************************************************************************
58:                  /* Function:
59:                      void BSP_Initialize(void)
60:                  
61:                    Summary:
62:                      Performs the necessary actions to initialize a board
63:                  
64:                    Description:
65:                      This function initializes the LED, Switch and other ports on the board.
66:                      This function must be called by the user before using any APIs present in
67:                      this BSP.
68:                  
69:                    Remarks:
70:                      Refer to bsp.h for usage information.
71:                  */
72:                  
73:                  void BSP_Initialize(void )
74:                  {
75:                  
76:                  
77:                      /* Switch off LEDs */
78:                  		LED1_Off();
9D0790FC  24032000   ADDIU V1, ZERO, 8192
9D079100  3C02BF86   LUI V0, -16506
9D079104  AC430438   SW V1, 1080(V0)
9D079108  03E00008   JR RA
9D07910C  00000000   NOP
79:                  
80:                  
81:                  }
82:                  
83:                  /*******************************************************************************
84:                   End of File
85:                  */
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/OledGrph.c  -----------
1:                   /************************************************************************/
2:                   /*																		*/
3:                   /*	OledGrph.c	--	OLED Display Graphics Routines						*/
4:                   /*																		*/
5:                   /************************************************************************/
6:                   /*	Author: 	Gene Apperson											*/
7:                   /*	Copyright 2011, Digilent Inc.										*/
8:                   /************************************************************************/
9:                   /*
10:                    This library is free software; you can redistribute it and/or
11:                    modify it under the terms of the GNU Lesser General Public
12:                    License as published by the Free Software Foundation; either
13:                    version 2.1 of the License, or (at your option) any later version.
14:                  
15:                    This library is distributed in the hope that it will be useful,
16:                    but WITHOUT ANY WARRANTY; without even the implied warranty of
17:                    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
18:                    Lesser General Public License for more details.
19:                  
20:                    You should have received a copy of the GNU Lesser General Public
21:                    License along with this library; if not, write to the Free Software
22:                    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
23:                   */
24:                  /************************************************************************/
25:                  /*  Module Description: 												*/
26:                  /*																		*/
27:                  /*	This module contains the implementation of the graphics functions	*/
28:                  /*	for the OLED display driver.										*/
29:                  /*																		*/
30:                  /************************************************************************/
31:                  /*  Revision History:													*/
32:                  /*																		*/
33:                  /*	06/03/2011(GeneA): created											*/
34:                  /*																		*/
35:                  /************************************************************************/
36:                  
37:                  
38:                  /* ------------------------------------------------------------ */
39:                  /*				Include File Definitions						*/
40:                  /* ------------------------------------------------------------ */
41:                  
42:                  #include <stdint.h>
43:                  #include <stdlib.h>
44:                  #include "display_type.h"
45:                  #include "OledDriver.h"
46:                  
47:                  /* ------------------------------------------------------------ */
48:                  /*				Local Type Definitions							*/
49:                  /* ------------------------------------------------------------ */
50:                  
51:                  
52:                  /* ------------------------------------------------------------ */
53:                  /*				Global Variables								*/
54:                  /* ------------------------------------------------------------ */
55:                  
56:                  extern int32_t xcoOledCur;
57:                  extern int32_t ycoOledCur;
58:                  extern uint8_t * pbOledCur;
59:                  extern uint8_t rgbOledBmp[];
60:                  extern uint8_t rgbFillPat[];
61:                  extern int32_t bnOledCur;
62:                  extern uint8_t clrOledCur;
63:                  extern uint8_t * pbOledPatCur;
64:                  extern uint8_t * pbOledFontUser;
65:                  extern uint8_t * pbOledFontCur;
66:                  extern int32_t dxcoOledFontCur;
67:                  extern int32_t dycoOledFontCur;
68:                  
69:                  /* ------------------------------------------------------------ */
70:                  /*				Local Variables									*/
71:                  /* ------------------------------------------------------------ */
72:                  
73:                  uint8_t(*pfnDoRop)(uint8_t bPix, uint8_t bDsp, uint8_t mskPix);
74:                  int32_t modOledCur;
75:                  
76:                  /* ------------------------------------------------------------ */
77:                  /*				Forward Declarations							*/
78:                  /* ------------------------------------------------------------ */
79:                  
80:                  void OledMoveDown(void);
81:                  void OledMoveUp(void);
82:                  void OledMoveRight(void);
83:                  void OledMoveLeft(void);
84:                  uint8_t OledRopSet(uint8_t bPix, uint8_t bDsp, uint8_t mskPix);
85:                  uint8_t OledRopOr(uint8_t bPix, uint8_t bDsp, uint8_t mskPix);
86:                  uint8_t OledRopAnd(uint8_t bPix, uint8_t bDsp, uint8_t mskPix);
87:                  uint8_t OledRopXor(uint8_t bPix, uint8_t bDsp, uint8_t mskPix);
88:                  int32_t OledClampXco(int32_t xco);
89:                  int32_t OledClampYco(int32_t yco);
90:                  
91:                  /* ------------------------------------------------------------ */
92:                  /*				Procedure Definitions							*/
93:                  /* ------------------------------------------------------------ */
94:                  
95:                  /***	OledMoveTo
96:                   **
97:                   **	Parameters:
98:                   **		xco			- x coordinate
99:                   **		yco			- y coordinate
100:                  **
101:                  **	Return Value:
102:                  **		none
103:                  **
104:                  **	Errors:
105:                  **		none
106:                  **
107:                  **	Description:
108:                  **		Set the current graphics drawing position.
109:                  */
110:                 
111:                 void OledMoveTo(int32_t xco, int32_t yco)
112:                 {
9D077DCC  04800012   BLTZ A0, .LVL8, .LBB31
9D077DD0  288300F0   SLTI V1, A0, 240
113:                 	/* Clamp the specified coordinates to the display surface
114:                 	 */
115:                 	xco = OledClampXco(xco);
116:                 	yco = OledClampYco(yco);
117:                 
118:                 	/* Save the current position.
119:                 	 */
120:                 	xcoOledCur = xco;
9D077E04  AF8480FC   SW A0, -32516(GP)
9D077E3C  AF8480FC   SW A0, -32516(GP)
9D077E74  AF8480FC   SW A0, -32516(GP)
121:                 	ycoOledCur = yco;
9D077E08  AF8580F0   SW A1, -32528(GP)
9D077E40  AF8580F0   SW A1, -32528(GP)
9D077E78  AF8580F0   SW A1, -32528(GP)
122:                 
123:                 	/* Compute the display access parameters corresponding to
124:                 	 ** the specified position.
125:                 	 */
126:                 	pbOledCur = &rgbOledBmp[((yco / 8) * ccolOledMax) + xco];
9D077DF4  00863021   ADDU A2, A0, A2
9D077DF8  3C038000   LUI V1, -32768
9D077DFC  246302D8   ADDIU V1, V1, 728
9D077E00  00661821   ADDU V1, V1, A2
9D077E0C  AF838108   SW V1, -32504(GP)
9D077E2C  00863021   ADDU A2, A0, A2
9D077E30  3C038000   LUI V1, -32768
9D077E34  246302D8   ADDIU V1, V1, 728
9D077E38  00661821   ADDU V1, V1, A2
9D077E44  AF838108   SW V1, -32504(GP)
9D077E64  00863021   ADDU A2, A0, A2
9D077E68  3C038000   LUI V1, -32768
9D077E6C  246302D8   ADDIU V1, V1, 728
9D077E70  00661821   ADDU V1, V1, A2
9D077E7C  AF838108   SW V1, -32504(GP)
127:                 	bnOledCur = yco & 7;
9D077E10  03E00008   JR RA
9D077E14  AF8280F8   SW V0, -32520(GP)
9D077E48  03E00008   JR RA
9D077E4C  AF8280F8   SW V0, -32520(GP)
9D077E50  000510C3   SRA V0, A1, 3
9D077E54  00021900   SLL V1, V0, 4
9D077E58  00023200   SLL A2, V0, 8
9D077E5C  00C33023   SUBU A2, A2, V1
9D077E60  30A20007   ANDI V0, A1, 7
9D077E80  03E00008   JR RA
9D077E84  AF8280F8   SW V0, -32520(GP)
128:                 }
129:                 
130:                 /* ------------------------------------------------------------ */
131:                 
132:                 /***	OledGetPos
133:                  **
134:                  **	Parameters:
135:                  **		pxco	- variable to receive x coordinate
136:                  **		pyco	- variable to receive y coordinate
137:                  **
138:                  **	Return Value:
139:                  **		none
140:                  **
141:                  **	Errors:
142:                  **		none
143:                  **
144:                  **	Description:
145:                  **		Fetch the current graphics drawing position
146:                  */
147:                 
148:                 void OledGetPos(int32_t * pxco, int32_t * pyco)
149:                 {
150:                 	*pxco = xcoOledCur;
00000000  00000000   NOP
151:                 	*pyco = ycoOledCur;
00000008  00000000   NOP
152:                 }
153:                 
154:                 /* ------------------------------------------------------------ */
155:                 
156:                 /***	OledSetDrawColor
157:                  **
158:                  **	Parameters:
159:                  **		clr		- drawing color to set
160:                  **
161:                  **	Return Value:
162:                  **		none
163:                  **
164:                  **	Errors:
165:                  **		none
166:                  **
167:                  **	Description:
168:                  **		Set the foreground color used for pixel draw operations.
169:                  */
170:                 
171:                 void OledSetDrawColor(uint8_t clr)
172:                 {
173:                 	clrOledCur = clr & 0x01;
174:                 }
175:                 
176:                 /* ------------------------------------------------------------ */
177:                 
178:                 /***	OledGetStdPattern
179:                  **
180:                  **	Parameters:
181:                  **		ipat		- index to standard fill pattern
182:                  **
183:                  **	Return Value:
184:                  **		returns a pointer to the standard fill pattern
185:                  **
186:                  **	Errors:
187:                  **		returns pattern 0 if index out of range
188:                  **
189:                  **	Description:
190:                  **		Return a pointer to the byte array for the specified
191:                  **		standard fill pattern.
192:                  */
193:                 
194:                 uint8_t * OledGetStdPattern(int32_t ipat)
195:                 {
196:                 	return rgbFillPat + 8 * ipat;
00000000  00000000   NOP
197:                 }
0000000C  00000000   NOP
198:                 
199:                 /* ------------------------------------------------------------ */
200:                 
201:                 /***	OledSetFillPattern
202:                  **
203:                  **	Parameters:
204:                  **		pbPat	- pointer to the fill pattern
205:                  **
206:                  **	Return Value:
207:                  **		none
208:                  **
209:                  **	Errors:
210:                  **		none
211:                  **
212:                  **	Description:
213:                  **		Set a pointer to the current fill pattern to use. A fill
214:                  **		pattern is an array of 8 bytes.
215:                  */
216:                 
217:                 void OledSetFillPattern(uint8_t * pbPat)
218:                 {
219:                 	pbOledPatCur = pbPat;
00000000  00000000   NOP
220:                 }
221:                 
222:                 /* ------------------------------------------------------------ */
223:                 
224:                 /***	OledSetDrawMode
225:                  **
226:                  **	Parameters:
227:                  **		mod		- drawing mode to select
228:                  **
229:                  **	Return Value:
230:                  **		none
231:                  **
232:                  **	Errors:
233:                  **		none
234:                  **
235:                  **	Description:
236:                  **		Set the specified mode as the current drawing mode.
237:                  */
238:                 
239:                 void OledSetDrawMode(int32_t mod)
240:                 {
241:                 	modOledCur = mod;
242:                 
243:                 	switch (mod) {
9D0785FC  24020001   ADDIU V0, ZERO, 1
9D078600  10820019   BEQ A0, V0, 0x9D078668
9D078604  AF848118   SW A0, -32488(GP)
9D078608  28820002   SLTI V0, A0, 2
9D07860C  1440000C   BNE V0, ZERO, 0x9D078640
9D078610  24020002   ADDIU V0, ZERO, 2
9D078614  10820006   BEQ A0, V0, 0x9D078630
9D078618  24020003   ADDIU V0, ZERO, 3
9D07861C  1482000D   BNE A0, V0, 0x9D078654
9D078620  3C029D08   LUI V0, -25336
9D078640  14800004   BNE A0, ZERO, 0x9D078654
9D078644  3C029D08   LUI V0, -25336
244:                 	case modOledSet:
245:                 		pfnDoRop = OledRopSet;
246:                 		break;
247:                 
248:                 	case modOledOr:
249:                 		pfnDoRop = OledRopOr;
9D078668  3C029D08   LUI V0, -25336
9D07866C  244291F4   ADDIU V0, V0, -28172
250:                 		break;
9D078670  03E00008   JR RA
9D078674  AF828114   SW V0, -32492(GP)
251:                 
252:                 	case modOledAnd:
253:                 		pfnDoRop = OledRopAnd;
9D078630  3C029D08   LUI V0, -25336
9D078634  24429200   ADDIU V0, V0, -28160
254:                 		break;
9D078638  03E00008   JR RA
9D07863C  AF828114   SW V0, -32492(GP)
255:                 
256:                 	case modOledXor:
257:                 		pfnDoRop = OledRopXor;
9D078624  2442920C   ADDIU V0, V0, -28148
258:                 		break;
9D078628  03E00008   JR RA
9D07862C  AF828114   SW V0, -32492(GP)
259:                 
260:                 	default:
261:                 		modOledCur = modOledSet;
9D078654  AF808118   SW ZERO, -32488(GP)
262:                 		pfnDoRop = OledRopSet;
9D078648  24429124   ADDIU V0, V0, -28380
9D07864C  03E00008   JR RA
9D078650  AF828114   SW V0, -32492(GP)
9D078658  3C029D08   LUI V0, -25336
9D07865C  24429124   ADDIU V0, V0, -28380
9D078660  03E00008   JR RA
9D078664  AF828114   SW V0, -32492(GP)
9D078668  3C029D08   LUI V0, -25336
9D07866C  244291F4   ADDIU V0, V0, -28172
9D078670  03E00008   JR RA
9D078674  AF828114   SW V0, -32492(GP)
263:                 	}
264:                 }
265:                 
266:                 /* ------------------------------------------------------------ */
267:                 
268:                 /***	OledGetDrawMode
269:                  **
270:                  **	Parameters:
271:                  **		none
272:                 
273:                  **	Return Value:
274:                  **		returns current drawing mode
275:                  **
276:                  **	Errors:
277:                  **		none
278:                  **
279:                  **	Description:
280:                  **		Get the current drawing mode
281:                  */
282:                 
283:                 int OledGetDrawMode(void)
284:                 {
285:                 	return modOledCur;
286:                 }
287:                 
288:                 /* ------------------------------------------------------------ */
289:                 
290:                 /***	OledDrawPixel
291:                  **
292:                  **	Parameters:
293:                  **		none
294:                  **
295:                  **	Return Value:
296:                  **		none
297:                  **
298:                  **	Errors:
299:                  **		none
300:                  **
301:                  **	Description:
302:                  **		Set the pixel at the current drawing location to the
303:                  **		specified value.
304:                  */
305:                 
306:                 void OledDrawPixel(void)
307:                 {
00000000  00000000   NOP
308:                 	*pbOledCur = (*pfnDoRop)((clrOledCur << bnOledCur), *pbOledCur, (1 << bnOledCur));
0000000C  00000000   NOP
309:                 }
0000003C  00000000   NOP
310:                 
311:                 /* ------------------------------------------------------------ */
312:                 
313:                 /***	OledGetPixel
314:                  **
315:                  **	Parameters:
316:                  **		none
317:                  **
318:                  **	Return Value:
319:                  **		returns pixel value at current drawing location
320:                  **
321:                  **	Errors:
322:                  **		none
323:                  **
324:                  **	Description:
325:                  **		Return the value of the pixel at the current drawing location
326:                  */
327:                 
328:                 uint8_t OledGetPixel(void)
329:                 {
330:                 	return(*pbOledCur & (1 << bnOledCur)) != 0 ? 1 : 0;
00000000  00000000   NOP
331:                 }
00000010  00000000   NOP
332:                 
333:                 /* ------------------------------------------------------------ */
334:                 
335:                 /***	OledLineTo
336:                  **
337:                  **	Parameters:
338:                  **		xco			- x coordinate
339:                  **		yco			- y coordinate
340:                  **
341:                  **	Return Value:
342:                  **		none
343:                  **
344:                  **	Errors:
345:                  **		none
346:                  **
347:                  **	Description:
348:                  **		Draw a line from the current position to the specified
349:                  **		position.
350:                  */
351:                 
352:                 void OledLineTo(int32_t xco, int32_t yco)
353:                 {
00000000  00000000   NOP
00000028  00000000   NOP
354:                 	int32_t err;
355:                 	int32_t del;
356:                 	int32_t lim;
357:                 	int32_t cpx;
358:                 	int32_t dxco;
359:                 	int32_t dyco;
360:                 	void (*pfnMajor)(void);
361:                 	void (*pfnMinor)(void);
362:                 
363:                 	/* Clamp the point to be on the display.
364:                 	 */
365:                 	xco = OledClampXco(xco);
366:                 	yco = OledClampYco(yco);
367:                 
368:                 	/* Determine which octant the line occupies
369:                 	 */
370:                 	dxco = xco - xcoOledCur;
00000050  00000000   NOP
371:                 	dyco = yco - ycoOledCur;
00000058  00000000   NOP
372:                 	if (labs(dxco) >= labs(dyco)) {
00000060  00000000   NOP
373:                 		/* Line is x-major
374:                 		 */
375:                 		lim = labs(dxco);
376:                 		del = labs(dyco);
377:                 		if (dxco >= 0) {
00000084  00000000   NOP
378:                 			pfnMajor = OledMoveRight;
0000008C  00000000   NOP
379:                 		} else {
380:                 			pfnMajor = OledMoveLeft;
381:                 		}
382:                 
383:                 		if (dyco >= 0) {
00000090  00000000   NOP
0000015C  00000000   NOP
384:                 			pfnMinor = OledMoveDown;
00000098  00000000   NOP
385:                 		} else {
386:                 			pfnMinor = OledMoveUp;
00000164  00000000   NOP
387:                 		}
388:                 	} else {
389:                 		/* Line is y-major
390:                 		 */
391:                 		lim = labs(dyco);
392:                 		del = labs(dxco);
393:                 		if (dyco >= 0) {
00000104  00000000   NOP
394:                 			pfnMajor = OledMoveDown;
0000010C  00000000   NOP
395:                 		} else {
396:                 			pfnMajor = OledMoveUp;
397:                 		}
398:                 
399:                 		if (dxco >= 0) {
00000110  00000000   NOP
00000170  00000000   NOP
400:                 			pfnMinor = OledMoveRight;
00000118  00000000   NOP
401:                 		} else {
402:                 			pfnMinor = OledMoveLeft;
00000178  00000000   NOP
403:                 		}
404:                 	}
405:                 
406:                 	/* Render the line. The algorithm is:
407:                 	 **		Write the current pixel
408:                 	 **		Move one pixel on the major axis
409:                 	 **		Add the minor axis delta to the error accumulator
410:                 	 **		if the error accumulator is greater than the major axis delta
411:                 	 **			Move one pixel in the minor axis
412:                 	 **			Subtract major axis delta from error accumulator
413:                 	 */
414:                 	err = lim / 2;
000000A8  00000000   NOP
00000120  00000000   NOP
415:                 	cpx = lim;
416:                 	while (cpx > 0) {
000000A0  00000000   NOP
000000C8  00000000   NOP
0000013C  00000000   NOP
417:                 		OledDrawPixel();
000000AC  00000000   NOP
418:                 		(*pfnMajor)();
000000B4  00000000   NOP
419:                 		err += del;
420:                 		if (err > lim) {
000000BC  00000000   NOP
421:                 			err -= lim;
422:                 			(*pfnMinor)();
00000134  00000000   NOP
423:                 		}
424:                 		cpx -= 1;
425:                 	}
426:                 
427:                 	/* Update the current location variables.
428:                 	 */
429:                 	xcoOledCur = xco;
000000D0  00000000   NOP
00000144  00000000   NOP
430:                 	ycoOledCur = yco;
000000D4  00000000   NOP
431:                 }
000000D8  00000000   NOP
432:                 
433:                 /* ------------------------------------------------------------ */
434:                 
435:                 /***	OledDrawRect
436:                  **
437:                  **	Parameters:
438:                  **		xco		- x coordinate of other corner
439:                  **		yco		- y coordinate of other corner
440:                  **
441:                  **	Return Value:
442:                  **		none
443:                  **
444:                  **	Errors:
445:                  **		none
446:                  **
447:                  **	Description:
448:                  **		Draw a rectangle bounded by the current location and
449:                  **		the specified location.
450:                  */
451:                 
452:                 void OledDrawRect(int32_t xco, int32_t yco)
453:                 {
00000000  00000000   NOP
00000018  00000000   NOP
454:                 	int32_t xco1;
455:                 	int32_t yco1;
456:                 
457:                 	/* Clamp the point to be on the display.
458:                 	 */
459:                 	xco = OledClampXco(xco);
460:                 	yco = OledClampYco(yco);
461:                 
462:                 	xco1 = xcoOledCur;
00000044  00000000   NOP
463:                 	yco1 = ycoOledCur;
00000040  00000000   NOP
464:                 	OledLineTo(xco, yco1);
00000048  00000000   NOP
465:                 	OledLineTo(xco, yco);
00000054  00000000   NOP
466:                 	OledLineTo(xco1, yco);
00000060  00000000   NOP
467:                 	OledLineTo(xco1, yco1);
0000006C  00000000   NOP
00000088  00000000   NOP
468:                 }
00000074  00000000   NOP
469:                 
470:                 /* ------------------------------------------------------------ */
471:                 
472:                 /***	OledFillRect
473:                  **
474:                  **	Parameters:
475:                  **		xco		- x coordinate of other corner
476:                  **		yco		- y coordinate of other corner
477:                  **
478:                  **	Return Value:
479:                  **		none
480:                  **
481:                  **	Errors:
482:                  **		none
483:                  **
484:                  **	Description:
485:                  **		Fill a rectangle bounded by the current location and
486:                  **		the specified location.
487:                  */
488:                 
489:                 void OledFillRect(int32_t xco, int32_t yco)
490:                 {
00000000  00000000   NOP
491:                 	int32_t xcoLeft;
492:                 	int32_t xcoRight;
493:                 	int32_t ycoTop;
494:                 	int32_t ycoBottom;
495:                 	int32_t ibPat;
496:                 	uint8_t * pbCur;
497:                 	uint8_t * pbLeft;
498:                 	int32_t xcoCur;
499:                 	uint8_t mskPat;
500:                 
501:                 	/* Clamp the point to be on the display.
502:                 	 */
503:                 	xco = OledClampXco(xco);
504:                 	yco = OledClampYco(yco);
505:                 
506:                 	/* Set up the four sides of the rectangle.
507:                 	 */
508:                 	if (xcoOledCur < xco) {
00000050  00000000   NOP
509:                 		xcoLeft = xcoOledCur;
510:                 		xcoRight = xco;
511:                 	} else {
512:                 		xcoLeft = xco;
513:                 		xcoRight = xcoOledCur;
514:                 	}
515:                 
516:                 	if (ycoOledCur < yco) {
0000006C  00000000   NOP
517:                 		ycoTop = ycoOledCur;
518:                 		ycoBottom = yco;
519:                 	} else {
520:                 		ycoTop = yco;
521:                 		ycoBottom = ycoOledCur;
522:                 	}
523:                 
524:                 
525:                 	while (ycoTop <= ycoBottom) {
00000150  00000000   NOP
526:                 		/* Compute the address of the left edge of the rectangle for this
527:                 		 ** stripe across the rectangle.
528:                 		 */
529:                 		pbLeft = &rgbOledBmp[((ycoTop / 8) * ccolOledMax) + xcoLeft];
000000B0  00000000   NOP
000000C4  00000000   NOP
000000D4  00000000   NOP
000000DC  00000000   NOP
530:                 
531:                 		/* Generate a mask to preserve any low bits in the byte that aren't
532:                 		 ** part of the rectangle being filled.
533:                 		 */
534:                 		mskPat = (1 << (ycoTop & 0x07)) - 1;
000000C0  00000000   NOP
000000CC  00000000   NOP
000000D8  00000000   NOP
535:                 
536:                 		/* Combine with a mask to preserve any upper bits in the byte that aren't
537:                 		 ** part of the rectangle being filled.
538:                 		 ** This mask will end up not preserving any bits for bytes that are in
539:                 		 ** the middle of the rectangle vertically.
540:                 		 */
541:                 		if ((ycoTop / 8) == (ycoBottom / 8)) {
000000E0  00000000   NOP
542:                 			mskPat |= ~((1 << ((ycoBottom & 0x07) + 1)) - 1);
00000084  00000000   NOP
0000018C  00000000   NOP
543:                 		}
544:                 		ibPat = xcoLeft & 0x07; //index to first pattern byte
00000108  00000000   NOP
545:                 		xcoCur = xcoLeft;
546:                 		pbCur = pbLeft;
000000E8  00000000   NOP
00000100  00000000   NOP
547:                 
548:                 		/* Loop through all of the bytes horizontally making up this stripe
549:                 		 ** of the rectangle.
550:                 		 */
551:                 		while (xcoCur <= xcoRight) {
000000F0  00000000   NOP
0000013C  00000000   NOP
552:                 			*pbCur = (*pfnDoRop)(*(pbOledPatCur + ibPat), *pbCur, ~mskPat);
00000110  00000000   NOP
553:                 			xcoCur += 1;
554:                 			pbCur += 1;
555:                 			ibPat += 1;
00000130  00000000   NOP
556:                 			if (ibPat > 7) {
557:                 				ibPat = 0;
00000138  00000000   NOP
558:                 			}
559:                 		}
560:                 		/* Advance to the next horizontal stripe.
561:                 		 */
562:                 		ycoTop = 8 * ((ycoTop / 8) + 1);
00000148  00000000   NOP
563:                 	}
564:                 }
0000015C  00000000   NOP
565:                 
566:                 /* ------------------------------------------------------------ */
567:                 
568:                 /***	OledGetBmp
569:                  **
570:                  **	Parameters:
571:                  **		dxco		- width of bitmap
572:                  **		dyco		- height of bitmap
573:                  **		pbBits		- pointer to the bitmap bits	
574:                  **
575:                  **	Return Value:
576:                  **		none
577:                  **
578:                  **	Errors:
579:                  **		none
580:                  **
581:                  **	Description:
582:                  **		This routine will get the bits corresponding to the
583:                  **		rectangle implied by the current location and the
584:                  **		specified width and height. The buffer specified
585:                  **		by pbBits must be large enough to hold the resulting
586:                  **		bytes.
587:                  */
588:                 
589:                 void OledGetBmp(int32_t dxco, int32_t dyco, uint8_t * pbBits)
590:                 {
00000000  00000000   NOP
591:                 	int32_t xcoLeft;
592:                 	int32_t xcoRight;
593:                 	int32_t ycoTop;
594:                 	int32_t ycoBottom;
595:                 	uint8_t * pbDspCur;
596:                 	uint8_t * pbDspLeft;
597:                 	uint8_t * pbBmpCur;
598:                 	uint8_t * pbBmpLeft;
599:                 	int32_t xcoCur;
600:                 	int32_t bnAlign;
601:                 	uint8_t mskEnd;
602:                 
603:                 	/* Set up the four sides of the source rectangle.
604:                 	 */
605:                 	xcoLeft = xcoOledCur;
0000000C  00000000   NOP
606:                 	xcoRight = xcoLeft + dxco;
00000038  00000000   NOP
607:                 	if (xcoRight >= ccolOledMax) {
608:                 		xcoRight = ccolOledMax - 1;
609:                 	}
610:                 
611:                 	ycoTop = ycoOledCur;
00000008  00000000   NOP
612:                 	ycoBottom = ycoTop + dyco;
00000020  00000000   NOP
613:                 	if (ycoBottom >= crowOledMax) {
614:                 		ycoBottom = crowOledMax - 1;
615:                 	}
616:                 
617:                 	bnAlign = ycoTop & 0x07;
00000058  00000000   NOP
618:                 	pbDspLeft = &rgbOledBmp[((ycoTop / 8) * ccolOledMax) + xcoLeft];
00000010  00000000   NOP
00000024  00000000   NOP
00000040  00000000   NOP
0000005C  00000000   NOP
619:                 	pbBmpLeft = pbBits;
620:                 
621:                 	while (ycoTop < ycoBottom) {
00000050  00000000   NOP
00000064  00000000   NOP
00000110  00000000   NOP
0000011C  00000000   NOP
00000174  00000000   NOP
00000180  00000000   NOP
622:                 
623:                 		if ((ycoTop / 8) == ((ycoBottom - 1) / 8)) {
000000B0  00000000   NOP
0000012C  00000000   NOP
624:                 			mskEnd = ((1 << (((ycoBottom - 1)&0x07) + 1)) - 1);
00000070  00000000   NOP
625:                 		} else {
626:                 			mskEnd = 0xFF;
000000A4  00000000   NOP
000000BC  00000000   NOP
00000138  00000000   NOP
627:                 		}
628:                 
629:                 		xcoCur = xcoLeft;
630:                 		pbDspCur = pbDspLeft;
631:                 		pbBmpCur = pbBmpLeft;
632:                 
633:                 		/* Loop through all of the bytes horizontally making up this stripe
634:                 		 ** of the rectangle.
635:                 		 */
636:                 		if (bnAlign == 0) {
000000C8  00000000   NOP
00000144  00000000   NOP
637:                 			while (xcoCur < xcoRight) {
0000014C  00000000   NOP
00000168  00000000   NOP
638:                 				*pbBmpCur = (*pbDspCur) & mskEnd;
00000158  00000000   NOP
00000164  00000000   NOP
639:                 				xcoCur += 1;
640:                 				pbBmpCur += 1;
00000160  00000000   NOP
641:                 				pbDspCur += 1;
0000015C  00000000   NOP
642:                 			}
643:                 		} else {
644:                 			while (xcoCur < xcoRight) {
000000D0  00000000   NOP
00000104  00000000   NOP
645:                 				//				bTmp = *pbDspCur;
646:                 				//				bTmp = *(pbDspCur + ccolOledMax);
647:                 				*pbBmpCur = ((*pbDspCur >> bnAlign) |
000000E8  00000000   NOP
000000F4  00000000   NOP
648:                 					((*(pbDspCur + ccolOledMax)) << (8 - bnAlign))) & mskEnd;
000000E4  00000000   NOP
000000F0  00000000   NOP
649:                 				xcoCur += 1;
650:                 				pbBmpCur += 1;
651:                 				pbDspCur += 1;
000000EC  00000000   NOP
652:                 			}
653:                 		}
654:                 
655:                 		/* Advance to the next horizontal stripe.
656:                 		 */
657:                 		ycoTop += 8;
0000010C  00000000   NOP
00000170  00000000   NOP
658:                 		pbDspLeft += ccolOledMax;
00000114  00000000   NOP
00000178  00000000   NOP
659:                 		pbBmpLeft += dxco;
00000118  00000000   NOP
0000017C  00000000   NOP
660:                 
661:                 	}
662:                 
663:                 }
00000188  00000000   NOP
664:                 
665:                 /* ------------------------------------------------------------ */
666:                 
667:                 /***	OledPutBmp
668:                  **
669:                  **	Parameters:
670:                  **		dxco		- width of bitmap
671:                  **		dyco		- height of bitmap
672:                  **		pbBits		- pointer to the bitmap bits	
673:                  **
674:                  **	Return Value:
675:                  **		none
676:                  **
677:                  **	Errors:
678:                  **		none
679:                  **
680:                  **	Description:
681:                  **		This routine will put the specified bitmap into the display
682:                  **		buffer at the current location.
683:                  */
684:                 
685:                 void OledPutBmp(int32_t dxco, int32_t dyco, uint8_t * pbBits)
686:                 {
00000000  00000000   NOP
00000058  00000000   NOP
0000009C  00000000   NOP
687:                 	int32_t xcoLeft;
688:                 	int32_t xcoRight;
689:                 	int32_t ycoTop;
690:                 	int32_t ycoBottom;
691:                 	uint8_t * pbDspCur;
692:                 	uint8_t * pbDspLeft;
693:                 	uint8_t * pbBmpCur;
694:                 	uint8_t * pbBmpLeft;
695:                 	int32_t xcoCur;
696:                 	uint8_t bBmp;
697:                 	uint8_t mskEnd;
698:                 	uint8_t mskUpper;
699:                 	uint8_t mskLower;
700:                 	int32_t bnAlign;
701:                 	int32_t fTop;
702:                 
703:                 	/* Set up the four sides of the destination rectangle.
704:                 	 */
705:                 	xcoLeft = xcoOledCur;
00000030  00000000   NOP
706:                 	xcoRight = xcoLeft + dxco;
0000006C  00000000   NOP
707:                 	if (xcoRight >= ccolOledMax) {
708:                 		xcoRight = ccolOledMax - 1;
709:                 	}
710:                 
711:                 	ycoTop = ycoOledCur;
0000002C  00000000   NOP
712:                 	ycoBottom = ycoTop + dyco;
0000004C  00000000   NOP
713:                 	if (ycoBottom >= crowOledMax) {
714:                 		ycoBottom = crowOledMax - 1;
715:                 	}
716:                 
717:                 	bnAlign = ycoTop & 0x07;
00000040  00000000   NOP
718:                 	mskUpper = (1 << bnAlign) - 1;
00000034  00000000   NOP
00000054  00000000   NOP
00000060  00000000   NOP
0000007C  00000000   NOP
719:                 	mskLower = ~mskUpper;
0000008C  00000000   NOP
000000A4  00000000   NOP
720:                 	pbDspLeft = &rgbOledBmp[((ycoTop / 8) * ccolOledMax) + xcoLeft];
00000038  00000000   NOP
00000044  00000000   NOP
00000050  00000000   NOP
00000064  00000000   NOP
00000080  00000000   NOP
00000094  00000000   NOP
000000AC  00000000   NOP
721:                 	pbBmpLeft = pbBits;
722:                 	fTop = 1;
000000F4  00000000   NOP
723:                 
724:                 	while (ycoTop < ycoBottom) {
00000098  00000000   NOP
000000B4  00000000   NOP
000001B4  00000000   NOP
000001C4  00000000   NOP
0000024C  00000000   NOP
0000025C  00000000   NOP
725:                 		/* Combine with a mask to preserve any upper bits in the byte that aren't
726:                 		 ** part of the rectangle being filled.
727:                 		 ** This mask will end up not preserving any bits for bytes that are in
728:                 		 ** the middle of the rectangle vertically.
729:                 		 */
730:                 		if ((ycoTop / 8) == ((ycoBottom - 1) / 8)) {
00000114  00000000   NOP
000001D8  00000000   NOP
731:                 			mskEnd = ((1 << (((ycoBottom - 1)&0x07) + 1)) - 1);
000000C0  00000000   NOP
00000120  00000000   NOP
000001E4  00000000   NOP
732:                 		} else {
733:                 			mskEnd = 0xFF;
734:                 		}
735:                 		if (fTop) {
736:                 			mskEnd &= ~mskUpper;
00000138  00000000   NOP
000001FC  00000000   NOP
737:                 		}
738:                 
739:                 		xcoCur = xcoLeft;
740:                 		pbDspCur = pbDspLeft;
741:                 		pbBmpCur = pbBmpLeft;
742:                 
743:                 		/* Loop through all of the bytes horizontally making up this stripe
744:                 		 ** of the rectangle.
745:                 		 */
746:                 		if (bnAlign == 0) {
00000140  00000000   NOP
00000204  00000000   NOP
747:                 			while (xcoCur < xcoRight) {
0000020C  00000000   NOP
00000238  00000000   NOP
748:                 				*pbDspCur = (*pfnDoRop)(*pbBmpCur, *pbDspCur, mskEnd);
0000021C  00000000   NOP
749:                 				xcoCur += 1;
750:                 				pbDspCur += 1;
751:                 				pbBmpCur += 1;
752:                 			}
753:                 		} else {
754:                 			while (xcoCur < xcoRight) {
00000148  00000000   NOP
000001A0  00000000   NOP
755:                 				bBmp = ((*pbBmpCur) << bnAlign);
0000015C  00000000   NOP
756:                 				if (!fTop) {
00000160  00000000   NOP
757:                 					bBmp |= ((*(pbBmpCur - dxco) >> (8 - bnAlign)) & ~mskLower);
00000100  00000000   NOP
00000168  00000000   NOP
758:                 				}
759:                 				bBmp &= mskEnd;
760:                 				*pbDspCur = (*pfnDoRop)(bBmp, *pbDspCur, mskEnd);
00000184  00000000   NOP
761:                 				xcoCur += 1;
762:                 				pbDspCur += 1;
0000019C  00000000   NOP
763:                 				pbBmpCur += 1;
764:                 			}
765:                 		}
766:                 
767:                 		/* Advance to the next horizontal stripe.
768:                 		 */
769:                 		ycoTop = 8 * ((ycoTop / 8) + 1);
000001A8  00000000   NOP
00000240  00000000   NOP
770:                 		pbDspLeft += ccolOledMax;
000001BC  00000000   NOP
00000254  00000000   NOP
771:                 		pbBmpLeft += dxco;
000001C0  00000000   NOP
00000258  00000000   NOP
772:                 		fTop = 0;
000001CC  00000000   NOP
773:                 	}
774:                 }
00000264  00000000   NOP
775:                 
776:                 /* ------------------------------------------------------------ */
777:                 
778:                 /***	OledDrawChar
779:                  **
780:                  **	Parameters:
781:                  **		ch			- character to write to display
782:                  **
783:                  **	Return Value:
784:                  **		none
785:                  **
786:                  **	Errors:
787:                  **		none
788:                  **
789:                  **	Description:
790:                  **		Write the specified character to the display at the current
791:                  **		cursor position and advance the cursor.
792:                  */
793:                 
794:                 void OledDrawChar(char ch)
795:                 {
00000008  00000000   NOP
796:                 	uint8_t * pbFont;
797:                 
798:                 	if ((ch & 0x80) != 0) {
00000000  00000000   NOP
799:                 		return;
800:                 	}
801:                 
802:                 	if (ch < chOledUserMax) {
0000000C  00000000   NOP
803:                 		pbFont = pbOledFontUser + ch*cbOledChar;
00000014  00000000   NOP
804:                 	} else if ((ch & 0x80) == 0) {
805:                 		pbFont = pbOledFontCur + (ch - chOledUserMax) * cbOledChar;
0000004C  00000000   NOP
806:                 	}
807:                 
808:                 	OledPutBmp(dxcoOledFontCur, dycoOledFontCur, pbFont);
00000020  00000000   NOP
809:                 
810:                 	xcoOledCur += dxcoOledFontCur;
0000002C  00000000   NOP
811:                 }
0000003C  00000000   NOP
812:                 
813:                 /* ------------------------------------------------------------ */
814:                 
815:                 /***	OledDrawString
816:                  **
817:                  **	Parameters:
818:                  **		sz		- pointer to the null terminated string
819:                  **
820:                  **	Return Value:
821:                  **		none
822:                  **
823:                  **	Errors:
824:                  **		none
825:                  **
826:                  **	Description:
827:                  **		Write the specified null terminated character string to the
828:                  **		display and advance the cursor.
829:                  */
830:                 
831:                 void OledDrawString(char * sz)
832:                 {
00000000  00000000   NOP
0000000C  00000000   NOP
833:                 	while (*sz != '\0') {
00000010  00000000   NOP
00000024  00000000   NOP
834:                 		OledDrawChar(*sz);
0000001C  00000000   NOP
835:                 		sz += 1;
836:                 	}
837:                 }
00000030  00000000   NOP
838:                 
839:                 /* ------------------------------------------------------------ */
840:                 /*				Internal Support Routines						*/
841:                 /* ------------------------------------------------------------ */
842:                 
843:                 /***	OledRopSet
844:                  **
845:                  **	Parameters:
846:                  **
847:                  **	Return Value:
848:                  **
849:                  **	Errors:
850:                  **
851:                  **	Description:
852:                  **
853:                  */
854:                 
855:                 uint8_t OledRopSet(uint8_t bPix, uint8_t bDsp, uint8_t mskPix)
856:                 {
857:                 	return(bDsp & ~mskPix) | (bPix & mskPix);
9D079124  00061027   NOR V0, ZERO, A2
9D079128  00451024   AND V0, V0, A1
9D07912C  00C42024   AND A0, A2, A0
858:                 }
9D079130  03E00008   JR RA
9D079134  00441025   OR V0, V0, A0
859:                 
860:                 /* ------------------------------------------------------------ */
861:                 
862:                 /***	OledRopOr
863:                  **
864:                  **	Parameters:
865:                  **
866:                  **	Return Value:
867:                  **
868:                  **	Errors:
869:                  **
870:                  **	Description:
871:                  **
872:                  */
873:                 
874:                 uint8_t OledRopOr(uint8_t bPix, uint8_t bDsp, uint8_t mskPix)
875:                 {
876:                 	return bDsp | (bPix & mskPix);
9D0791F4  00861024   AND V0, A0, A2
877:                 }
9D0791F8  03E00008   JR RA
9D0791FC  00A21025   OR V0, A1, V0
878:                 
879:                 /* ------------------------------------------------------------ */
880:                 
881:                 /***	OledRopAnd
882:                  **
883:                  **	Parameters:
884:                  **
885:                  **	Return Value:
886:                  **
887:                  **	Errors:
888:                  **
889:                  **	Description:
890:                  **
891:                  */
892:                 
893:                 uint8_t OledRopAnd(uint8_t bPix, uint8_t bDsp, uint8_t mskPix)
894:                 {
895:                 	return bDsp & (bPix & mskPix);
9D079200  00C51024   AND V0, A2, A1
896:                 }
9D079204  03E00008   JR RA
9D079208  00821024   AND V0, A0, V0
897:                 
898:                 /* ------------------------------------------------------------ */
899:                 
900:                 /***	OledRopXor
901:                  **
902:                  **	Parameters:
903:                  **
904:                  **	Return Value:
905:                  **
906:                  **	Errors:
907:                  **
908:                  **	Description:
909:                  **
910:                  */
911:                 
912:                 uint8_t OledRopXor(uint8_t bPix, uint8_t bDsp, uint8_t mskPix)
913:                 {
914:                 	return bDsp ^ (bPix & mskPix);
9D07920C  00861024   AND V0, A0, A2
915:                 }
9D079210  03E00008   JR RA
9D079214  00A21026   XOR V0, A1, V0
916:                 
917:                 /* ------------------------------------------------------------ */
918:                 
919:                 /***	OledMoveUp
920:                  **
921:                  **	Parameters:
922:                  **		none
923:                  **
924:                  **	Return Value:
925:                  **		none
926:                  **
927:                  **	Errors:
928:                  **		none
929:                  **
930:                  **	Description:
931:                  **		Updates global variables related to current position on the
932:                  **		display.
933:                  */
934:                 
935:                 void OledMoveUp(void)
936:                 {
937:                 	/* Go up one bit position in the current byte.
938:                 	 */
939:                 	bnOledCur -= 1;
00000000  00000000   NOP
00000010  00000000   NOP
940:                 
941:                 	/* If we have gone off the end of the current byte
942:                 	 ** go up 1 page.
943:                 	 */
944:                 	if (bnOledCur < 0) {
00000008  00000000   NOP
945:                 		bnOledCur = 7;
00000028  00000000   NOP
946:                 		pbOledCur -= ccolOledMax;
00000018  00000000   NOP
0000003C  00000000   NOP
947:                 		/* If we have gone off of the top of the display,
948:                 		 ** go back down.
949:                 		 */
950:                 		if (pbOledCur < rgbOledBmp) {
0000001C  00000000   NOP
0000002C  00000000   NOP
951:                 			pbOledCur += ccolOledMax;
952:                 		}
953:                 	}
954:                 }
955:                 
956:                 /* ------------------------------------------------------------ */
957:                 
958:                 /***	OledMoveDown
959:                  **
960:                  **	Parameters:
961:                  **		none
962:                  **
963:                  **	Return Value:
964:                  **		none
965:                  **
966:                  **	Errors:
967:                  **		none
968:                  **
969:                  **	Description:
970:                  **		Updates global variables related to current position on the
971:                  **		display.
972:                  */
973:                 
974:                 void OledMoveDown(void)
975:                 {
00000000  00000000   NOP
976:                 	/* Go down one bit position in the current byte.
977:                 	 */
978:                 	bnOledCur += 1;
0000003C  00000000   NOP
979:                 
980:                 	/* If we have gone off the end of the current byte,
981:                 	 ** go down one page in the display memory.
982:                 	 */
983:                 	if (bnOledCur > 7) {
00000008  00000000   NOP
984:                 		bnOledCur = 0;
985:                 		pbOledCur += ccolOledMax;
00000014  00000000   NOP
00000034  00000000   NOP
986:                 		/* If we have gone off the end of the display memory
987:                 		 ** go back up a page.
988:                 		 */
989:                 		if (pbOledCur >= rgbOledBmp + cbOledDispMax) {
0000001C  00000000   NOP
990:                 			pbOledCur -= ccolOledMax;
991:                 		}
992:                 	}
993:                 }
994:                 
995:                 /* ------------------------------------------------------------ */
996:                 
997:                 /***	OledMoveLeft
998:                  **
999:                  **	Parameters:
1000:                 **		none
1001:                 **
1002:                 **	Return Value:
1003:                 **		none
1004:                 **
1005:                 **	Errors:
1006:                 **		none
1007:                 **
1008:                 **	Description:
1009:                 **		Updates global variables related to current position on the
1010:                 **		display.
1011:                 */
1012:                
1013:                void OledMoveLeft(void)
1014:                {
1015:                	/* Are we at the left edge of the display already
1016:                	 */
1017:                	if (((pbOledCur - rgbOledBmp) & (ccolOledMax - 1)) == 0) {
00000000  00000000   NOP
1018:                		return;
1019:                	}
1020:                
1021:                	/* Not at the left edge, so go back one byte.
1022:                	 */
1023:                	pbOledCur -= 1;
0000001C  00000000   NOP
1024:                }
1025:                
1026:                /* ------------------------------------------------------------ */
1027:                
1028:                /***	OledMoveRight
1029:                 **
1030:                 **	Parameters:
1031:                 **		none
1032:                 **
1033:                 **	Return Value:
1034:                 **		none
1035:                 **
1036:                 **	Errors:
1037:                 **		none
1038:                 **
1039:                 **	Description:
1040:                 **		Updates global variables related to current position on the
1041:                 **		display.
1042:                 */
1043:                
1044:                void OledMoveRight(void)
1045:                {
1046:                	/* Are we at the right edge of the display already
1047:                	 */
1048:                	if (((pbOledCur - rgbOledBmp) & (ccolOledMax - 1)) == (ccolOledMax - 1)) {
00000000  00000000   NOP
1049:                		return;
1050:                	}
1051:                
1052:                	/* Not at the right edge, so go forward one byte
1053:                	 */
1054:                	pbOledCur += 1;
00000020  00000000   NOP
1055:                }
1056:                
1057:                /* ------------------------------------------------------------ */
1058:                
1059:                /***	OledClampXco
1060:                 **
1061:                 **	Parameters:
1062:                 **		xco		- x value to clamp
1063:                 **
1064:                 **	Return Value:
1065:                 **		Returns clamped x value
1066:                 **
1067:                 **	Errors:
1068:                 **		none
1069:                 **
1070:                 **	Description:
1071:                 **		This routine forces the x value to be on the display.
1072:                 */
1073:                
1074:                int32_t OledClampXco(int32_t xco)
1075:                {
00000000  00000000   NOP
1076:                	if (xco < 0) {
0000001C  00000000   NOP
0000002C  00000000   NOP
1077:                		xco = 0;
00000154  00000000   NOP
1078:                	}
1079:                	if (xco >= ccolOledMax) {
00000008  00000000   NOP
00000024  00000000   NOP
00000034  00000000   NOP
1080:                		xco = ccolOledMax - 1;
9D077DD4  240200EF   ADDIU V0, ZERO, 239
0000000C  00000000   NOP
00000028  00000000   NOP
00000038  00000000   NOP
1081:                	}
1082:                
1083:                	return xco;
1084:                }
00000018  00000000   NOP
1085:                
1086:                /* ------------------------------------------------------------ */
1087:                
1088:                /***	OledClampYco
1089:                 **
1090:                 **	Parameters:
1091:                 **		yco		- y value to clamp
1092:                 **
1093:                 **	Return Value:
1094:                 **		Returns clamped y value
1095:                 **
1096:                 **	Errors:
1097:                 **		none
1098:                 **
1099:                 **	Description:
1100:                 **		This routine forces the y value to be on the display.
1101:                 */
1102:                
1103:                int32_t OledClampYco(int32_t yco)
1104:                {
00000000  00000000   NOP
1105:                	if (yco < 0) {
9D077DD8  04A00011   BLTZ A1, 0x9D077E20
9D077DDC  0043200A   MOVZ A0, V0, V1
9D077E18  04A1FFF1   BGEZ A1, 0x9D077DE0
9D077E1C  00002021   ADDU A0, ZERO, ZERO
9D077E20  00001021   ADDU V0, ZERO, ZERO
9D077E24  00003021   ADDU A2, ZERO, ZERO
0000002C  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
00000090  00000000   NOP
0000019C  00000000   NOP
1106:                		yco = 0;
9D077E28  00002821   ADDU A1, ZERO, ZERO
00000098  00000000   NOP
0000014C  00000000   NOP
000001A4  00000000   NOP
1107:                	}
1108:                	if (yco >= crowOledMax) {
9D077DE0  28A20080   SLTI V0, A1, 128
9D077DE4  1440001A   BNE V0, ZERO, .LVL10
9D077DE8  24020007   ADDIU V0, ZERO, 7
9D077DEC  24060E10   ADDIU A2, ZERO, 3600
00000008  00000000   NOP
00000034  00000000   NOP
00000044  00000000   NOP
1109:                		yco = crowOledMax - 1;
9D077DF0  2405007F   ADDIU A1, ZERO, 127
0000000C  00000000   NOP
00000038  00000000   NOP
00000048  00000000   NOP
1110:                	}
1111:                
1112:                	return yco;
1113:                }
00000018  00000000   NOP
1114:                
1115:                /* ------------------------------------------------------------ */
1116:                /***	ProcName
1117:                 **
1118:                 **	Parameters:
1119:                 **
1120:                 **	Return Value:
1121:                 **
1122:                 **	Errors:
1123:                 **
1124:                 **	Description:
1125:                 **
1126:                 */
1127:                
1128:                /* ------------------------------------------------------------ */
1129:                
1130:                /************************************************************************/
1131:                
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/OledDriver.c  ---------
1:                   /************************************************************************/
2:                   /*										*/
3:                   /*	OledDriver.c	-- Graphics Driver Library for OLED Display		*/
4:                   /*										*/
5:                   /************************************************************************/
6:                   /*	Author: 	Gene Apperson						*/
7:                   /*	Copyright 2011, Digilent Inc.						*/
8:                   /************************************************************************/
9:                   /*
10:                    This library is free software; you can redistribute it and/or
11:                    modify it under the terms of the GNU Lesser General Public
12:                    License as published by the Free Software Foundation; either
13:                    version 2.1 of the License, or (at your option) any later version.
14:                  
15:                    This library is distributed in the hope that it will be useful,
16:                    but WITHOUT ANY WARRANTY; without even the implied warranty of
17:                    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
18:                    Lesser General Public License for more details.
19:                  
20:                    You should have received a copy of the GNU Lesser General Public
21:                    License along with this library; if not, write to the Free Software
22:                    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
23:                   */
24:                  /************************************************************************/
25:                  /*  Module Description: 							*/
26:                  /*										*/
27:                  /*	This is part of the device driver software for the OLED bit mapped	*/
28:                  /*	display on the Digilent Basic I/O Shield. This module contains the	*/
29:                  /*	initialization functions and basic display control functions.		*/
30:                  /*										*/
31:                  /************************************************************************/
32:                  /*  Revision History:								*/
33:                  /*										*/
34:                  /*	04/29/2011(GeneA): Created						*/
35:                  /*	08/03/2011(GeneA): added functions to shut down the display and to	*/
36:                  /*		turn the display on and off.					*/
37:                  /*	01/04/2012(GeneA): Changed use of DelayMs to using standard delay	*/
38:                  /*		function. Removed delay.h					*/
39:                  /*	05/11/2017(FGB): convert XC32 and Harmony 2.0				*/
40:                  /*	08/01/2020(FGB): convert to Harmony 3.0 for pic32mk			*/
41:                  /************************************************************************/
42:                  
43:                  
44:                  /* ------------------------------------------------------------ */
45:                  /*				Include File Definitions	*/
46:                  /* ------------------------------------------------------------ */
47:                   
48:                  #include "display_type.h"
49:                  #include "OledDriver.h"
50:                  #include "OledChar.h"
51:                  #include "OledGrph.h"
52:                  #include "dogm-graphic.h"
53:                  #include "tests.h"
54:                  #include "eadog.h"
55:                  
56:                  /* ------------------------------------------------------------ */
57:                  /*				Local Symbol Definitions						*/
58:                  
59:                  /* ------------------------------------------------------------ */
60:                  
61:                  
62:                  
63:                  /* ------------------------------------------------------------ */
64:                  /*				Global Variables								*/
65:                  /* ------------------------------------------------------------ */
66:                  volatile uint8_t dma_flag = 0;
67:                  
68:                  extern uint8_t rgbOledFont0[];
69:                  extern uint8_t rgbOledFontUser[];
70:                  extern uint8_t rgbFillPat[];
71:                  
72:                  extern int32_t xchOledMax;
73:                  extern int32_t ychOledMax;
74:                  
75:                  /* Coordinates of current pixel location on the display. The origin
76:                   ** is at the upper left of the display. X increases to the right
77:                   ** and y increases going down.
78:                   */
79:                  int32_t xcoOledCur;
80:                  int32_t ycoOledCur;
81:                  
82:                  uint8_t * pbOledCur; //address of byte corresponding to current location
83:                  int32_t bnOledCur; //bit number of bit corresponding to current location
84:                  uint8_t clrOledCur; //drawing color to use
85:                  uint8_t * pbOledPatCur; //current fill pattern
86:                  int32_t fOledCharUpdate;
87:                  
88:                  int32_t dxcoOledFontCur;
89:                  int32_t dycoOledFontCur;
90:                  
91:                  uint8_t * pbOledFontCur;
92:                  uint8_t * pbOledFontUser;
93:                  
94:                  /* ------------------------------------------------------------ */
95:                  /*				Local Variables									*/
96:                  /* ------------------------------------------------------------ */
97:                  
98:                  /* This array is the offscreen frame buffer used for rendering.
99:                   ** It isn't possible to read back frome the OLED display device,
100:                  ** so display data is rendered into this offscreen buffer and then
101:                  ** copied to the display.
102:                  */
103:                 uint8_t rgbOledBmp[cbOledDispMax];
104:                 
105:                 /* ------------------------------------------------------------ */
106:                 /*				Forward Declarations							*/
107:                 /* ------------------------------------------------------------ */
108:                 
109:                 void OledHostInit(void);
110:                 void OledHostTerm(void);
111:                 void OledDevInit(void);
112:                 void OledDevTerm(void);
113:                 void OledDvrInit(void);
114:                 void OledPutBuffer(int32_t cb, uint8_t * rgbTx);
115:                 
116:                 uint16_t SPI1_to_Buffer(uint8_t *, uint16_t, uint8_t *);
117:                 
118:                 void RS_SetLow(void);
119:                 void RS_SetHigh(void);
120:                 void CSB_SetLow(void);
121:                 void CSB_SetHigh(void);
122:                 void SPI_Exchange8bit(uint8_t);
123:                 
124:                 
125:                 /* ------------------------------------------------------------ */
126:                 /*				Procedure Definitions							*/
127:                 /* ------------------------------------------------------------ */
128:                 
129:                 /***	OledInit
130:                  **
131:                  **	Parameters:
132:                  **		none
133:                  **
134:                  **	Return Value:
135:                  **		none
136:                  **
137:                  **	Errors:
138:                  **		none
139:                  **
140:                  **	Description:
141:                  **		Initialize the OLED display subsystem.
142:                  */
143:                 
144:                 void OledInit(void)
145:                 {
9D078E88  27BDFFE8   ADDIU SP, SP, -24
9D078E8C  AFBF0014   SW RA, 20(SP)
146:                 	/* Init the PIC32 peripherals used to talk to the display.
147:                 	 */
148:                 	OledHostInit();
149:                 
150:                 	/* Init the memory variables used to control access to the
151:                 	 ** display.
152:                 	 */
153:                 	OledDvrInit();
9D078E90  0F41E0BA   JAL OledDvrInit
9D078E94  00000000   NOP
154:                 
155:                 	/* Init the OLED display hardware.
156:                 	 */
157:                 	OledDevInit();
158:                 
159:                 	/*
160:                 	 * init DMA
161:                 	 */
162:                 #ifdef USE_DMA
163:                 	DMA1_Initialize();
164:                 	/*
165:                 	 * set RX for DMA mode
166:                 	 */
167:                 #endif
168:                 
169:                 	/* Clear the display.
170:                 	 */
171:                 	OledClear();
172:                 }
9D078EB4  8FBF0014   LW RA, 20(SP)
173:                 
174:                 /* ------------------------------------------------------------ */
175:                 
176:                 /***	OledTerm
177:                  **
178:                  **	Parameters:
179:                  **		none
180:                  **
181:                  **	Return Value:
182:                  **		none
183:                  **
184:                  **	Errors:
185:                  **		none
186:                  **
187:                  **	Description:
188:                  **		Shut down the OLED display.
189:                  */
190:                 
191:                 void OledTerm(void)
192:                 {
193:                 	/* Shut down the OLED display hardware.
194:                 	 */
195:                 	OledDevTerm();
196:                 
197:                 	/* Release the PIC32 peripherals being used.
198:                 	 */
199:                 	OledHostTerm();
200:                 }
201:                 
202:                 /* ------------------------------------------------------------ */
203:                 
204:                 /***	OledHostInit
205:                  **
206:                  **	Parameters:
207:                  **		none
208:                  **
209:                  **	Return Value:
210:                  **		none
211:                  **
212:                  **	Errors:
213:                  **		none
214:                  **
215:                  **	Description:
216:                  **		Perform PIC32 device initialization to prepare for use
217:                  **		of the OLED display.
218:                  */
219:                 
220:                 void OledHostInit(void)
221:                 {
222:                 	/*
223:                 	 * dogm does the init
224:                 	 */
225:                 }
226:                 
227:                 /* ------------------------------------------------------------ */
228:                 
229:                 /***	OledHostTerm
230:                  **
231:                  **	Parameters:
232:                  **		none
233:                  **
234:                  **	Return Value:
235:                  **		none
236:                  **
237:                  **	Errors:
238:                  **		none
239:                  **
240:                  **	Description:
241:                  **		Release processor resources used by the library
242:                  */
243:                 
244:                 void OledHostTerm(void)
245:                 {
00000000  00000000   NOP
246:                 	// does nothing, the display and SPI port remains active
247:                 }
248:                 
249:                 /* ------------------------------------------------------------ */
250:                 
251:                 /***	OledDvrInit
252:                  **
253:                  **	Parameters:
254:                  **		none
255:                  **
256:                  **	Return Value:
257:                  **		none
258:                  **
259:                  **	Errors:
260:                  **		none
261:                  **
262:                  **	Description:
263:                  **		Initialize the OLED software system
264:                  */
265:                 
266:                 void OledDvrInit(void)
267:                 {
9D0782E8  27BDFFE8   ADDIU SP, SP, -24
9D0782EC  AFBF0014   SW RA, 20(SP)
268:                 	int32_t ib;
269:                 
270:                 	/* Init the parameters for the default font
271:                 	 */
272:                 	dxcoOledFontCur = cbOledChar;
9D0782F8  24040008   ADDIU A0, ZERO, 8
9D0782FC  00601021   ADDU V0, V1, ZERO
9D078300  AF8480EC   SW A0, -32532(GP)
273:                 	dycoOledFontCur = 8;
9D078304  AF848100   SW A0, -32512(GP)
274:                 	pbOledFontCur = rgbOledFont0;
9D078308  3C049D07   LUI A0, -25337
9D07830C  248440F0   ADDIU A0, A0, 16624
9D078310  AF848110   SW A0, -32496(GP)
275:                 	pbOledFontUser = rgbOledFontUser;
9D0782F0  3C038000   LUI V1, -32768
9D0782F4  246301D8   ADDIU V1, V1, 472
9D078314  AF83810C   SW V1, -32500(GP)
9D078318  24630100   ADDIU V1, V1, 256
276:                 
277:                 	for (ib = 0; ib < cbOledFontUser; ib++) {
9D078324  5443FFFE   BNEL V0, V1, 0x9D078320
9D078328  A0400000   SB ZERO, 0(V0)
278:                 		rgbOledFontUser[ib] = 0;
9D07831C  A0400000   SB ZERO, 0(V0)
9D078320  24420001   ADDIU V0, V0, 1
279:                 	}
280:                 
281:                 	xchOledMax = ccolOledMax / dxcoOledFontCur;
9D078334  2402001E   ADDIU V0, ZERO, 30
9D078338  AF8280D8   SW V0, -32552(GP)
282:                 	ychOledMax = crowOledMax / dycoOledFontCur;
9D07833C  24020010   ADDIU V0, ZERO, 16
283:                 
284:                 	/* Set the default character cursor position.
285:                 	 */
286:                 	OledSetCursor(0, 0);
9D07832C  00002021   ADDU A0, ZERO, ZERO
9D078330  00002821   ADDU A1, ZERO, ZERO
9D078340  0F41E328   JAL OledSetCursor
9D078344  AF8280D4   SW V0, -32556(GP)
287:                 
288:                 	/* Set the default foreground draw color and fill pattern
289:                 	 */
290:                 	clrOledCur = 0x01;
9D07834C  24020001   ADDIU V0, ZERO, 1
9D078350  A38280E8   SB V0, -32536(GP)
291:                 	pbOledPatCur = rgbFillPat;
9D078354  3C029D08   LUI V0, -25336
9D078358  24428D20   ADDIU V0, V0, -29408
292:                 	OledSetDrawMode(modOledSet);
9D078348  00002021   ADDU A0, ZERO, ZERO
9D07835C  0F41E17F   JAL OledSetDrawMode
9D078360  AF828104   SW V0, -32508(GP)
293:                 
294:                 	/* Default the character routines to manual
295:                 	 ** updates to the display.
296:                 	 */
297:                 	fOledCharUpdate = 0;
9D078364  AF8080F4   SW ZERO, -32524(GP)
298:                 }
9D078368  8FBF0014   LW RA, 20(SP)
9D07836C  03E00008   JR RA
9D078370  27BD0018   ADDIU SP, SP, 24
299:                 
300:                 /* ------------------------------------------------------------ */
301:                 
302:                 /***	OledDevInit
303:                  **
304:                  **	Parameters:
305:                  **		none
306:                  **
307:                  **	Return Value:
308:                  **		none
309:                  **
310:                  **	Errors:
311:                  **		none
312:                  **
313:                  **	Description:
314:                  **		Initialize the OLED display controller and turn the display on.
315:                  */
316:                 
317:                 
318:                 void OledDevInit(void)
319:                 {
320:                 	/*
321:                 	 * handled by dogm-graphics
322:                 	 */
323:                 }
324:                 
325:                 /* ------------------------------------------------------------ */
326:                 
327:                 /***	OledDevTerm
328:                  **
329:                  **	Parameters:
330:                  **		none
331:                  **
332:                  **	Return Value:
333:                  **		none
334:                  **
335:                  **	Errors:
336:                  **		none
337:                  **
338:                  **	Description:
339:                  **		Shut down the OLED display hardware
340:                  */
341:                 
342:                 void OledDevTerm(void)
343:                 {
344:                 	/* Send the Display Off command.
345:                 	 * does nothing
346:                 	 */
347:                 }
348:                 
349:                 /* ------------------------------------------------------------ */
350:                 
351:                 /***	OledDisplayOn
352:                  **
353:                  **	Parameters:
354:                  **		none
355:                  **
356:                  **	Return Value:
357:                  **		none
358:                  **
359:                  **	Errors:
360:                  **		none
361:                  **
362:                  **	Description:
363:                  **		Turn the display on. This assumes that the display has
364:                  **		already been powered on and initialized. All it does
365:                  **		is send the display on command.
366:                  */
367:                 
368:                 void OledDisplayOn(void)
369:                 {
370:                 	/*
371:                 	 * does nothing
372:                 	 */
373:                 }
374:                 
375:                 /* ------------------------------------------------------------ */
376:                 
377:                 /***	OledDisplayOff
378:                  **
379:                  **	Parameters:
380:                  **		none
381:                  **
382:                  **	Return Value:
383:                  **		none
384:                  **
385:                  **	Errors:
386:                  **		none
387:                  **
388:                  **	Description:
389:                  **		Turn the display off. This does not power the display
390:                  **		down. All it does is send the display off command.
391:                  */
392:                 
393:                 void OledDisplayOff(void)
394:                 {
00000000  00000000   NOP
395:                 	/*
396:                 	 * does nothing
397:                 	 */
398:                 }
399:                 
400:                 /* ------------------------------------------------------------ */
401:                 
402:                 /***	OledClear
403:                  **
404:                  **	Parameters:
405:                  **		none
406:                  **
407:                  **	Return Value:
408:                  **		none
409:                  **
410:                  **	Errors:
411:                  **		none
412:                  **
413:                  **	Description:
414:                  **		Clear the display. This clears the memory buffer and then
415:                  **		updates the display.
416:                  */
417:                 
418:                 void OledClear(void)
419:                 {
420:                 	OledClearBuffer();
421:                 	OledUpdate();
9D078EB8  0B41E23E   J OledUpdate
9D078EBC  27BD0018   ADDIU SP, SP, 24
0000001C  00000000   NOP
422:                 }
423:                 
424:                 /* ------------------------------------------------------------ */
425:                 
426:                 /***	OledClearBuffer
427:                  **
428:                  **	Parameters:
429:                  **		none
430:                  **
431:                  **	Return Value:
432:                  **		none
433:                  **
434:                  **	Errors:
435:                  **		none
436:                  **
437:                  **	Description:
438:                  **		Clear the display memory buffer.
439:                  */
440:                 
441:                 void OledClearBuffer(void)
442:                 {
443:                 	int32_t ib;
444:                 	uint8_t * pb;
445:                 
446:                 	pb = rgbOledBmp;
9D078E98  3C028000   LUI V0, -32768
00000000  00000000   NOP
447:                 
448:                 	/* Fill the memory buffer with 0.
449:                 	 */
450:                 	for (ib = 0; ib < cbOledDispMax; ib++) {
9D078EAC  1443FFFE   BNE V0, V1, .LVL34
00000014  00000000   NOP
451:                 		*pb++ = 0x00;
9D078EA8  24420001   ADDIU V0, V0, 1
00000010  00000000   NOP
452:                 	}
453:                 }
0000001C  00000000   NOP
454:                 
455:                 /* ------------------------------------------------------------ */
456:                 
457:                 /***	OledUpdate
458:                  **
459:                  **	Parameters:
460:                  **		none
461:                  **
462:                  **	Return Value:
463:                  **		none
464:                  **
465:                  **	Errors:
466:                  **		none
467:                  **
468:                  **	Description:
469:                  **		Update the OLED display with the contents of the memory buffer
470:                  */
471:                 
472:                 void OledUpdate(void)
473:                 {
9D0788F8  27BDFFE0   ADDIU SP, SP, -32
9D0788FC  AFBF001C   SW RA, 28(SP)
9D078900  AFB20018   SW S2, 24(SP)
9D078904  AFB10014   SW S1, 20(SP)
9D078908  AFB00010   SW S0, 16(SP)
474:                 #ifdef EDOGS
475:                 	int32_t ipag;
476:                 	uint8_t* pb;
477:                 
478:                 	pb = rgbOledBmp;
9D07890C  3C118000   LUI S1, -32768
9D078910  263102D8   ADDIU S1, S1, 728
479:                 
480:                 	for (ipag = 0; ipag < cpagOledMax; ipag++) {
9D078914  00008021   ADDU S0, ZERO, ZERO
9D078918  24120010   ADDIU S2, ZERO, 16
9D07893C  1612FFF7   BNE S0, S2, .LVL23
9D078940  263100F0   ADDIU S1, S1, 240
481:                 		/* Set the page address
482:                 		 */
483:                 		//Set page command
484:                 		//page number
485:                 		/* Start at the left column
486:                 		 */
487:                 		//set low nibble of column
488:                 		//set high nibble of column
489:                 		lcd_moveto_xy(ipag, 0);
9D07891C  320400FF   ANDI A0, S0, 255
9D078920  0F41E26F   JAL lcd_moveto_xy
9D078924  00002821   ADDU A1, ZERO, ZERO
490:                 		/* Copy this memory page of display data.
491:                 		 */
492:                 		OledPutBuffer(ccolOledMax, pb);
493:                 		pb += ccolOledMax;
494:                 	}
495:                 #endif
496:                 }
9D078944  8FBF001C   LW RA, 28(SP)
9D078948  8FB20018   LW S2, 24(SP)
9D07894C  8FB10014   LW S1, 20(SP)
9D078950  8FB00010   LW S0, 16(SP)
9D078954  03E00008   JR RA
9D078958  27BD0020   ADDIU SP, SP, 32
497:                 
498:                 /* ------------------------------------------------------------ */
499:                 
500:                 /***	OledPutBuffer
501:                  **
502:                  **	Parameters:
503:                  **		cb		- number of bytes to send
504:                  **		rgbTx	- pointer to the buffer to send
505:                  **
506:                  **	Return Value:
507:                  **		none
508:                  **
509:                  **	Errors:
510:                  **		none
511:                  **
512:                  **	Description:
513:                  **		Send the bytes specified in rgbTx to the slave OLED
514:                  */
515:                 
516:                 
517:                 void OledPutBuffer(int32_t cb, uint8_t * rgbTx)
518:                 {
00000000  00000000   NOP
519:                 	SPI1_to_Buffer(rgbTx, cb, NULL);
9D078928  02202021   ADDU A0, S1, ZERO
9D07892C  240500F0   ADDIU A1, ZERO, 240
9D078930  00003021   ADDU A2, ZERO, ZERO
9D078934  0F41E20A   JAL SPI1_to_Buffer
9D078938  26100001   ADDIU S0, S0, 1
520:                 }
521:                 
522:                 uint16_t SPI1_to_Buffer(uint8_t *dataIn, uint16_t bufLen, uint8_t *dataOut)
523:                 {
9D078828  27BDFFE0   ADDIU SP, SP, -32
9D07882C  AFBF001C   SW RA, 28(SP)
9D078830  AFB10018   SW S1, 24(SP)
9D078834  AFB00014   SW S0, 20(SP)
9D078838  00808821   ADDU S1, A0, ZERO
9D07883C  00A08021   ADDU S0, A1, ZERO
524:                 	uint16_t bytesWritten = 0;
525:                 
526:                 #ifdef USE_DMA
527:                 	PWM8_LoadDutyValue(1);
528:                 	while (dma_flag);
529:                 
530:                 	SPI1CON0bits.EN = 0;
531:                 	SPI1CON2 = 0x02; //  Received data is not stored in the FIFO
532:                 	SPI1CON0bits.EN = 1;
533:                 	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
534:                 	DMA1SSA = (uint24_t) & dataIn[0];
535:                 	//	DMA1SSZ = (uint16_t) bufLen;
536:                 	DMA1SSZ = 16;
537:                 	DMA1CON0bits.EN = 1;
538:                 	dma_flag = 1;
539:                 	DMA1CON0bits.DMA1SIRQEN = 1; /* start DMA trigger */
540:                 
541:                 	return bufLen;
542:                 #else
543:                 	while (SPI1_IsBusy());
9D078840  0F41E404   JAL SPI1_IsBusy
9D078844  00000000   NOP
9D078848  1440FFFD   BNE V0, ZERO, .LVL11
9D07884C  00000000   NOP
544:                 	LCD_SELECT();
9D078850  0F41E458   JAL .LFB16, .LFE15, CSB_SetLow
9D078854  00000000   NOP
545:                 	LCD_DRAM();
9D078858  0F41E453   JAL .LFB15, .LFE14, RS_SetHigh
9D07885C  00000000   NOP
546:                 	if (bufLen != 0) {
9D078860  12000003   BEQ S0, ZERO, .LVL15
9D078864  02202021   ADDU A0, S1, ZERO
547:                 #ifdef EDOGS
548:                 		SPI_ExchangeBuffer(dataIn, bufLen);
9D078868  0F41E488   JAL SPI_ExchangeBuffer
9D07886C  02002821   ADDU A1, S0, ZERO
549:                 		bytesWritten = bufLen;
550:                 #endif
551:                 #ifdef EDOGM
552:                 		if (dataIn != NULL) {
553:                 			while (bytesWritten < bufLen) {
554:                 				if (dataOut == NULL) {
555:                 					SPI_Exchange8bit(dataIn[bytesWritten]);
556:                 				} else {
557:                 					SPI_Exchange8bit(dataIn[bytesWritten]);
558:                 				}
559:                 				lcd_inc_column(1);
560:                 				bytesWritten++;
561:                 			}
562:                 		} else {
563:                 			if (dataOut != NULL) {
564:                 				while (bytesWritten < bufLen) {
565:                 					SPI_Exchange8bit(0xff);
566:                 					lcd_inc_column(1);
567:                 					bytesWritten++;
568:                 				}
569:                 			}
570:                 		}
571:                 #endif
572:                 	}
573:                 	LCD_UNSELECT();
9D078870  0F41E45D   JAL .LFB17, .LFE16, CSB_SetHigh
9D078874  00000000   NOP
574:                 	return bytesWritten;
575:                 #endif
576:                 }
9D078878  02001021   ADDU V0, S0, ZERO
9D07887C  8FBF001C   LW RA, 28(SP)
9D078880  8FB10018   LW S1, 24(SP)
9D078884  8FB00014   LW S0, 20(SP)
9D078888  03E00008   JR RA
9D07888C  27BD0020   ADDIU SP, SP, 32
577:                 
578:                 void wait_lcd_done(void)
579:                 {
00000000  00000000   NOP
580:                 #ifdef USE_DMA
581:                 	while (dma_flag);
582:                 #endif
583:                 	while (SPI1_IsBusy());
00000008  00000000   NOP
584:                 }
00000018  00000000   NOP
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/src/OledChar.c  -----------
1:                   /************************************************************************/
2:                   /*																		*/
3:                   /*	OledChar.c	--	Character Output Routines for OLED Display			*/
4:                   /*																		*/
5:                   /************************************************************************/
6:                   /*	Author: 	Gene Apperson											*/
7:                   /*	Copyright 2011, Digilent Inc.										*/
8:                   /************************************************************************/
9:                   /*
10:                    This library is free software; you can redistribute it and/or
11:                    modify it under the terms of the GNU Lesser General Public
12:                    License as published by the Free Software Foundation; either
13:                    version 2.1 of the License, or (at your option) any later version.
14:                  
15:                    This library is distributed in the hope that it will be useful,
16:                    but WITHOUT ANY WARRANTY; without even the implied warranty of
17:                    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
18:                    Lesser General Public License for more details.
19:                  
20:                    You should have received a copy of the GNU Lesser General Public
21:                    License along with this library; if not, write to the Free Software
22:                    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
23:                   */
24:                  /************************************************************************/
25:                  /*  Module Description: 												*/
26:                  /*																		*/
27:                  /*	This module contains the implementations of the 'character mode'	*/
28:                  /*	functions. These functions treat the graphics display as a 4 row	*/
29:                  /*	by 16 column character display.										*/
30:                  /*																		*/
31:                  /************************************************************************/
32:                  /*  Revision History:													*/
33:                  /*																		*/
34:                  /*	06/01/2011(GeneA): created											*/
35:                  /*																		*/
36:                  /************************************************************************/
37:                  
38:                  
39:                  /* ------------------------------------------------------------ */
40:                  /*				Include File Definitions						*/
41:                  /* ------------------------------------------------------------ */
42:                  
43:                  #include <stdint.h>
44:                  
45:                  #include <inttypes.h>
46:                  
47:                  #include "OledDriver.h"
48:                  #include "OledChar.h"
49:                  #include "OledGrph.h"
50:                  #include "eadog.h"
51:                  
52:                  /* ------------------------------------------------------------ */
53:                  /*				Local Type Definitions							*/
54:                  /* ------------------------------------------------------------ */
55:                  
56:                  
57:                  /* ------------------------------------------------------------ */
58:                  /*				Global Variables								*/
59:                  /* ------------------------------------------------------------ */
60:                  
61:                  extern int32_t xcoOledCur;
62:                  extern int32_t ycoOledCur;
63:                  
64:                  extern uint8_t * pbOledCur;
65:                  extern uint8_t mskOledCur;
66:                  extern int32_t bnOledCur;
67:                  extern int32_t fOledCharUpdate;
68:                  
69:                  extern uint8_t rgbOledBmp[];
70:                  
71:                  extern int32_t dxcoOledFontCur;
72:                  extern int32_t dycoOledFontCur;
73:                  
74:                  extern uint8_t * pbOledFontCur;
75:                  extern uint8_t * pbOledFontUser;
76:                  
77:                  /* ------------------------------------------------------------ */
78:                  /*				Local Variables									*/
79:                  /* ------------------------------------------------------------ */
80:                  
81:                  int32_t xchOledCur;
82:                  int32_t ychOledCur;
83:                  
84:                  int32_t xchOledMax;
85:                  int32_t ychOledMax;
86:                  
87:                  uint8_t * pbOledFontExt;
88:                  
89:                  uint8_t rgbOledFontUser[cbOledFontUser];
90:                  
91:                  /* ------------------------------------------------------------ */
92:                  /*				Forward Declarations							*/
93:                  /* ------------------------------------------------------------ */
94:                  
95:                  void OledDrawGlyph(char ch);
96:                  void OledAdvanceCursor(void);
97:                  
98:                  /* ------------------------------------------------------------ */
99:                  /*				Procedure Definitions							*/
100:                 /* ------------------------------------------------------------ */
101:                 
102:                 /***	OledSetCursor
103:                  **
104:                  **	Parameters:
105:                  **		xch			- horizontal character position
106:                  **		ych			- vertical character position
107:                  **
108:                  **	Return Value:
109:                  **		none
110:                  **
111:                  **	Errors:
112:                  **		none
113:                  **
114:                  **	Description:
115:                  **		Set the character cursor position to the specified location.
116:                  **		If either the specified X or Y location is off the display, it
117:                  **		is clamped to be on the display.
118:                  */
119:                 
120:                 void OledSetCursor(int32_t xch, int32_t ych)
121:                 {
9D078CA8  00801021   ADDU V0, A0, ZERO
122:                 	/* Clamp the specified location to the display surface
123:                 	 */
124:                 	if (xch >= xchOledMax) {
9D078CA0  8F8680D8   LW A2, -32552(GP)
9D078CAC  0086382A   SLT A3, A0, A2
125:                 		xch = xchOledMax - 1;
9D078CB0  24C6FFFF   ADDIU A2, A2, -1
9D078CBC  00C7100A   MOVZ V0, A2, A3
126:                 	}
127:                 
128:                 	if (ych >= ychOledMax) {
9D078CA4  8F8380D4   LW V1, -32556(GP)
9D078CB4  00A3202A   SLT A0, A1, V1
129:                 		ych = ychOledMax - 1;
9D078CB8  2463FFFF   ADDIU V1, V1, -1
9D078CC0  0064280A   MOVZ A1, V1, A0
130:                 	}
131:                 
132:                 	/* Save the given character location.
133:                 	 */
134:                 	xchOledCur = xch;
9D078CCC  AF8280E0   SW V0, -32544(GP)
135:                 	ychOledCur = ych;
9D078CD0  AF8580E4   SW A1, -32540(GP)
136:                 
137:                 	/* Convert the character location to a frame buffer address.
138:                 	 */
139:                 	OledMoveTo(xch*dxcoOledFontCur, ych * dycoOledFontCur);
9D078CC4  8F8480EC   LW A0, -32532(GP)
9D078CC8  70442002   MUL A0, V0, A0
9D078CD4  8F828100   LW V0, -32512(GP)
9D078CD8  0B41DF73   J OledMoveTo
9D078CDC  70A22802   MUL A1, A1, V0
140:                 }
141:                 
142:                 /* ------------------------------------------------------------ */
143:                 
144:                 /***	OledGetCursor
145:                  **
146:                  **	Parameters:
147:                  **		pxch		- pointer to variable to receive horizontal position
148:                  **		pych		- pointer to variable to receive vertical position
149:                  **
150:                  **	Return Value:
151:                  **		none
152:                  **
153:                  **	Errors:
154:                  **		none
155:                  **
156:                  **	Description:
157:                  **		Fetch the current cursor position
158:                  */
159:                 
160:                 void OledGetCursor(int32_t * pxch, int32_t * pych)
161:                 {
162:                 	*pxch = xchOledCur;
00000000  00000000   NOP
163:                 	*pych = ychOledCur;
00000008  00000000   NOP
164:                 }
165:                 
166:                 /* ------------------------------------------------------------ */
167:                 
168:                 /***	OledDefUserChar
169:                  **
170:                  **	Parameters:
171:                  **		ch		- character code to define
172:                  **		pbDef	- definition for the character
173:                  **
174:                  **	Return Value:
175:                  **		none
176:                  **
177:                  **	Errors:
178:                  **		Returns TRUE if successful, FALSE if not
179:                  **
180:                  **	Description:
181:                  **		Give a definition for the glyph for the specified user
182:                  **		character code. User definable character codes are in
183:                  **		the range 0x00 - 0x1F. If the code specified by ch is
184:                  **		outside this range, the function returns false.
185:                  */
186:                 
187:                 int32_t OledDefUserChar(char ch, uint8_t * pbDef)
188:                 {
189:                 	uint8_t * pb;
190:                 	int32_t ib;
191:                 
192:                 	if (ch < chOledUserMax) {
00000000  00000000   NOP
193:                 		pb = pbOledFontUser + ch * cbOledChar;
0000000C  00000000   NOP
194:                 		for (ib = 0; ib < cbOledChar; ib++) {
00000028  00000000   NOP
195:                 			*pb++ = *pbDef++;
0000001C  00000000   NOP
196:                 		}
197:                 		return 1;
00000030  00000000   NOP
198:                 	} else {
199:                 		return 0;
200:                 	}
201:                 }
00000034  00000000   NOP
202:                 
203:                 /* ------------------------------------------------------------ */
204:                 
205:                 /***	OledSetCharUpdate
206:                  **
207:                  **	Parameters:
208:                  **		f		- enable/disable automatic update
209:                  **
210:                  **	Return Value:
211:                  **		none
212:                  **
213:                  **	Errors:
214:                  **		none
215:                  **
216:                  **	Description:
217:                  **		Set the character update mode. This determines whether
218:                  **		or not the display is automatically updated after a
219:                  **		character or string is drawn. A non-zero value turns
220:                  **		automatic updating on.
221:                  */
222:                 
223:                 void OledSetCharUpdate(int32_t f)
224:                 {
225:                 	fOledCharUpdate = (f != 0) ? 1 : 0;
9D0791E8  0004202B   SLTU A0, ZERO, A0
9D0791EC  03E00008   JR RA
9D0791F0  AF8480F4   SW A0, -32524(GP)
226:                 }
227:                 
228:                 /* ------------------------------------------------------------ */
229:                 
230:                 /***	OledGetCharUpdate
231:                  **
232:                  **	Parameters:
233:                  **		none
234:                  **
235:                  **	Return Value:
236:                  **		returns current character update mode
237:                  **
238:                  **	Errors:
239:                  **		none
240:                  **
241:                  **	Description:
242:                  **		Return the current character update mode.
243:                  */
244:                 
245:                 int32_t OledGetCharUpdate(void)
246:                 {
247:                 	return fOledCharUpdate;
248:                 }
249:                 
250:                 /* ------------------------------------------------------------ */
251:                 
252:                 /***	OledPutChar
253:                  **
254:                  **	Parameters:
255:                  **		ch			- character to write to display
256:                  **
257:                  **	Return Value:
258:                  **		none
259:                  **
260:                  **	Errors:
261:                  **		none
262:                  **
263:                  **	Description:
264:                  **		Write the specified character to the display at the current
265:                  **		cursor position and advance the cursor.
266:                  */
267:                 
268:                 void OledPutChar(char ch)
269:                 {
00000000  00000000   NOP
270:                 	OledDrawGlyph(ch);
00000008  00000000   NOP
271:                 	OledAdvanceCursor();
00000010  00000000   NOP
272:                 	if (fOledCharUpdate) {
00000018  00000000   NOP
273:                 		OledUpdate();
0000002C  00000000   NOP
274:                 	}
275:                 }
00000024  00000000   NOP
276:                 
277:                 /* ------------------------------------------------------------ */
278:                 
279:                 /***	OledPutString
280:                  **
281:                  **	Parameters:
282:                  **		sz		- pointer to the null terminated string
283:                  **
284:                  **	Return Value:
285:                  **		none
286:                  **
287:                  **	Errors:
288:                  **		none
289:                  **
290:                  **	Description:
291:                  **		Write the specified null terminated character string to the
292:                  **		display and advance the cursor.
293:                  */
294:                 
295:                 void OledPutString(char * sz)
296:                 {
9D078A1C  27BDFFE8   ADDIU SP, SP, -24
9D078A20  AFBF0014   SW RA, 20(SP)
9D078A24  AFB00010   SW S0, 16(SP)
9D078A28  00808021   ADDU S0, A0, ZERO
297:                 	sz[max_strlen]='\0';
298:                 	while (*sz != '\0') {
9D078A2C  80840000   LB A0, 0(A0)
9D078A30  10800008   BEQ A0, ZERO, 0x9D078A54
9D078A34  A200009F   SB ZERO, 159(S0)
9D078A48  82040000   LB A0, 0(S0)
9D078A4C  1480FFFA   BNE A0, ZERO, 0x9D078A38
9D078A50  00000000   NOP
299:                 		OledDrawGlyph(*sz);
9D078A38  0F41E1F0   JAL OledDrawGlyph
9D078A3C  26100001   ADDIU S0, S0, 1
300:                 		OledAdvanceCursor();
9D078A40  0F41E2C9   JAL OledAdvanceCursor
9D078A44  00000000   NOP
301:                 		sz += 1;
302:                 	}
303:                 
304:                 	if (fOledCharUpdate) {
9D078A54  8F8280F4   LW V0, -32524(GP)
9D078A58  14400004   BNE V0, ZERO, .LVL35
9D078A5C  8FBF0014   LW RA, 20(SP)
305:                 		OledUpdate();
9D078A70  0B41E23E   J OledUpdate
9D078A74  27BD0018   ADDIU SP, SP, 24
306:                 	}
307:                 }
9D078A60  8FB00010   LW S0, 16(SP)
9D078A64  03E00008   JR RA
9D078A68  27BD0018   ADDIU SP, SP, 24
9D078A6C  8FB00010   LW S0, 16(SP)
9D078A70  0B41E23E   J OledUpdate
9D078A74  27BD0018   ADDIU SP, SP, 24
308:                 
309:                 /* ------------------------------------------------------------ */
310:                 
311:                 /***	OledDrawGlyph
312:                  **
313:                  **	Parameters:
314:                  **		ch		- character code of character to draw
315:                  **
316:                  **	Return Value:
317:                  **		none
318:                  **
319:                  **	Errors:
320:                  **		none
321:                  **
322:                  **	Description:
323:                  **		Renders the specified character into the display buffer
324:                  **		at the current character cursor location. This does not
325:                  **		affect the current character cursor location or the 
326:                  **		current drawing position in the display buffer.
327:                  */
328:                 
329:                 void OledDrawGlyph(char ch)
330:                 {
331:                 	uint8_t * pbFont;
332:                 	uint8_t * pbBmp;
333:                 	int ib;
334:                 
335:                 	if ((ch & 0x80) != 0) {
9D0787C0  04800013   BLTZ A0, .LVL22
9D0787C4  28820020   SLTI V0, A0, 32
336:                 		return;
337:                 	}
338:                 
339:                 	if (ch < chOledUserMax) {
9D0787C8  50400013   BEQL V0, ZERO, 0x9D078818
9D0787CC  2484FFE0   ADDIU A0, A0, -32
340:                 		pbFont = pbOledFontUser + ch*cbOledChar;
9D0787D0  000420C0   SLL A0, A0, 3
9D0787D4  8F86810C   LW A2, -32500(GP)
9D0787D8  00C43021   ADDU A2, A2, A0
341:                 	} else if ((ch & 0x80) == 0) {
342:                 		pbFont = pbOledFontCur + (ch - chOledUserMax) * cbOledChar;
9D078818  000420C0   SLL A0, A0, 3
9D07881C  8F868110   LW A2, -32496(GP)
9D078820  0B41E1F7   J .LVL17
9D078824  00C43021   ADDU A2, A2, A0
343:                 	}
344:                 
345:                 	pbBmp = pbOledCur;
346:                 
347:                 	for (ib = 0; ib < dxcoOledFontCur; ib++) {
9D0787DC  8F8280EC   LW V0, -32532(GP)
9D0787E0  1840000B   BLEZ V0, .LVL22
9D0787E4  8F838108   LW V1, -32504(GP)
9D0787E8  00C01021   ADDU V0, A2, ZERO
9D078800  8F8480EC   LW A0, -32532(GP)
9D078804  00A4202A   SLT A0, A1, A0
9D078808  1480FFF9   BNE A0, ZERO, .LVL19
9D07880C  24420001   ADDIU V0, V0, 1
9D078810  03E00008   JR RA
9D078814  00000000   NOP
348:                 		*pbBmp++ = *pbFont++;
9D0787EC  24420001   ADDIU V0, V0, 1
9D0787F0  9044FFFF   LBU A0, -1(V0)
9D0787F4  24630001   ADDIU V1, V1, 1
9D0787F8  00462823   SUBU A1, V0, A2
9D0787FC  A064FFFF   SB A0, -1(V1)
9D078800  8F8480EC   LW A0, -32532(GP)
9D078804  00A4202A   SLT A0, A1, A0
9D078808  1480FFF9   BNE A0, ZERO, .LVL19
9D07880C  24420001   ADDIU V0, V0, 1
9D078810  03E00008   JR RA
9D078814  00000000   NOP
9D078818  000420C0   SLL A0, A0, 3
9D07881C  8F868110   LW A2, -32496(GP)
9D078820  0B41E1F7   J .LVL17
9D078824  00C43021   ADDU A2, A2, A0
349:                 	}
350:                 
351:                 }
352:                 
353:                 /* ------------------------------------------------------------ */
354:                 
355:                 /***	OledAdvanceCursor
356:                  **
357:                  **	Parameters:
358:                  **		none
359:                  **
360:                  **	Return Value:
361:                  **		none
362:                  **
363:                  **	Errors:
364:                  **		none
365:                  **
366:                  **	Description:
367:                  **		Advance the character cursor by one character location,
368:                  **		wrapping at the end of line and back to the top at the
369:                  **		end of the display.
370:                  */
371:                 
372:                 void OledAdvanceCursor(void)
373:                 {
374:                 
375:                 	xchOledCur += 1;
9D078B24  8F8480E0   LW A0, -32544(GP)
9D078B28  24840001   ADDIU A0, A0, 1
376:                 	if (xchOledCur >= xchOledMax) {
9D078B2C  8F8280D8   LW V0, -32552(GP)
9D078B30  0082102A   SLT V0, A0, V0
9D078B34  1040000A   BEQ V0, ZERO, .LVL25
9D078B38  AF8480E0   SW A0, -32544(GP)
9D078B3C  8F8580E4   LW A1, -32540(GP)
377:                 		xchOledCur = 0;
9D078B60  AF8080E0   SW ZERO, -32544(GP)
378:                 		ychOledCur += 1;
9D078B64  00002021   ADDU A0, ZERO, ZERO
9D078B68  8F8580E4   LW A1, -32540(GP)
9D078B6C  24A50001   ADDIU A1, A1, 1
9D078B70  0B41E2D0   J 0x9D078B40
9D078B74  AF8580E4   SW A1, -32540(GP)
379:                 	}
380:                 	if (ychOledCur >= ychOledMax) {
9D078B40  8F8280D4   LW V0, -32556(GP)
9D078B44  00A2102A   SLT V0, A1, V0
9D078B48  14400003   BNE V0, ZERO, 0x9D078B58
9D078B4C  00000000   NOP
381:                 		ychOledCur = 0;
9D078B50  AF8080E4   SW ZERO, -32540(GP)
9D078B54  00002821   ADDU A1, ZERO, ZERO
382:                 	}
383:                 
384:                 	OledSetCursor(xchOledCur, ychOledCur);
9D078B58  0B41E328   J OledSetCursor
9D078B5C  00000000   NOP
9D078B60  AF8080E0   SW ZERO, -32544(GP)
9D078B64  00002021   ADDU A0, ZERO, ZERO
9D078B68  8F8580E4   LW A1, -32540(GP)
9D078B6C  24A50001   ADDIU A1, A1, 1
9D078B70  0B41E2D0   J 0x9D078B40
9D078B74  AF8580E4   SW A1, -32540(GP)
385:                 
386:                 }
387:                 
388:                 /* ------------------------------------------------------------ */
389:                 /***	ProcName
390:                  **
391:                  **	Parameters:
392:                  **
393:                  **	Return Value:
394:                  **
395:                  **	Errors:
396:                  **
397:                  **	Description:
398:                  **
399:                  */
400:                 
401:                 /* ------------------------------------------------------------ */
402:                 
403:                 /************************************************************************/
404:                 
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/pic32mk_mcj_curiosity_pro.X/MahonyAHRS/MahonyAHRS.c
1:                   //=====================================================================================================
2:                   // MahonyAHRS.c
3:                   //=====================================================================================================
4:                   //
5:                   // Madgwick's implementation of Mayhony's AHRS algorithm.
6:                   // See: http://www.x-io.co.uk/node/8#open_source_ahrs_and_imu_algorithms
7:                   //
8:                   // Date			Author			Notes
9:                   // 29/09/2011	SOH Madgwick    Initial release
10:                  // 02/10/2011	SOH Madgwick	Optimised for reduced CPU load
11:                  //
12:                  //=====================================================================================================
13:                  
14:                  //---------------------------------------------------------------------------------------------------
15:                  // Header files
16:                  
17:                  #include "MahonyAHRS.h"
18:                  #include <math.h>
19:                  
20:                  //---------------------------------------------------------------------------------------------------
21:                  // Definitions
22:                  
23:                  #define sampleFreq	100.0f			// sample frequency in Hz
24:                  #define twoKpDef	(2.0f * 0.5f)	// 2 * proportional gain
25:                  #define twoKiDef	(2.0f * 0.0f)	// 2 * integral gain
26:                  
27:                  //---------------------------------------------------------------------------------------------------
28:                  // Variable definitions
29:                  
30:                  volatile float twoKp = twoKpDef; // 2 * proportional gain (Kp)
31:                  volatile float twoKi = twoKiDef; // 2 * integral gain (Ki)
32:                  static volatile float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f; // quaternion of sensor frame relative to auxiliary frame
33:                  volatile float integralFBx = 0.0f, integralFBy = 0.0f, integralFBz = 0.0f; // integral error terms scaled by Ki
34:                  
35:                  //---------------------------------------------------------------------------------------------------
36:                  // Function declarations
37:                  
38:                  static float invSqrt(float x);
39:                  
40:                  //====================================================================================================
41:                  // Functions
42:                  
43:                  //---------------------------------------------------------------------------------------------------
44:                  // AHRS algorithm update
45:                  
46:                  void MahonyAHRSupdate(float gx, float gy, float gz, float ax, float ay, float az, float mx, float my, float mz)
47:                  {
00000000  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
00000050  00000000   NOP
48:                  	float recipNorm;
49:                  	float q0q0, q0q1, q0q2, q0q3, q1q1, q1q2, q1q3, q2q2, q2q3, q3q3;
50:                  	float hx, hy, bx, bz;
51:                  	float halfvx, halfvy, halfvz, halfwx, halfwy, halfwz;
52:                  	float halfex, halfey, halfez;
53:                  	float qa, qb, qc;
54:                  
55:                  	// Use IMU algorithm if magnetometer measurement invalid (avoids NaN in magnetometer normalisation)
56:                  	if ((mx == 0.0f) && (my == 0.0f) && (mz == 0.0f)) {
00000044  00000000   NOP
0000004C  00000000   NOP
00000068  00000000   NOP
000004DC  00000000   NOP
57:                  		MahonyAHRSupdateIMU(gx, gy, gz, ax, ay, az);
00000520  00000000   NOP
58:                  		return;
59:                  	}
60:                  
61:                  	// Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)
62:                  	if (!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {
0000007C  00000000   NOP
000004C8  00000000   NOP
63:                  
64:                  		// Normalise accelerometer measurement
65:                  		recipNorm = invSqrt(ax * ax + ay * ay + az * az);
0000012C  00000000   NOP
00000150  00000000   NOP
00000170  00000000   NOP
66:                  		ax *= recipNorm;
000001E8  00000000   NOP
67:                  		ay *= recipNorm;
000001EC  00000000   NOP
68:                  		az *= recipNorm;
000001F4  00000000   NOP
69:                  
70:                  		// Normalise magnetometer measurement
71:                  		recipNorm = invSqrt(mx * mx + my * my + mz * mz);
00000094  00000000   NOP
000000B0  00000000   NOP
000000CC  00000000   NOP
72:                  		mx *= recipNorm;
0000018C  00000000   NOP
73:                  		my *= recipNorm;
00000188  00000000   NOP
74:                  		mz *= recipNorm;
00000190  00000000   NOP
75:                  
76:                  		// Auxiliary variables to avoid repeated arithmetic
77:                  		q0q0 = q0 * q0;
000000B4  00000000   NOP
000001BC  00000000   NOP
78:                  		q0q1 = q0 * q1;
000000BC  00000000   NOP
0000015C  00000000   NOP
79:                  		q0q2 = q0 * q2;
000000C4  00000000   NOP
00000180  00000000   NOP
80:                  		q0q3 = q0 * q3;
000000D4  00000000   NOP
00000144  00000000   NOP
81:                  		q1q1 = q1 * q1;
000000DC  00000000   NOP
000000FC  00000000   NOP
82:                  		q1q2 = q1 * q2;
000000E4  00000000   NOP
00000148  00000000   NOP
83:                  		q1q3 = q1 * q3;
00000100  00000000   NOP
00000184  00000000   NOP
84:                  		q2q2 = q2 * q2;
00000108  00000000   NOP
00000114  00000000   NOP
0000014C  00000000   NOP
85:                  		q2q3 = q2 * q3;
00000118  00000000   NOP
00000160  00000000   NOP
86:                  		q3q3 = q3 * q3;
00000120  00000000   NOP
00000138  00000000   NOP
87:                  
88:                  		// Reference direction of Earth's magnetic field
89:                  		hx = 2.0f * (mx * (0.5f - q2q2 - q3q3) + my * (q1q2 - q0q3) + mz * (q1q3 + q0q2));
0000016C  00000000   NOP
0000017C  00000000   NOP
00000198  00000000   NOP
000001A8  00000000   NOP
000001B8  00000000   NOP
000001C4  00000000   NOP
000001D0  00000000   NOP
000001DC  00000000   NOP
90:                  		hy = 2.0f * (mx * (q1q2 + q0q3) + my * (0.5f - q1q1 - q3q3) + mz * (q2q3 - q0q1));
00000140  00000000   NOP
00000158  00000000   NOP
00000178  00000000   NOP
0000019C  00000000   NOP
000001A4  00000000   NOP
000001C0  00000000   NOP
000001CC  00000000   NOP
000001D8  00000000   NOP
91:                  		bx = sqrt(hx * hx + hy * hy);
000001E4  00000000   NOP
000001F0  00000000   NOP
00000240  00000000   NOP
92:                  		bz = 2.0f * (mx * (q1q3 - q0q2) + my * (q2q3 + q0q1) + mz * (0.5f - q1q1 - q2q2));
00000224  00000000   NOP
00000244  00000000   NOP
0000026C  00000000   NOP
00000284  00000000   NOP
0000028C  00000000   NOP
93:                  
94:                  		// Estimated direction of gravity and magnetic field
95:                  		halfvx = q1q3 - q0q2;
96:                  		halfvy = q0q1 + q2q3;
97:                  		halfvz = q0q0 - 0.5f + q3q3;
00000248  00000000   NOP
00000264  00000000   NOP
98:                  		halfwx = bx * (0.5f - q2q2 - q3q3) + bz * (q1q3 - q0q2);
00000290  00000000   NOP
0000029C  00000000   NOP
99:                  		halfwy = bx * (q1q2 - q0q3) + bz * (q0q1 + q2q3);
00000294  00000000   NOP
000002A0  00000000   NOP
100:                 		halfwz = bx * (q0q2 + q1q3) + bz * (0.5f - q1q1 - q2q2);
00000298  00000000   NOP
000002A4  00000000   NOP
101:                 
102:                 		// Error is sum of cross product between estimated direction and measured direction of field vectors
103:                 		halfex = (ay * halfvz - az * halfvy) + (my * halfwz - mz * halfwy);
00000250  00000000   NOP
0000027C  00000000   NOP
000002AC  00000000   NOP
000002B8  00000000   NOP
000002C4  00000000   NOP
104:                 		halfey = (az * halfvx - ax * halfvz) + (mz * halfwx - mx * halfwz);
00000274  00000000   NOP
00000288  00000000   NOP
000002B0  00000000   NOP
000002BC  00000000   NOP
000002C8  00000000   NOP
105:                 		halfez = (ax * halfvy - ay * halfvx) + (mx * halfwy - my * halfwx);
00000258  00000000   NOP
00000280  00000000   NOP
000002A8  00000000   NOP
000002B4  00000000   NOP
000002C0  00000000   NOP
106:                 
107:                 		// Compute and apply integral feedback if enabled
108:                 		if (twoKi > 0.0f) {
00000260  00000000   NOP
00000268  00000000   NOP
00000270  00000000   NOP
000002CC  00000000   NOP
109:                 			integralFBx += twoKi * halfex * (1.0f / sampleFreq); // integral error scaled by Ki
000002D4  00000000   NOP
110:                 			integralFBy += twoKi * halfey * (1.0f / sampleFreq);
000002F0  00000000   NOP
111:                 			integralFBz += twoKi * halfez * (1.0f / sampleFreq);
00000304  00000000   NOP
112:                 			gx += integralFBx; // apply integral feedback
00000318  00000000   NOP
00000324  00000000   NOP
113:                 			gy += integralFBy;
0000031C  00000000   NOP
00000328  00000000   NOP
114:                 			gz += integralFBz;
00000320  00000000   NOP
0000032C  00000000   NOP
115:                 		} else {
116:                 			integralFBx = 0.0f; // prevent integral windup
00000528  00000000   NOP
117:                 			integralFBy = 0.0f;
0000052C  00000000   NOP
118:                 			integralFBz = 0.0f;
00000530  00000000   NOP
119:                 		}
120:                 
121:                 		// Apply proportional feedback
122:                 		gx += twoKp * halfex;
00000330  00000000   NOP
0000033C  00000000   NOP
123:                 		gy += twoKp * halfey;
00000334  00000000   NOP
00000340  00000000   NOP
124:                 		gz += twoKp * halfez;
00000338  00000000   NOP
00000344  00000000   NOP
125:                 	}
126:                 
127:                 	// Integrate rate of change of quaternion
128:                 	gx *= (0.5f * (1.0f / sampleFreq)); // pre-multiply common factors
00000348  00000000   NOP
00000360  00000000   NOP
129:                 	gy *= (0.5f * (1.0f / sampleFreq));
00000358  00000000   NOP
130:                 	gz *= (0.5f * (1.0f / sampleFreq));
00000364  00000000   NOP
131:                 	qa = q0;
00000350  00000000   NOP
132:                 	qb = q1;
00000354  00000000   NOP
133:                 	qc = q2;
0000035C  00000000   NOP
134:                 	q0 += (-qb * gx - qc * gy - q3 * gz);
00000368  00000000   NOP
00000384  00000000   NOP
00000394  00000000   NOP
000003AC  00000000   NOP
000003B8  00000000   NOP
135:                 	q1 += (qa * gx + qc * gz - q3 * gy);
00000388  00000000   NOP
000003A4  00000000   NOP
000003C0  00000000   NOP
136:                 	q2 += (qa * gy - qb * gz + q3 * gx);
0000038C  00000000   NOP
000003A8  00000000   NOP
000003D8  00000000   NOP
137:                 	q3 += (qa * gz + qb * gy - qc * gx);
0000037C  00000000   NOP
00000390  00000000   NOP
000003A0  00000000   NOP
000003B4  00000000   NOP
000003EC  00000000   NOP
138:                 
139:                 	// Normalise quaternion
140:                 	recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
000003F8  00000000   NOP
00000420  00000000   NOP
141:                 	q0 *= recipNorm;
0000041C  00000000   NOP
00000458  00000000   NOP
142:                 	q1 *= recipNorm;
00000460  00000000   NOP
143:                 	q2 *= recipNorm;
0000046C  00000000   NOP
144:                 	q3 *= recipNorm;
00000478  00000000   NOP
145:                 }
00000484  00000000   NOP
000004E4  00000000   NOP
146:                 
147:                 //---------------------------------------------------------------------------------------------------
148:                 // IMU algorithm update
149:                 
150:                 void MahonyAHRSupdateIMU(float gx, float gy, float gz, float ax, float ay, float az)
151:                 {
00000000  00000000   NOP
0000000C  00000000   NOP
152:                 	float recipNorm;
153:                 	float halfvx, halfvy, halfvz;
154:                 	float halfex, halfey, halfez;
155:                 	float qa, qb, qc;
156:                 
157:                 	// Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)
158:                 	if (!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {
00000010  00000000   NOP
000002C0  00000000   NOP
159:                 
160:                 		// Normalise accelerometer measurement
161:                 		recipNorm = invSqrt(ax * ax + ay * ay + az * az);
00000024  00000000   NOP
00000038  00000000   NOP
00000058  00000000   NOP
162:                 		ax *= recipNorm;
000000C8  00000000   NOP
163:                 		ay *= recipNorm;
000000D0  00000000   NOP
164:                 		az *= recipNorm;
000000D4  00000000   NOP
165:                 
166:                 		// Estimated direction of gravity and vector perpendicular to magnetic flux
167:                 		halfvx = q1 * q3 - q0 * q2;
00000040  00000000   NOP
00000070  00000000   NOP
0000009C  00000000   NOP
168:                 		halfvy = q0 * q1 + q2 * q3;
00000050  00000000   NOP
00000060  00000000   NOP
00000074  00000000   NOP
000000A8  00000000   NOP
169:                 		halfvz = q0 * q0 - 0.5f + q3 * q3;
00000068  00000000   NOP
00000090  00000000   NOP
000000B0  00000000   NOP
170:                 
171:                 		// Error is sum of cross product between estimated and measured direction of gravity
172:                 		halfex = (ay * halfvz - az * halfvy);
000000E0  00000000   NOP
173:                 		halfey = (az * halfvx - ax * halfvz);
000000D8  00000000   NOP
000000E4  00000000   NOP
174:                 		halfez = (ax * halfvy - ay * halfvx);
000000DC  00000000   NOP
000000E8  00000000   NOP
175:                 
176:                 		// Compute and apply integral feedback if enabled
177:                 		if (twoKi > 0.0f) {
000000AC  00000000   NOP
000000B4  00000000   NOP
000000EC  00000000   NOP
178:                 			integralFBx += twoKi * halfex * (1.0f / sampleFreq); // integral error scaled by Ki
000000F4  00000000   NOP
179:                 			integralFBy += twoKi * halfey * (1.0f / sampleFreq);
00000110  00000000   NOP
180:                 			integralFBz += twoKi * halfez * (1.0f / sampleFreq);
00000124  00000000   NOP
181:                 			gx += integralFBx; // apply integral feedback
00000138  00000000   NOP
00000144  00000000   NOP
182:                 			gy += integralFBy;
0000013C  00000000   NOP
00000148  00000000   NOP
183:                 			gz += integralFBz;
00000140  00000000   NOP
0000014C  00000000   NOP
184:                 		} else {
185:                 			integralFBx = 0.0f; // prevent integral windup
000002D4  00000000   NOP
186:                 			integralFBy = 0.0f;
000002D8  00000000   NOP
187:                 			integralFBz = 0.0f;
000002DC  00000000   NOP
188:                 		}
189:                 
190:                 		// Apply proportional feedback
191:                 		gx += twoKp * halfex;
00000158  00000000   NOP
00000164  00000000   NOP
192:                 		gy += twoKp * halfey;
0000015C  00000000   NOP
00000168  00000000   NOP
193:                 		gz += twoKp * halfez;
00000160  00000000   NOP
0000016C  00000000   NOP
194:                 	}
195:                 
196:                 	// Integrate rate of change of quaternion
197:                 	gx *= (0.5f * (1.0f / sampleFreq)); // pre-multiply common factors
00000178  00000000   NOP
00000190  00000000   NOP
198:                 	gy *= (0.5f * (1.0f / sampleFreq));
00000188  00000000   NOP
199:                 	gz *= (0.5f * (1.0f / sampleFreq));
00000194  00000000   NOP
200:                 	qa = q0;
00000180  00000000   NOP
201:                 	qb = q1;
00000184  00000000   NOP
202:                 	qc = q2;
0000018C  00000000   NOP
203:                 	q0 += (-qb * gx - qc * gy - q3 * gz);
0000019C  00000000   NOP
000001B8  00000000   NOP
000001C8  00000000   NOP
000001E0  00000000   NOP
000001EC  00000000   NOP
204:                 	q1 += (qa * gx + qc * gz - q3 * gy);
000001BC  00000000   NOP
000001D8  00000000   NOP
000001F4  00000000   NOP
205:                 	q2 += (qa * gy - qb * gz + q3 * gx);
000001C0  00000000   NOP
000001DC  00000000   NOP
0000020C  00000000   NOP
206:                 	q3 += (qa * gz + qb * gy - qc * gx);
000001B0  00000000   NOP
000001C4  00000000   NOP
000001D4  00000000   NOP
000001E8  00000000   NOP
00000220  00000000   NOP
207:                 
208:                 	// Normalise quaternion
209:                 	recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
0000022C  00000000   NOP
00000254  00000000   NOP
210:                 	q0 *= recipNorm;
00000250  00000000   NOP
0000028C  00000000   NOP
211:                 	q1 *= recipNorm;
00000294  00000000   NOP
212:                 	q2 *= recipNorm;
000002A0  00000000   NOP
213:                 	q3 *= recipNorm;
000002AC  00000000   NOP
214:                 }
215:                 
216:                 //---------------------------------------------------------------------------------------------------
217:                 // Fast inverse square-root
218:                 // See: http://en.wikipedia.org/wiki/Fast_inverse_square_root
219:                 // change to standards version
220:                 
221:                 static float invSqrt(float x)
222:                 {
223:                 	const float x2 = x * 0.5F;
00000028  00000000   NOP
00000078  00000000   NOP
00000098  00000000   NOP
000000EC  00000000   NOP
00000194  00000000   NOP
000001D0  00000000   NOP
00000264  00000000   NOP
0000039C  00000000   NOP
00000430  00000000   NOP
224:                 	const float threehalfs = 1.5F;
225:                 
226:                 	union {
227:                 		float f;
228:                 		unsigned long i;
229:                 	} conv = {.f = x};
230:                 	conv.i = 0x5f3759df - (conv.i >> 1);
00000080  00000000   NOP
000000A0  00000000   NOP
000000F4  00000000   NOP
000001A0  00000000   NOP
00000268  00000000   NOP
00000434  00000000   NOP
231:                 	conv.f *= (threehalfs - (x2 * conv.f * conv.f));
00000030  00000000   NOP
00000084  00000000   NOP
000000A0  00000000   NOP
000000A8  00000000   NOP
000000BC  00000000   NOP
000000F8  00000000   NOP
0000010C  00000000   NOP
00000130  00000000   NOP
00000154  00000000   NOP
00000164  00000000   NOP
000001AC  00000000   NOP
000001C8  00000000   NOP
000001D4  00000000   NOP
000001E0  00000000   NOP
000001E4  00000000   NOP
0000026C  00000000   NOP
000003B0  00000000   NOP
00000438  00000000   NOP
232:                 	return conv.f;
233:                 }
234:                 
235:                 //====================================================================================================
236:                 // END OF CODE
237:                 //====================================================================================================
---  /root/vcan/imu/pic32mk/csp_apps_pic32mk/apps/clock/clock_config/firmware/pic32mk_mcj_curiosity_pro.X/MadgwickAHRS/MadgwickAHRS.c
1:                   //=====================================================================================================
2:                   // MadgwickAHRS.c
3:                   //=====================================================================================================
4:                   //
5:                   // Implementation of Madgwick's IMU and AHRS algorithms.
6:                   // See: http://www.x-io.co.uk/node/8#open_source_ahrs_and_imu_algorithms
7:                   //
8:                   // Date			Author          Notes
9:                   // 29/09/2011	SOH Madgwick    Initial release
10:                  // 02/10/2011	SOH Madgwick	Optimised for reduced CPU load
11:                  // 19/02/2012	SOH Madgwick	Magnetometer measurement is normalised
12:                  //
13:                  //=====================================================================================================
14:                  
15:                  //---------------------------------------------------------------------------------------------------
16:                  // Header files
17:                  
18:                  #include "MadgwickAHRS.h"
19:                  #include <math.h>
20:                  
21:                  //---------------------------------------------------------------------------------------------------
22:                  // Definitions
23:                  
24:                  #define sampleFreq	400.0f		// sample frequency in Hz
25:                  #define betaDef		0.025f		// 2 * proportional gain
26:                  
27:                  //---------------------------------------------------------------------------------------------------
28:                  // Variable definitions
29:                  
30:                  volatile float beta = betaDef; // 2 * proportional gain (Kp)
31:                  volatile float q0 = 1.0f, q1 = 0.0f, q2 = 0.0f, q3 = 0.0f; // quaternion of sensor frame relative to auxiliary frame
32:                  
33:                  //---------------------------------------------------------------------------------------------------
34:                  // Function declarations
35:                  
36:                  float invSqrt(float x);
37:                  
38:                  //====================================================================================================
39:                  // Functions
40:                  
41:                  //---------------------------------------------------------------------------------------------------
42:                  // AHRS algorithm update
43:                  
44:                  void MadgwickAHRSupdate(float gx, float gy, float gz, float ax, float ay, float az, float mx, float my, float mz)
45:                  {
9D071998  27BDFF10   ADDIU SP, SP, -240
9D07199C  AFBF0084   SW RA, 132(SP)
9D0719A0  AFB30080   SW S3, 128(SP)
9D0719A4  AFB2007C   SW S2, 124(SP)
9D0719A8  AFB10078   SW S1, 120(SP)
9D0719AC  AFB00074   SW S0, 116(SP)
9D0719B0  F7BF00E0   SDC1 F31, 224(SP)
9D0719B4  F7BE00D8   SDC1 F30, 216(SP)
9D0719B8  F7BD00D0   SDC1 F29, 208(SP)
9D0719BC  F7BC00C8   SDC1 F28, 200(SP)
9D0719C0  F7BB00C0   SDC1 F27, 192(SP)
9D0719C4  F7BA00B8   SDC1 F26, 184(SP)
9D0719C8  F7B900B0   SDC1 F25, 176(SP)
9D0719CC  F7B800A8   SDC1 F24, 168(SP)
9D0719D0  F7B700A0   SDC1 F23, 160(SP)
9D0719D4  F7B60098   SDC1 F22, 152(SP)
9D0719D8  F7B50090   SDC1 F21, 144(SP)
9D0719DC  F7B40088   SDC1 F20, 136(SP)
9D0719E0  C7B90108   LWC1 F25, 264(SP)
9D0719E8  46006046   MOV.S F1, F12
9D0719F0  460070C6   MOV.S F3, F14
9D0719F4  44861000   MTC1 A2, F2
9D0719F8  4487B000   MTC1 A3, F22
9D0719FC  C7B80100   LWC1 F24, 256(SP)
9D071A00  C7BB0104   LWC1 F27, 260(SP)
9D071A04  C7B5010C   LWC1 F21, 268(SP)
46:                  	float recipNorm;
47:                  	float s0, s1, s2, s3;
48:                  	float qDot1, qDot2, qDot3, qDot4;
49:                  	float hx, hy;
50:                  	float _2q0mx, _2q0my, _2q0mz, _2q1mx, _2bx, _2bz, _4bx, _4bz, _2q0, _2q1, _2q2, _2q3, _2q0q2, _2q2q3, q0q0, q0q1, q0q2, q0q3, q1q1, q1q2, q1q3, q2q2, q2q3, q3q3;
51:                  
52:                  	// Use IMU algorithm if magnetometer measurement invalid (avoids NaN in magnetometer normalisation)
53:                  	if ((mx == 0.0f) && (my == 0.0f) && (mz == 0.0f)) {
9D0719E4  44800000   MTC1 ZERO, F0
9D0719EC  4600C832   C.EQ.S F25, F0
9D071A08  45000004   BC1F 0x9D071A1C
9D071A0C  C7B40110   LWC1 F20, 272(SP)
9D071A10  4600A932   C.EQ.S 1, F21, F0
9D071A14  450501B9   BC1T 1, .LVL122
9D071A18  4600A232   C.EQ.S 2, F20, F0
9D0720FC  4508FE47   BC1F 2, 0x9D071A1C
9D072100  8FBF0084   LW RA, 132(SP)
54:                  		MadgwickAHRSupdateIMU(gx, gy, gz, ax, ay, az);
9D072144  0B41CDCE   J MadgwickAHRSupdateIMU
9D072148  27BD00F0   ADDIU SP, SP, 240
55:                  		return;
56:                  	}
57:                  
58:                  	// Rate of change of quaternion from gyroscope
59:                  	qDot1 = 0.5f * (-q1 * gx - q2 * gy - q3 * gz);
9D071A1C  8F848068   LW A0, -32664(GP)
9D071A20  C79C8064   LWC1 F28, -32668(GP)
9D071A24  C7888060   LWC1 F8, -32672(GP)
9D071A4C  4603E702   MUL.S F28, F28, F3
9D071A60  3C038000   LUI V1, -32768
9D071A64  00831026   XOR V0, A0, V1
9D071A68  44826800   MTC1 V0, F13
9D071A6C  4F816B28   MSUB.S F12, F28, F13, F1
9D071A70  46024202   MUL.S F8, F8, F2
9D071A8C  46086701   SUB.S F28, F12, F8
9D071A90  3C139D08   LUI S3, -25336
9D071A98  C66490B0   LWC1 F4, -28496(S3)
9D071AA4  4604E702   MUL.S F28, F28, F4
60:                  	qDot2 = 0.5f * (q0 * gx + q2 * gz - q3 * gy);
9D071A28  C78B8024   LWC1 F11, -32732(GP)
9D071A2C  C7878064   LWC1 F7, -32668(GP)
9D071A30  C78A8060   LWC1 F10, -32672(GP)
9D071A50  460239C2   MUL.S F7, F7, F2
9D071A74  4CE159E0   MADD.S F7, F7, F11, F1
9D071A78  460350C2   MUL.S F3, F10, F3
9D071A94  460338C1   SUB.S F3, F7, F3
9D071AA8  460418C2   MUL.S F3, F3, F4
61:                  	qDot3 = 0.5f * (q0 * gy - q1 * gz + q3 * gx);
9D071A34  C78C8024   LWC1 F12, -32732(GP)
9D071A38  C7858068   LWC1 F5, -32664(GP)
9D071A3C  C7898060   LWC1 F9, -32672(GP)
9D071A44  46022942   MUL.S F5, F5, F2
9D071A5C  4CA36168   MSUB.S F5, F5, F12, F3
9D071A84  4CA14860   MADD.S F1, F5, F9, F1
9D071AAC  46040842   MUL.S F1, F1, F4
62:                  	qDot4 = 0.5f * (q0 * gz + q1 * gy - q2 * gx);
9D071A40  C7808024   LWC1 F0, -32732(GP)
9D071A48  C7848068   LWC1 F4, -32664(GP)
9D071A54  46032102   MUL.S F4, F4, F3
9D071A58  C7868064   LWC1 F6, -32668(GP)
9D071A7C  4C8200A0   MADD.S F2, F4, F0, F2
9D071A80  46013182   MUL.S F6, F6, F1
9D071A9C  46061081   SUB.S F2, F2, F6
63:                  
64:                  	// Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)
65:                  	if (!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {
9D071A88  44802800   MTC1 ZERO, F5
9D071AA0  4605B332   C.EQ.S 3, F22, F5
9D071AB0  450C0004   BC1F 3, .LVL52
9D071AB4  46041102   MUL.S F4, F2, F4
9D071AB8  4605C432   C.EQ.S 4, F24, F5
9D071ABC  4511018B   BC1T 4, .LVL121
9D071AC0  4605DD32   C.EQ.S 5, F27, F5
9D0720EC  4515FFC5   BC1T 5, .LVL114
9D0720F0  00000000   NOP
66:                  
67:                  		// Normalise accelerometer measurement
68:                  		recipNorm = invSqrt(ax * ax + ay * ay + az * az);
9D071AC4  4618C302   MUL.S F12, F24, F24
9D071AC8  4D96B320   MADD.S F12, F12, F22, F22
9D071ACC  4D9BDB20   MADD.S F12, F12, F27, F27
9D071AD0  F7A10060   SDC1 F1, 96(SP)
9D071AD4  F7A30058   SDC1 F3, 88(SP)
9D071AD8  0F41E160   JAL .LFB71, .LVL0, .LFE5, invSqrt
9D071ADC  F7A40068   SDC1 F4, 104(SP)
9D0720F4  0B41C6B2   J 0x9D071AC8
9D0720F8  4618C302   MUL.S F12, F24, F24
69:                  		ax *= recipNorm;
9D071AE4  4600B582   MUL.S F22, F22, F0
9D071AE8  E7B6001C   SWC1 F22, 28(SP)
70:                  		ay *= recipNorm;
9D071AEC  4600C602   MUL.S F24, F24, F0
9D071AF0  E7B80020   SWC1 F24, 32(SP)
71:                  		az *= recipNorm;
9D071AF4  4600DEC2   MUL.S F27, F27, F0
9D071AF8  E7BB0024   SWC1 F27, 36(SP)
72:                  
73:                  		// Normalise magnetometer measurement
74:                  		recipNorm = invSqrt(mx * mx + my * my + mz * mz);
9D071AE0  4615AB02   MUL.S F12, F21, F21
9D071AFC  4D99CB20   MADD.S F12, F12, F25, F25
9D071B00  0F41E160   JAL .LFB71, .LVL0, .LFE5, invSqrt
9D071B04  4D94A320   MADD.S F12, F12, F20, F20
75:                  		mx *= recipNorm;
9D071B48  4600CD82   MUL.S F22, F25, F0
76:                  		my *= recipNorm;
9D071B0C  4600AD42   MUL.S F21, F21, F0
77:                  		mz *= recipNorm;
9D071B44  4600A502   MUL.S F20, F20, F0
78:                  
79:                  		// Auxiliary variables to avoid repeated arithmetic
80:                  		_2q0mx = 2.0f * q0 * mx;
9D071B08  C78A8024   LWC1 F10, -32732(GP)
9D071B54  460A5000   ADD.S F0, F10, F10
9D071B64  46160002   MUL.S F0, F0, F22
9D071B68  44120000   MFC1 S2, F0
81:                  		_2q0my = 2.0f * q0 * my;
9D071B10  C79E8024   LWC1 F30, -32732(GP)
9D071B50  461EF780   ADD.S F30, F30, F30
9D071B60  4615F782   MUL.S F30, F30, F21
82:                  		_2q0mz = 2.0f * q0 * mz;
9D071B14  C7898024   LWC1 F9, -32732(GP)
9D071B58  46094A40   ADD.S F9, F9, F9
9D071B6C  46144A42   MUL.S F9, F9, F20
83:                  		_2q1mx = 2.0f * q1 * mx;
9D071B18  C7888068   LWC1 F8, -32664(GP)
9D071BDC  46084200   ADD.S F8, F8, F8
9D071BF4  46164202   MUL.S F8, F8, F22
9D071BF8  E7A80010   SWC1 F8, 16(SP)
84:                  		_2q0 = 2.0f * q0;
9D071B1C  C7858024   LWC1 F5, -32732(GP)
9D071C88  46052940   ADD.S F5, F5, F5
9D071C8C  44112800   MFC1 S1, F5
85:                  		_2q1 = 2.0f * q1;
9D071B20  C78C8068   LWC1 F12, -32664(GP)
9D071C04  460C6640   ADD.S F25, F12, F12
86:                  		_2q2 = 2.0f * q2;
9D071B24  C7868064   LWC1 F6, -32668(GP)
9D071C18  46063180   ADD.S F6, F6, F6
9D071C1C  44103000   MFC1 S0, F6
87:                  		_2q3 = 2.0f * q3;
9D071B28  C7878060   LWC1 F7, -32672(GP)
9D071C90  46073C00   ADD.S F16, F7, F7
88:                  		_2q0q2 = 2.0f * q0 * q2;
9D071B2C  C78E8024   LWC1 F14, -32732(GP)
9D071B30  8F828064   LW V0, -32668(GP)
9D071C70  460E7380   ADD.S F14, F14, F14
9D071CBC  44821000   MTC1 V0, F2
9D071CC0  46027382   MUL.S F14, F14, F2
89:                  		_2q2q3 = 2.0f * q2 * q3;
9D071B34  C78B8064   LWC1 F11, -32668(GP)
9D071B38  8F898060   LW T1, -32672(GP)
9D071C7C  460B5AC0   ADD.S F11, F11, F11
9D071CC4  44892800   MTC1 T1, F5
9D071CC8  46055AC2   MUL.S F11, F11, F5
90:                  		q0q0 = q0 * q0;
9D071B3C  C79D8024   LWC1 F29, -32732(GP)
9D071B40  C7828024   LWC1 F2, -32732(GP)
9D071B4C  4602EF42   MUL.S F29, F29, F2
91:                  		q0q1 = q0 * q1;
9D071B5C  8F8B8024   LW T3, -32732(GP)
9D071B74  C79F8068   LWC1 F31, -32664(GP)
9D071CA0  448B3000   MTC1 T3, F6
9D071CA4  461F37C2   MUL.S F31, F6, F31
92:                  		q0q2 = q0 * q2;
9D071B78  8F838024   LW V1, -32732(GP)
9D071B7C  C7828064   LWC1 F2, -32668(GP)
9D071CB0  44839000   MTC1 V1, F18
9D071CB4  46029482   MUL.S F18, F18, F2
9D071CB8  E7B20018   SWC1 F18, 24(SP)
93:                  		q0q3 = q0 * q3;
9D071B80  8F888024   LW T0, -32732(GP)
9D071B84  C7918060   LWC1 F17, -32672(GP)
9D071CCC  44883000   MTC1 T0, F6
9D071CD0  46113182   MUL.S F6, F6, F17
9D071CD4  44083000   MFC1 T0, F6
94:                  		q1q1 = q1 * q1;
9D071B88  C7998068   LWC1 F25, -32664(GP)
9D071B8C  C7988068   LWC1 F24, -32664(GP)
9D071BF0  4618CE02   MUL.S F24, F25, F24
95:                  		q1q2 = q1 * q2;
9D071B90  C7908068   LWC1 F16, -32664(GP)
9D071B94  E7B0002C   SWC1 F16, 44(SP)
9D071B98  C7928064   LWC1 F18, -32668(GP)
9D071B9C  E7B20030   SWC1 F18, 48(SP)
9D071CDC  C7A7002C   LWC1 F7, 44(SP)
9D071CE0  C7A80030   LWC1 F8, 48(SP)
9D071CE4  460839C2   MUL.S F7, F7, F8
9D071CE8  E7A7002C   SWC1 F7, 44(SP)
96:                  		q1q3 = q1 * q3;
9D071BA0  8F868068   LW A2, -32664(GP)
9D071BA4  C79A8060   LWC1 F26, -32672(GP)
9D071C80  44868000   MTC1 A2, F16
9D071C84  461A8682   MUL.S F26, F16, F26
97:                  		q2q2 = q2 * q2;
9D071BA8  C7978064   LWC1 F23, -32668(GP)
9D071BAC  8F8D8064   LW T5, -32668(GP)
9D071C08  448D4000   MTC1 T5, F8
9D071C0C  4608BDC2   MUL.S F23, F23, F8
98:                  		q2q3 = q2 * q3;
9D071BB0  C78D8064   LWC1 F13, -32668(GP)
9D071BB4  C7938060   LWC1 F19, -32672(GP)
9D071CF0  46136CC2   MUL.S F19, F13, F19
9D071CF4  E7B30030   SWC1 F19, 48(SP)
99:                  		q3q3 = q3 * q3;
9D071BB8  8F848060   LW A0, -32672(GP)
9D071BBC  C79B8060   LWC1 F27, -32672(GP)
9D071C34  44843000   MTC1 A0, F6
9D071C38  461B36C2   MUL.S F27, F6, F27
100:                 
101:                 		// Reference direction of Earth's magnetic field
102:                 		hx = mx * q0q0 - _2q0my * q3 + _2q0mz * q2 + mx * q1q1 + _2q1 * my * q2 + _2q1 * mz * q3 - mx * q2q2 - mx * q3q3;
9D071BC0  C7808060   LWC1 F0, -32672(GP)
9D071BC4  8F878064   LW A3, -32668(GP)
9D071BC8  8F8E8064   LW T6, -32668(GP)
9D071BCC  4600F3C2   MUL.S F15, F30, F0
9D071BD0  8F8A8060   LW T2, -32672(GP)
9D071BFC  4DFDB3E8   MSUB.S F15, F15, F22, F29
9D071C20  44876000   MTC1 A3, F12
9D071C24  4DEC4A60   MADD.S F9, F15, F9, F12
9D071C30  4615CC82   MUL.S F18, F25, F21
9D071C44  4614CB02   MUL.S F12, F25, F20
9D071C4C  4D38B260   MADD.S F9, F9, F22, F24
9D071C58  4617B3C2   MUL.S F15, F22, F23
9D071C60  461BB002   MUL.S F0, F22, F27
9D071C74  448E3000   MTC1 T6, F6
9D071C78  4D269260   MADD.S F9, F9, F18, F6
9D071CA8  448A3800   MTC1 T2, F7
9D071CAC  4D276320   MADD.S F12, F9, F12, F7
9D071CEC  460F6301   SUB.S F12, F12, F15
9D071CFC  46006301   SUB.S F12, F12, F0
103:                 		hy = _2q0mx * q3 + my * q0q0 - _2q0mz * q1 + _2q1mx * q2 - my * q1q1 + my * q2q2 + _2q2 * mz * q3 - my * q3q3;
9D071B70  461DAA82   MUL.S F10, F21, F29
9D071BD4  8F8C8060   LW T4, -32672(GP)
9D071BD8  C7808068   LWC1 F0, -32664(GP)
9D071BE0  44928000   MTC1 S2, F16
9D071BE4  448C9000   MTC1 T4, F18
9D071BE8  4D528420   MADD.S F16, F10, F16, F18
9D071BEC  46004802   MUL.S F0, F9, F0
9D071C00  C78A8064   LWC1 F10, -32668(GP)
9D071C10  46008201   SUB.S F8, F16, F0
9D071C14  4618A802   MUL.S F0, F21, F24
9D071C28  C7B00010   LWC1 F16, 16(SP)
9D071C2C  4D0A8220   MADD.S F8, F8, F16, F10
9D071C3C  44906000   MTC1 S0, F12
9D071C40  46146282   MUL.S F10, F12, F20
9D071C48  8F8D8060   LW T5, -32672(GP)
9D071C50  46004001   SUB.S F0, F8, F0
9D071C54  440C0000   MFC1 T4, F0
9D071C5C  461BAA02   MUL.S F8, F21, F27
9D071C64  448C8000   MTC1 T4, F16
9D071C68  4E17AC20   MADD.S F16, F16, F21, F23
9D071C6C  440C8000   MFC1 T4, F16
9D071C94  448D9000   MTC1 T5, F18
9D071C98  448C2800   MTC1 T4, F5
9D071C9C  4CB252A0   MADD.S F10, F5, F10, F18
9D071CD8  46085281   SUB.S F10, F10, F8
104:                 		_2bx = sqrt(hx * hx + hy * hy);
9D071CF8  460A5282   MUL.S F10, F10, F10
9D071D00  4D4C6320   MADD.S F12, F10, F12, F12
9D071DF4  46200020   CVT.S.D F0, F0
9D071DF8  44060000   MFC1 A2, F0
105:                 		_2bz = -_2q0mx * q2 + _2q0my * q1 + mz * q0q0 + _2q1mx * q3 - mz * q1q1 + _2q2 * my * q3 - mz * q2q2 + mz * q3q3;
9D071D1C  C7858064   LWC1 F5, -32668(GP)
9D071D20  C78C8068   LWC1 F12, -32664(GP)
9D071D24  3C028000   LUI V0, -32768
9D071D28  02421826   XOR V1, S2, V0
9D071D2C  460CF782   MUL.S F30, F30, F12
9D071D30  C78A8060   LWC1 F10, -32672(GP)
9D071D34  4618A342   MUL.S F13, F20, F24
9D071D38  44909000   MTC1 S0, F18
9D071D3C  46159302   MUL.S F12, F18, F21
9D071D40  C7938060   LWC1 F19, -32672(GP)
9D071D44  4617A442   MUL.S F17, F20, F23
9D071D4C  44833800   MTC1 V1, F7
9D071D50  4FC538A0   MADD.S F2, F30, F7, F5
9D071D68  4C5DA760   MADD.S F29, F2, F20, F29
9D071D90  C7A20010   LWC1 F2, 16(SP)
9D071D94  4FAA1220   MADD.S F8, F29, F2, F10
9D071DBC  460D4201   SUB.S F8, F8, F13
9D071DD0  4D136320   MADD.S F12, F8, F12, F19
9D071DFC  46116301   SUB.S F12, F12, F17
9D071E10  4D9BA320   MADD.S F12, F12, F20, F27
106:                 		_4bx = 2.0f * _2bx;
9D071EAC  44869000   MTC1 A2, F18
9D071EB0  44861000   MTC1 A2, F2
9D071EB4  46129480   ADD.S F18, F18, F18
9D071EB8  44059000   MFC1 A1, F18
107:                 		_4bz = 2.0f * _2bz;
9D071E50  460C6200   ADD.S F8, F12, F12
108:                 
109:                 		// Gradient decent algorithm corrective step
110:                 		s0 = -_2q2 * (2.0f * q1q3 - _2q0q2 - ax) + _2q1 * (2.0f * q0q1 + _2q2q3 - ay) - _2bz * q2 * (_2bx * (0.5f - q2q2 - q3q3) + _2bz * (q1q3 - q0q2) - mx) + (-_2bx * q3 + _2bz * q1) * (_2bx * (q1q2 - q0q3) + _2bz * (q0q1 + q2q3) - my) + _2bx * q2 * (_2bx * (q0q2 + q1q3) + _2bz * (0.5f - q1q1 - q2q2) - mz);
9D071D48  461FF980   ADD.S F6, F31, F31
9D071D58  D7AB0048   LDC1 F11, 72(SP)
9D071D5C  460B32C0   ADD.S F11, F6, F11
9D071D60  461AD140   ADD.S F5, F26, F26
9D071D78  C7A80020   LWC1 F8, 32(SP)
9D071D7C  46085981   SUB.S F6, F11, F8
9D071D80  C66B90B0   LWC1 F11, -28496(S3)
9D071D84  C7A20018   LWC1 F2, 24(SP)
9D071D88  4602D481   SUB.S F18, F26, F2
9D071D8C  C7878064   LWC1 F7, -32668(GP)
9D071D98  8F878060   LW A3, -32672(GP)
9D071DA4  C79E8068   LWC1 F30, -32664(GP)
9D071DA8  C7828064   LWC1 F2, -32668(GP)
9D071DAC  E7A20010   SWC1 F2, 16(SP)
9D071DB4  D7AE0040   LDC1 F14, 64(SP)
9D071DB8  460E2B81   SUB.S F14, F5, F14
9D071DC0  46175B41   SUB.S F13, F11, F23
9D071DD8  C7A8001C   LWC1 F8, 28(SP)
9D071DDC  46087141   SUB.S F5, F14, F8
9D071DE8  461B6B41   SUB.S F13, F13, F27
9D071DEC  C7A80030   LWC1 F8, 48(SP)
9D071DF0  4608FFC0   ADD.S F31, F31, F8
9D071E00  46185E01   SUB.S F24, F11, F24
9D071E20  4617C5C1   SUB.S F23, F24, F23
9D071E24  8FA80050   LW T0, 80(SP)
9D071E28  C7AE002C   LWC1 F14, 44(SP)
9D071E2C  4488C000   MTC1 T0, F24
9D071E30  46187441   SUB.S F17, F14, F24
9D071E38  460C9382   MUL.S F14, F18, F12
9D071E3C  460CFFC2   MUL.S F31, F31, F12
9D071E54  4486C000   MTC1 A2, F24
9D071E58  4DD86B60   MADD.S F13, F14, F13, F24
9D071E5C  4FF88FE0   MADD.S F31, F31, F17, F24
9D071E60  460CBDC2   MUL.S F23, F23, F12
9D071E64  46193382   MUL.S F14, F6, F25
9D071E68  46076442   MUL.S F17, F12, F7
9D071E74  46166D81   SUB.S F22, F13, F22
9D071E84  C7AD0018   LWC1 F13, 24(SP)
9D071E88  461A6E80   ADD.S F26, F13, F26
9D071E8C  461E6782   MUL.S F30, F12, F30
9D071EA8  02022026   XOR A0, S0, V0
9D071EC0  4615FD41   SUB.S F21, F31, F21
9D071EC4  4EE2D6A0   MADD.S F26, F23, F26, F2
9D071EC8  44848000   MTC1 A0, F16
9D071ECC  4DC58360   MADD.S F13, F14, F16, F5
9D071ED0  46168882   MUL.S F2, F17, F22
9D071EF8  00C21826   XOR V1, A2, V0
9D071F00  44835000   MTC1 V1, F10
9D071F04  44878000   MTC1 A3, F16
9D071F08  4FD055E0   MADD.S F23, F30, F10, F16
9D071F34  4614D501   SUB.S F20, F26, F20
9D071F38  46026881   SUB.S F2, F13, F2
9D071F4C  4C55B8A0   MADD.S F2, F2, F23, F21
9D071F50  44868000   MTC1 A2, F16
9D071F54  C7B80010   LWC1 F24, 16(SP)
9D071F58  46188782   MUL.S F30, F16, F24
9D071F78  4C54F7A0   MADD.S F30, F2, F30, F20
111:                 		s1 = _2q3 * (2.0f * q1q3 - _2q0q2 - ax) + _2q0 * (2.0f * q0q1 + _2q2q3 - ay) - 4.0f * q1 * (1 - 2.0f * q1q1 - 2.0f * q2q2 - az) + _2bz * q3 * (_2bx * (0.5f - q2q2 - q3q3) + _2bz * (q1q3 - q0q2) - mx) + (_2bx * q2 + _2bz * q0) * (_2bx * (q1q2 - q0q3) + _2bz * (q0q1 + q2q3) - my) + (_2bx * q3 - _4bz * q1) * (_2bx * (q0q2 + q1q3) + _2bz * (0.5f - q1q1 - q2q2) - mz);
9D071D54  4618C240   ADD.S F9, F24, F24
9D071D64  4617BBC0   ADD.S F15, F23, F23
9D071D6C  3C049D08   LUI A0, -25336
9D071D70  C48690C4   LWC1 F6, -28476(A0)
9D071D74  46093241   SUB.S F9, F6, F9
9D071D9C  3C039D08   LUI V1, -25336
9D071DA0  C46A90B8   LWC1 F10, -28488(V1)
9D071DB0  C7828068   LWC1 F2, -32664(GP)
9D071DC4  460F4A41   SUB.S F9, F9, F15
9D071DC8  44912800   MTC1 S1, F5
9D071DCC  46062BC2   MUL.S F15, F5, F6
9D071DD4  460A1082   MUL.S F2, F2, F10
9D071DE0  C7AE0024   LWC1 F14, 36(SP)
9D071DE4  460E4A41   SUB.S F9, F9, F14
9D071E04  D7B00038   LDC1 F16, 56(SP)
9D071E08  4DE582E0   MADD.S F11, F15, F16, F5
9D071E0C  46091002   MUL.S F0, F2, F9
9D071E14  C7828060   LWC1 F2, -32672(GP)
9D071E18  C7938064   LWC1 F19, -32668(GP)
9D071E1C  C78F8024   LWC1 F15, -32732(GP)
9D071E34  C79D8060   LWC1 F29, -32672(GP)
9D071E40  C7928068   LWC1 F18, -32664(GP)
9D071E44  46026082   MUL.S F2, F12, F2
9D071E4C  460F63C2   MUL.S F15, F12, F15
9D071E6C  46005E01   SUB.S F24, F11, F0
9D071E90  4F02B620   MADD.S F24, F24, F22, F2
9D071E94  44868000   MTC1 A2, F16
9D071E98  4DF38420   MADD.S F16, F15, F16, F19
9D071E9C  44098000   MFC1 T1, F16
9D071EA0  461246C2   MUL.S F27, F8, F18
9D071F0C  44895000   MTC1 T1, F10
9D071F10  4F0AAE20   MADD.S F24, F24, F21, F10
9D071F14  44868000   MTC1 A2, F16
9D071F18  4F7D8768   MSUB.S F29, F27, F16, F29
9D071F48  4F1DA760   MADD.S F29, F24, F20, F29
112:                 		s2 = -_2q0 * (2.0f * q1q3 - _2q0q2 - ax) + _2q3 * (2.0f * q0q1 + _2q2q3 - ay) - 4.0f * q2 * (1 - 2.0f * q1q1 - 2.0f * q2q2 - az) + (-_4bx * q2 - _2bz * q0) * (_2bx * (0.5f - q2q2 - q3q3) + _2bz * (q1q3 - q0q2) - mx) + (_2bx * q1 + _2bz * q3) * (_2bx * (q1q2 - q0q3) + _2bz * (q0q1 + q2q3) - my) + (_2bx * q0 - _4bz * q2) * (_2bx * (q0q2 + q1q3) + _2bz * (0.5f - q1q1 - q2q2) - mz);
9D071E48  C79B8064   LWC1 F27, -32668(GP)
9D071E70  460681C2   MUL.S F7, F16, F6
9D071E78  460ADA82   MUL.S F10, F27, F10
9D071E7C  C78B8064   LWC1 F11, -32668(GP)
9D071E80  C7808024   LWC1 F0, -32732(GP)
9D071EA4  46006002   MUL.S F0, F12, F0
9D071EBC  02221826   XOR V1, S1, V0
9D071ED4  44839000   MTC1 V1, F18
9D071ED8  4CF229E0   MADD.S F7, F7, F5, F18
9D071EDC  460A4A42   MUL.S F9, F9, F10
9D071EE0  C79F8068   LWC1 F31, -32664(GP)
9D071EE4  C7938060   LWC1 F19, -32672(GP)
9D071EE8  C78E8024   LWC1 F14, -32732(GP)
9D071EEC  C7928064   LWC1 F18, -32668(GP)
9D071EFC  00A22026   XOR A0, A1, V0
9D071F1C  44848000   MTC1 A0, F16
9D071F20  4C0B82A8   MSUB.S F10, F0, F16, F11
9D071F24  461364C2   MUL.S F19, F12, F19
9D071F3C  46093A41   SUB.S F9, F7, F9
9D071F5C  4D2AB2A0   MADD.S F10, F9, F22, F10
9D071F60  4E7F8260   MADD.S F9, F19, F16, F31
9D071F64  46124202   MUL.S F8, F8, F18
9D071F80  4D49AA60   MADD.S F9, F10, F21, F9
9D071F84  4D0E86E8   MSUB.S F27, F8, F16, F14
9D071FA0  4D3BA6E0   MADD.S F27, F9, F20, F27
113:                 		s3 = _2q1 * (2.0f * q1q3 - _2q0q2 - ax) + _2q2 * (2.0f * q0q1 + _2q2q3 - ay) + (-_4bx * q3 + _2bz * q1) * (_2bx * (0.5f - q2q2 - q3q3) + _2bz * (q1q3 - q0q2) - mx) + (-_2bx * q0 + _2bz * q2) * (_2bx * (q1q2 - q0q3) + _2bz * (q0q1 + q2q3) - my) + _2bx * q1 * (_2bx * (q0q2 + q1q3) + _2bz * (0.5f - q1q1 - q2q2) - mz);
9D071EF0  C7918060   LWC1 F17, -32672(GP)
9D071EF4  C78F8068   LWC1 F15, -32664(GP)
9D071F28  44905800   MTC1 S0, F11
9D071F2C  46065802   MUL.S F0, F11, F6
9D071F30  460F63C2   MUL.S F15, F12, F15
9D071F40  C78D8024   LWC1 F13, -32732(GP)
9D071F44  C78B8064   LWC1 F11, -32668(GP)
9D071F68  4C05CE60   MADD.S F25, F0, F25, F5
9D071F6C  44842800   MTC1 A0, F5
9D071F70  4DF12820   MADD.S F0, F15, F5, F17
9D071F74  460B62C2   MUL.S F11, F12, F11
9D071F88  C7828068   LWC1 F2, -32664(GP)
9D071F8C  4F20B5A0   MADD.S F22, F25, F22, F0
9D071F90  44833000   MTC1 V1, F6
9D071F94  4D6D3160   MADD.S F5, F11, F6, F13
9D071F98  46028002   MUL.S F0, F16, F2
9D071FA4  4EC5AD60   MADD.S F21, F22, F21, F5
9D071FAC  4EA0A520   MADD.S F20, F21, F20, F0
114:                 		recipNorm = invSqrt(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3); // normalise step magnitude
9D071F7C  461DEB02   MUL.S F12, F29, F29
9D071F9C  4D9EF320   MADD.S F12, F12, F30, F30
9D071FA8  4D9BDB20   MADD.S F12, F12, F27, F27
9D071FB0  0F41E160   JAL .LFB71, .LVL0, .LFE5, invSqrt
9D071FB4  4D94A320   MADD.S F12, F12, F20, F20
115:                 		s0 *= recipNorm;
9D071FBC  4600F782   MUL.S F30, F30, F0
116:                 		s1 *= recipNorm;
9D071FC0  4600EF42   MUL.S F29, F29, F0
117:                 		s2 *= recipNorm;
9D071FC4  4600DEC2   MUL.S F27, F27, F0
118:                 		s3 *= recipNorm;
9D071FC8  4600A502   MUL.S F20, F20, F0
119:                 
120:                 		// Apply feedback step
121:                 		qDot1 -= beta * s0;
9D071FB8  C7868028   LWC1 F6, -32728(GP)
9D071FD8  461E3782   MUL.S F30, F6, F30
9D071FE8  461EE701   SUB.S F28, F28, F30
122:                 		qDot2 -= beta * s1;
9D071FCC  C7858028   LWC1 F5, -32728(GP)
9D071FDC  461D2F42   MUL.S F29, F5, F29
9D071FEC  D7A30058   LDC1 F3, 88(SP)
9D071FF0  461D18C1   SUB.S F3, F3, F29
123:                 		qDot3 -= beta * s2;
9D071FD0  C7828028   LWC1 F2, -32728(GP)
9D071FE0  461B16C2   MUL.S F27, F2, F27
9D071FF4  D7A10060   LDC1 F1, 96(SP)
9D071FF8  461B0841   SUB.S F1, F1, F27
124:                 		qDot4 -= beta * s3;
9D071FD4  C7808028   LWC1 F0, -32728(GP)
9D071FE4  46140502   MUL.S F20, F0, F20
9D071FFC  D7A40068   LDC1 F4, 104(SP)
9D072000  46142101   SUB.S F4, F4, F20
125:                 	}
126:                 
127:                 	// Integrate rate of change of quaternion to yield quaternion
128:                 	q0 += qDot1 * (1.0f / sampleFreq);
9D072004  C7828024   LWC1 F2, -32732(GP)
9D072008  3C029D08   LUI V0, -25336
9D07200C  C44090C0   LWC1 F0, -28480(V0)
9D072010  4C40E720   MADD.S F28, F2, F28, F0
9D072014  E79C8024   SWC1 F28, -32732(GP)
129:                 	q1 += qDot2 * (1.0f / sampleFreq);
9D072018  C7828068   LWC1 F2, -32664(GP)
9D07201C  4C4018E0   MADD.S F3, F2, F3, F0
9D072020  E7838068   SWC1 F3, -32664(GP)
130:                 	q2 += qDot3 * (1.0f / sampleFreq);
9D072024  C7828064   LWC1 F2, -32668(GP)
9D072028  4C400860   MADD.S F1, F2, F1, F0
9D07202C  E7818064   SWC1 F1, -32668(GP)
131:                 	q3 += qDot4 * (1.0f / sampleFreq);
9D072030  C7828060   LWC1 F2, -32672(GP)
9D072034  4C402120   MADD.S F4, F2, F4, F0
9D072038  E7848060   SWC1 F4, -32672(GP)
132:                 
133:                 	// Normalise quaternion
134:                 	recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
9D07203C  C7828024   LWC1 F2, -32732(GP)
9D072040  C7858024   LWC1 F5, -32732(GP)
9D072044  C7848068   LWC1 F4, -32664(GP)
9D072048  C7818068   LWC1 F1, -32664(GP)
9D07204C  C7808064   LWC1 F0, -32668(GP)
9D072050  C7838064   LWC1 F3, -32668(GP)
9D072054  46012102   MUL.S F4, F4, F1
9D072058  C78C8060   LWC1 F12, -32672(GP)
9D07205C  C7818060   LWC1 F1, -32672(GP)
9D072060  4C8510A0   MADD.S F2, F4, F2, F5
9D072064  4C430020   MADD.S F0, F2, F0, F3
9D072068  0F41E160   JAL .LFB71, .LVL0, .LFE5, invSqrt
9D07206C  4C016320   MADD.S F12, F0, F12, F1
135:                 	q0 *= recipNorm;
9D072070  C7818024   LWC1 F1, -32732(GP)
9D072074  46000842   MUL.S F1, F1, F0
9D072078  E7818024   SWC1 F1, -32732(GP)
136:                 	q1 *= recipNorm;
9D07207C  C7818068   LWC1 F1, -32664(GP)
9D072080  46000842   MUL.S F1, F1, F0
9D072084  E7818068   SWC1 F1, -32664(GP)
137:                 	q2 *= recipNorm;
9D072088  C7818064   LWC1 F1, -32668(GP)
9D07208C  46000842   MUL.S F1, F1, F0
9D072090  E7818064   SWC1 F1, -32668(GP)
138:                 	q3 *= recipNorm;
9D072094  C7818060   LWC1 F1, -32672(GP)
9D072098  46000802   MUL.S F0, F1, F0
9D07209C  E7808060   SWC1 F0, -32672(GP)
139:                 }
9D0720A0  8FBF0084   LW RA, 132(SP)
9D0720A4  8FB30080   LW S3, 128(SP)
9D0720A8  8FB2007C   LW S2, 124(SP)
9D0720AC  8FB10078   LW S1, 120(SP)
9D0720B0  8FB00074   LW S0, 116(SP)
9D0720B4  D7BF00E0   LDC1 F31, 224(SP)
9D0720B8  D7BE00D8   LDC1 F30, 216(SP)
9D0720BC  D7BD00D0   LDC1 F29, 208(SP)
9D0720C0  D7BC00C8   LDC1 F28, 200(SP)
9D0720C4  D7BB00C0   LDC1 F27, 192(SP)
9D0720C8  D7BA00B8   LDC1 F26, 184(SP)
9D0720CC  D7B900B0   LDC1 F25, 176(SP)
9D0720D0  D7B800A8   LDC1 F24, 168(SP)
9D0720D4  D7B700A0   LDC1 F23, 160(SP)
9D0720D8  D7B60098   LDC1 F22, 152(SP)
9D0720DC  D7B50090   LDC1 F21, 144(SP)
9D0720E0  D7B40088   LDC1 F20, 136(SP)
9D0720E4  03E00008   JR RA
9D0720E8  27BD00F0   ADDIU SP, SP, 240
9D072104  8FB30080   LW S3, 128(SP)
9D072108  8FB2007C   LW S2, 124(SP)
9D07210C  8FB10078   LW S1, 120(SP)
9D072110  8FB00074   LW S0, 116(SP)
9D072114  D7BF00E0   LDC1 F31, 224(SP)
9D072118  D7BE00D8   LDC1 F30, 216(SP)
9D07211C  D7BD00D0   LDC1 F29, 208(SP)
9D072120  D7BC00C8   LDC1 F28, 200(SP)
9D072124  D7BB00C0   LDC1 F27, 192(SP)
9D072128  D7BA00B8   LDC1 F26, 184(SP)
9D07212C  D7B900B0   LDC1 F25, 176(SP)
9D072130  D7B800A8   LDC1 F24, 168(SP)
9D072134  D7B700A0   LDC1 F23, 160(SP)
9D072138  D7B60098   LDC1 F22, 152(SP)
9D07213C  D7B50090   LDC1 F21, 144(SP)
9D072140  D7B40088   LDC1 F20, 136(SP)
140:                 
141:                 //---------------------------------------------------------------------------------------------------
142:                 // IMU algorithm update
143:                 
144:                 void MadgwickAHRSupdateIMU(float gx, float gy, float gz, float ax, float ay, float az)
145:                 {
9D073738  27BDFF88   ADDIU SP, SP, -120
9D07373C  AFBF001C   SW RA, 28(SP)
9D073740  F7BD0068   SDC1 F29, 104(SP)
9D073744  F7BC0060   SDC1 F28, 96(SP)
9D073748  F7BB0058   SDC1 F27, 88(SP)
9D07374C  F7BA0050   SDC1 F26, 80(SP)
9D073750  F7B90048   SDC1 F25, 72(SP)
9D073754  F7B80040   SDC1 F24, 64(SP)
9D073758  F7B70038   SDC1 F23, 56(SP)
9D07375C  F7B60030   SDC1 F22, 48(SP)
9D073760  F7B50028   SDC1 F21, 40(SP)
9D073764  F7B40020   SDC1 F20, 32(SP)
9D073800  C7B40088   LWC1 F20, 136(SP)
9D073804  C7B5008C   LWC1 F21, 140(SP)
146:                 	float recipNorm;
147:                 	float s0, s1, s2, s3;
148:                 	float qDot1, qDot2, qDot3, qDot4;
149:                 	float _2q0, _2q1, _2q2, _2q3, _4q0, _4q1, _4q2, _8q1, _8q2, q0q0, q1q1, q2q2, q3q3;
150:                 
151:                 	// Rate of change of quaternion from gyroscope
152:                 	qDot1 = 0.5f * (-q1 * gx - q2 * gy - q3 * gz);
9D073768  8F828068   LW V0, -32664(GP)
9D07376C  C7898064   LWC1 F9, -32668(GP)
9D073770  C7848060   LWC1 F4, -32672(GP)
9D0737A4  460E4DC2   MUL.S F23, F9, F14
9D0737B4  3C048000   LUI A0, -32768
9D0737B8  00441826   XOR V1, V0, A0
9D0737BC  44835000   MTC1 V1, F10
9D0737C0  4EEC5268   MSUB.S F9, F23, F10, F12
9D0737C4  44865000   MTC1 A2, F10
9D0737C8  460A2102   MUL.S F4, F4, F10
9D0737E4  46044DC1   SUB.S F23, F9, F4
9D0737F0  3C049D08   LUI A0, -25336
9D0737F4  C48190B0   LWC1 F1, -28496(A0)
9D073808  4601BDC2   MUL.S F23, F23, F1
153:                 	qDot2 = 0.5f * (q0 * gx + q2 * gz - q3 * gy);
9D073774  C7838024   LWC1 F3, -32732(GP)
9D073778  C7868064   LWC1 F6, -32668(GP)
9D07377C  C7828060   LWC1 F2, -32672(GP)
9D07379C  44865000   MTC1 A2, F10
9D0737A0  460A3182   MUL.S F6, F6, F10
9D0737CC  4CCC19A0   MADD.S F6, F6, F3, F12
9D0737D0  460E1382   MUL.S F14, F2, F14
9D0737E8  460E3381   SUB.S F14, F6, F14
9D07380C  46017742   MUL.S F29, F14, F1
154:                 	qDot3 = 0.5f * (q0 * gy - q1 * gz + q3 * gx);
9D073780  C7858024   LWC1 F5, -32732(GP)
9D073784  C7808068   LWC1 F0, -32664(GP)
9D073788  C7878060   LWC1 F7, -32672(GP)
9D07378C  44860800   MTC1 A2, F1
9D073790  46010002   MUL.S F0, F0, F1
9D0737AC  4C0E2828   MSUB.S F0, F0, F5, F14
9D0737DC  4C0C3820   MADD.S F0, F0, F7, F12
9D073810  46010582   MUL.S F22, F0, F1
155:                 	qDot4 = 0.5f * (q0 * gz + q1 * gy - q2 * gx);
9D073794  C7888024   LWC1 F8, -32732(GP)
9D073798  C7818068   LWC1 F1, -32664(GP)
9D0737A8  460E0842   MUL.S F1, F1, F14
9D0737B0  C7858064   LWC1 F5, -32668(GP)
9D0737D4  4C2A4060   MADD.S F1, F1, F8, F10
9D0737D8  460C2942   MUL.S F5, F5, F12
9D0737EC  46050941   SUB.S F5, F1, F5
156:                 
157:                 	// Compute feedback only if accelerometer measurement valid (avoids NaN in accelerometer normalisation)
158:                 	if (!((ax == 0.0f) && (ay == 0.0f) && (az == 0.0f))) {
9D0737E0  44801000   MTC1 ZERO, F2
9D0737F8  44871800   MTC1 A3, F3
9D0737FC  46021832   C.EQ.S F3, F2
9D073814  45000004   BC1F 0x9D073828
9D073818  46012F02   MUL.S F28, F5, F1
9D07381C  4602A132   C.EQ.S 1, F20, F2
9D073820  4505009A   BC1T 1, .LVL45
9D073824  4602AA32   C.EQ.S 2, F21, F2
9D073A8C  450AFF67   BC1FL 2, .LVL12
9D073A90  4614A302   MUL.S F12, F20, F20
9D073A94  0B41CE6F   J .LVL38
9D073A98  00000000   NOP
159:                 
160:                 		// Normalise accelerometer measurement
161:                 		recipNorm = invSqrt(ax * ax + ay * ay + az * az);
9D073828  4614A302   MUL.S F12, F20, F20
9D07382C  44875000   MTC1 A3, F10
9D073830  4D8A5320   MADD.S F12, F12, F10, F10
9D073834  4D95AB20   MADD.S F12, F12, F21, F21
9D073838  0F41E160   JAL .LFB71, .LVL0, .LFE5, invSqrt
9D07383C  AFA70010   SW A3, 16(SP)
162:                 		ax *= recipNorm;
9D073844  8FA70010   LW A3, 16(SP)
9D073848  44871000   MTC1 A3, F2
9D07384C  46001042   MUL.S F1, F2, F0
163:                 		ay *= recipNorm;
9D0738AC  4600A0C2   MUL.S F3, F20, F0
164:                 		az *= recipNorm;
9D073904  4600AD42   MUL.S F21, F21, F0
165:                 
166:                 		// Auxiliary variables to avoid repeated arithmetic
167:                 		_2q0 = 2.0f * q0;
9D073840  C78D8024   LWC1 F13, -32732(GP)
9D0738B0  460D6B40   ADD.S F13, F13, F13
168:                 		_2q1 = 2.0f * q1;
9D073850  C78B8068   LWC1 F11, -32664(GP)
9D073910  460B5AC0   ADD.S F11, F11, F11
169:                 		_2q2 = 2.0f * q2;
9D073854  C7888064   LWC1 F8, -32668(GP)
9D0738E8  46084200   ADD.S F8, F8, F8
170:                 		_2q3 = 2.0f * q3;
9D073858  C7908060   LWC1 F16, -32672(GP)
9D073860  46108400   ADD.S F16, F16, F16
171:                 		_4q0 = 4.0f * q0;
9D07385C  C7898024   LWC1 F9, -32732(GP)
9D073868  3C029D08   LUI V0, -25336
9D07386C  C44C90B8   LWC1 F12, -28488(V0)
9D0738F4  460C4A42   MUL.S F9, F9, F12
172:                 		_4q1 = 4.0f * q1;
9D073864  C7868068   LWC1 F6, -32664(GP)
9D07389C  460C3182   MUL.S F6, F6, F12
173:                 		_4q2 = 4.0f * q2;
9D073870  C7858064   LWC1 F5, -32668(GP)
9D0738D4  460C2942   MUL.S F5, F5, F12
174:                 		_8q1 = 8.0f * q1;
9D073874  C78A8068   LWC1 F10, -32664(GP)
9D0738CC  3C029D08   LUI V0, -25336
9D0738D0  C44D90BC   LWC1 F13, -28484(V0)
9D0738E4  460D5282   MUL.S F10, F10, F13
175:                 		_8q2 = 8.0f * q2;
9D073878  C7878064   LWC1 F7, -32668(GP)
9D073908  460D39C2   MUL.S F7, F7, F13
176:                 		q0q0 = q0 * q0;
9D07387C  C7928024   LWC1 F18, -32732(GP)
9D073880  C7918024   LWC1 F17, -32732(GP)
9D0738A0  46119442   MUL.S F17, F18, F17
177:                 		q1q1 = q1 * q1;
9D073884  C79B8068   LWC1 F27, -32664(GP)
9D073888  C7848068   LWC1 F4, -32664(GP)
9D0738D8  4604D902   MUL.S F4, F27, F4
178:                 		q2q2 = q2 * q2;
9D07388C  C7828064   LWC1 F2, -32668(GP)
9D073890  C7988064   LWC1 F24, -32668(GP)
9D0738F0  46181082   MUL.S F2, F2, F24
179:                 		q3q3 = q3 * q3;
9D073894  C78F8060   LWC1 F15, -32672(GP)
9D073898  C7838060   LWC1 F3, -32672(GP)
9D0738A4  46037BC2   MUL.S F15, F15, F3
180:                 
181:                 		// Gradient decent algorithm corrective step
182:                 		s0 = _4q0 * q2q2 + _2q2 * ax + _4q0 * q1q1 - _2q1 * ay;
9D073900  46014482   MUL.S F18, F8, F1
9D073920  4E424CA0   MADD.S F18, F18, F9, F2
9D073928  46035CC2   MUL.S F19, F11, F3
9D07393C  4E444920   MADD.S F4, F18, F9, F4
9D073958  46132641   SUB.S F25, F4, F19
183:                 		s1 = _4q1 * q3q3 - _2q3 * ax + 4.0f * q0q0 * q1 - _2q0 * ay - _4q1 + _8q1 * q1q1 + _8q1 * q2q2 + _4q1 * az;
9D0738A8  46018482   MUL.S F18, F16, F1
9D0738B4  C7998068   LWC1 F25, -32664(GP)
9D0738B8  460C8C42   MUL.S F17, F17, F12
9D0738C0  4E4F3528   MSUB.S F20, F18, F6, F15
9D0738C4  46036C82   MUL.S F18, F13, F3
9D0738E0  4E998D20   MADD.S F20, F20, F17, F25
9D0738FC  4612A501   SUB.S F20, F20, F18
9D07390C  4606A501   SUB.S F20, F20, F6
9D07391C  4E845520   MADD.S F20, F20, F10, F4
9D073938  4E825520   MADD.S F20, F20, F10, F2
9D073954  4E953520   MADD.S F20, F20, F6, F21
184:                 		s2 = 4.0f * q0q0 * q2 + _2q0 * ax + _4q2 * q3q3 - _2q3 * ay - _4q2 + _8q2 * q1q1 + _8q2 * q2q2 + _4q2 * az;
9D0738BC  46016CC2   MUL.S F19, F13, F1
9D0738C8  C79A8064   LWC1 F26, -32668(GP)
9D0738DC  4E7A8CE0   MADD.S F19, F19, F17, F26
9D0738EC  46038402   MUL.S F16, F16, F3
9D0738F8  4E6F2BE0   MADD.S F15, F19, F5, F15
9D073914  46107BC1   SUB.S F15, F15, F16
9D073924  46057BC1   SUB.S F15, F15, F5
9D073934  4DE43BE0   MADD.S F15, F15, F7, F4
9D073950  4DE238A0   MADD.S F2, F15, F7, F2
9D073960  4C552E20   MADD.S F24, F2, F5, F21
185:                 		s3 = 4.0f * q1q1 * q3 - _2q1 * ax + 4.0f * q2q2 * q3 - _2q2 * ay;
9D073918  460C2602   MUL.S F24, F4, F12
9D07392C  46015AC2   MUL.S F11, F11, F1
9D073930  C7808060   LWC1 F0, -32672(GP)
9D073940  460C1302   MUL.S F12, F2, F12
9D073944  C7928060   LWC1 F18, -32672(GP)
9D073948  4D60C028   MSUB.S F0, F11, F24, F0
9D07394C  46034202   MUL.S F8, F8, F3
9D07395C  4C1260E0   MADD.S F3, F0, F12, F18
9D073968  46081D41   SUB.S F21, F3, F8
186:                 		recipNorm = invSqrt(s0 * s0 + s1 * s1 + s2 * s2 + s3 * s3); // normalise step magnitude
9D073964  4614A302   MUL.S F12, F20, F20
9D07396C  4D99CB20   MADD.S F12, F12, F25, F25
9D073970  4D98C320   MADD.S F12, F12, F24, F24
9D073974  0F41E160   JAL .LFB71, .LVL0, .LFE5, invSqrt
9D073978  4D95AB20   MADD.S F12, F12, F21, F21
187:                 		s0 *= recipNorm;
9D073980  4600C902   MUL.S F4, F25, F0
188:                 		s1 *= recipNorm;
9D073984  4600A502   MUL.S F20, F20, F0
189:                 		s2 *= recipNorm;
9D073988  4600C082   MUL.S F2, F24, F0
190:                 		s3 *= recipNorm;
9D07398C  4600A802   MUL.S F0, F21, F0
191:                 
192:                 		// Apply feedback step
193:                 		qDot1 -= beta * s0;
9D07397C  C7868028   LWC1 F6, -32728(GP)
9D07399C  46043102   MUL.S F4, F6, F4
9D0739AC  4604BDC1   SUB.S F23, F23, F4
194:                 		qDot2 -= beta * s1;
9D073990  C7858028   LWC1 F5, -32728(GP)
9D0739A0  46142D02   MUL.S F20, F5, F20
9D0739B0  4614EF41   SUB.S F29, F29, F20
195:                 		qDot3 -= beta * s2;
9D073994  C7958028   LWC1 F21, -32728(GP)
9D0739A4  4602A882   MUL.S F2, F21, F2
9D0739B4  4602B581   SUB.S F22, F22, F2
196:                 		qDot4 -= beta * s3;
9D073998  C7838028   LWC1 F3, -32728(GP)
9D0739A8  460018C2   MUL.S F3, F3, F0
9D0739B8  4603E701   SUB.S F28, F28, F3
197:                 	}
198:                 
199:                 	// Integrate rate of change of quaternion to yield quaternion
200:                 	q0 += qDot1 * (1.0f / sampleFreq);
9D0739BC  C7828024   LWC1 F2, -32732(GP)
9D0739C0  3C029D08   LUI V0, -25336
9D0739C4  C44090C0   LWC1 F0, -28480(V0)
9D0739C8  4C40BDE0   MADD.S F23, F2, F23, F0
9D0739CC  E7978024   SWC1 F23, -32732(GP)
201:                 	q1 += qDot2 * (1.0f / sampleFreq);
9D0739D0  C7828068   LWC1 F2, -32664(GP)
9D0739D4  4C40EBA0   MADD.S F14, F2, F29, F0
9D0739D8  E78E8068   SWC1 F14, -32664(GP)
202:                 	q2 += qDot3 * (1.0f / sampleFreq);
9D0739DC  C78C8064   LWC1 F12, -32668(GP)
9D0739E0  4D80B5A0   MADD.S F22, F12, F22, F0
9D0739E4  E7968064   SWC1 F22, -32668(GP)
203:                 	q3 += qDot4 * (1.0f / sampleFreq);
9D0739E8  C7828060   LWC1 F2, -32672(GP)
9D0739EC  4C40E060   MADD.S F1, F2, F28, F0
9D0739F0  E7818060   SWC1 F1, -32672(GP)
204:                 
205:                 	// Normalise quaternion
206:                 	recipNorm = invSqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
9D0739F4  C7828024   LWC1 F2, -32732(GP)
9D0739F8  C7858024   LWC1 F5, -32732(GP)
9D0739FC  C7848068   LWC1 F4, -32664(GP)
9D073A00  C7818068   LWC1 F1, -32664(GP)
9D073A04  C7808064   LWC1 F0, -32668(GP)
9D073A08  C7838064   LWC1 F3, -32668(GP)
9D073A0C  46012102   MUL.S F4, F4, F1
9D073A10  C78C8060   LWC1 F12, -32672(GP)
9D073A14  C7818060   LWC1 F1, -32672(GP)
9D073A18  4C8510A0   MADD.S F2, F4, F2, F5
9D073A1C  4C430020   MADD.S F0, F2, F0, F3
9D073A20  0F41E160   JAL .LFB71, .LVL0, .LFE5, invSqrt
9D073A24  4C016320   MADD.S F12, F0, F12, F1
207:                 	q0 *= recipNorm;
9D073A28  C7818024   LWC1 F1, -32732(GP)
9D073A2C  46000842   MUL.S F1, F1, F0
9D073A30  E7818024   SWC1 F1, -32732(GP)
208:                 	q1 *= recipNorm;
9D073A34  C7818068   LWC1 F1, -32664(GP)
9D073A38  46000842   MUL.S F1, F1, F0
9D073A3C  E7818068   SWC1 F1, -32664(GP)
209:                 	q2 *= recipNorm;
9D073A40  C7818064   LWC1 F1, -32668(GP)
9D073A44  46000842   MUL.S F1, F1, F0
9D073A48  E7818064   SWC1 F1, -32668(GP)
210:                 	q3 *= recipNorm;
9D073A4C  C7818060   LWC1 F1, -32672(GP)
9D073A50  46000802   MUL.S F0, F1, F0
9D073A54  E7808060   SWC1 F0, -32672(GP)
211:                 }
9D073A58  8FBF001C   LW RA, 28(SP)
9D073A5C  D7BD0068   LDC1 F29, 104(SP)
9D073A60  D7BC0060   LDC1 F28, 96(SP)
9D073A64  D7BB0058   LDC1 F27, 88(SP)
9D073A68  D7BA0050   LDC1 F26, 80(SP)
9D073A6C  D7B90048   LDC1 F25, 72(SP)
9D073A70  D7B80040   LDC1 F24, 64(SP)
9D073A74  D7B70038   LDC1 F23, 56(SP)
9D073A78  D7B60030   LDC1 F22, 48(SP)
9D073A7C  D7B50028   LDC1 F21, 40(SP)
9D073A80  D7B40020   LDC1 F20, 32(SP)
9D073A84  03E00008   JR RA
9D073A88  27BD0078   ADDIU SP, SP, 120
9D073A8C  450AFF67   BC1FL 2, .LVL12
9D073A90  4614A302   MUL.S F12, F20, F20
9D073A94  0B41CE6F   J .LVL38
9D073A98  00000000   NOP
212:                 
213:                 int expensive = 1;
214:                 //---------------------------------------------------------------------------------------------------
215:                 // Fast inverse square-root
216:                 // See: http://en.wikipedia.org/wiki/Fast_inverse_square_root
217:                 // change to standards version
218:                 
219:                 float invSqrt(float x)
220:                 {
9D078580  27BDFFE8   ADDIU SP, SP, -24
9D078584  AFBF0014   SW RA, 20(SP)
221:                 	if (expensive) {
9D078588  8F828020   LW V0, -32736(GP)
9D07858C  14400012   BNE V0, ZERO, .LVL5, .LBB17, .LBB19
9D078590  44036000   MFC1 V1, F12
222:                 		/* optimal but expensive method: */
223:                 		return 1.0f / sqrt(x);
9D0785E0  3C029D08   LUI V0, -25336
9D0785E4  D44290A8   LDC1 F2, -28504(V0)
9D0785E8  46201003   DIV.D F0, F2, F0
9D0785EC  46200020   CVT.S.D F0, F0
224:                 	} else {
225:                 		const float x2 = x * 0.5F;
9D078598  3C029D08   LUI V0, -25336
9D07859C  C44090B0   LWC1 F0, -28496(V0)
9D0785A0  46006002   MUL.S F0, F12, F0
226:                 		const float threehalfs = 1.5F;
227:                 
228:                 		union {
229:                 			float f;
230:                 			unsigned long i;
231:                 		} conv = {.f = x};
232:                 		conv.i = 0x5f3759df - (conv.i >> 1);
9D078594  00032042   SRL A0, V1, 1
9D0785A4  3C055F37   LUI A1, 24375
9D0785A8  24A559DF   ADDIU A1, A1, 23007
233:                 		conv.f *= (threehalfs - (x2 * conv.f * conv.f));
9D0785AC  00A41023   SUBU V0, A1, A0
9D0785B0  44820800   MTC1 V0, F1
9D0785B4  46000802   MUL.S F0, F1, F0
9D0785B8  46000802   MUL.S F0, F1, F0
9D0785BC  3C049D08   LUI A0, -25336
9D0785C0  C48290B4   LWC1 F2, -28492(A0)
9D0785C4  46001001   SUB.S F0, F2, F0
9D0785C8  46000802   MUL.S F0, F1, F0
234:                 		return conv.f;
235:                 	}
236:                 }
9D0785CC  8FBF0014   LW RA, 20(SP)
9D0785D0  03E00008   JR RA
9D0785D4  27BD0018   ADDIU SP, SP, 24
9D0785F0  8FBF0014   LW RA, 20(SP)
9D0785F4  03E00008   JR RA
9D0785F8  27BD0018   ADDIU SP, SP, 24
237:                 
238:                 //====================================================================================================
239:                 // END OF CODE
240:                 //====================================================================================================
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_setMagScale.c
1:                   /**
2:                    * @file LSM9DS1_setMagScale.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  int __pinM;
21:                  float __mRes;
22:                  unsigned char __settings_mag_scale = 16;
23:                  
24:                  
25:                  void imu_setMagScale(unsigned char mScl)
26:                  {
9D076264  27BDFFE0   ADDIU SP, SP, -32
9D076268  AFBF001C   SW RA, 28(SP)
9D07626C  AFB00018   SW S0, 24(SP)
27:                    if ((mScl != 4) && (mScl != 8) && (mScl != 12) && (mScl != 16)) mScl = 4;
9D076270  24020004   ADDIU V0, ZERO, 4
9D076274  10820008   BEQ A0, V0, .LVL1
9D076278  00808021   ADDU S0, A0, ZERO
9D07627C  24020008   ADDIU V0, ZERO, 8
9D076280  10820019   BEQ A0, V0, .LVL4
9D076284  2402000C   ADDIU V0, ZERO, 12
9D076288  1082002B   BEQ A0, V0, .LVL7
9D07628C  24020010   ADDIU V0, ZERO, 16
9D076290  1082003D   BEQ A0, V0, .LVL10
9D076294  93848098   LBU A0, -32616(GP)
28:                   
29:                    // We need to preserve the other bytes in CTRL_REG6_XM. So, first read it:
30:                    unsigned char temp;
31:                    imu_SPIreadBytes(__pinM, CTRL_REG2_M, &temp, 1);
9D076298  93848098   LBU A0, -32616(GP)
9D07629C  24050021   ADDIU A1, ZERO, 33
9D0762A0  27A60010   ADDIU A2, SP, 16
9D0762A4  0F41DAF0   JAL imu_SPIreadBytes
9D0762A8  24070001   ADDIU A3, ZERO, 1
9D0762E8  93848098   LBU A0, -32616(GP)
9D0762EC  24050021   ADDIU A1, ZERO, 33
9D0762F0  27A60010   ADDIU A2, SP, 16
9D0762F4  0F41DAF0   JAL imu_SPIreadBytes
9D0762F8  24070001   ADDIU A3, ZERO, 1
9D076338  93848098   LBU A0, -32616(GP)
9D07633C  24050021   ADDIU A1, ZERO, 33
9D076340  27A60010   ADDIU A2, SP, 16
9D076344  0F41DAF0   JAL imu_SPIreadBytes
9D076348  24070001   ADDIU A3, ZERO, 1
9D076388  24050021   ADDIU A1, ZERO, 33
9D07638C  27A60010   ADDIU A2, SP, 16
9D076390  0F41DAF0   JAL imu_SPIreadBytes
9D076394  24070001   ADDIU A3, ZERO, 1
32:                    // Then mask out the mag scale bits:
33:                    temp &= 0xFF^(0x3 << 5);
9D0762AC  93A60010   LBU A2, 16(SP)
9D0762B0  30C6009F   ANDI A2, A2, 159
9D0762B4  A3A60010   SB A2, 16(SP)
9D0762FC  93A60010   LBU A2, 16(SP)
9D07634C  93A60010   LBU A2, 16(SP)
9D076398  93A60010   LBU A2, 16(SP)
34:                    
35:                    switch (mScl)
36:                    {
37:                    case 8:
38:                      temp |= (0x1 << 5);
9D076300  30C6009F   ANDI A2, A2, 159
9D076304  34C60020   ORI A2, A2, 32
9D076308  A3A60010   SB A2, 16(SP)
39:                      __settings_mag_scale = 8;
9D07630C  A3908014   SB S0, -32748(GP)
40:                      __mRes = 3448.28;
9D076310  3C029D08   LUI V0, -25336
9D076314  C44091A8   LWC1 F0, -28248(V0)
9D076318  E78080A8   SWC1 F0, -32600(GP)
41:                      break;
42:                    case 12:
43:                      temp |= (0x2 << 5);
9D076350  30C6009F   ANDI A2, A2, 159
9D076354  34C60040   ORI A2, A2, 64
9D076358  A3A60010   SB A2, 16(SP)
44:                      __settings_mag_scale = 12;
9D07635C  A3908014   SB S0, -32748(GP)
45:                      __mRes = 2298.85;
9D076360  3C029D08   LUI V0, -25336
9D076364  C44091AC   LWC1 F0, -28244(V0)
9D076368  E78080A8   SWC1 F0, -32600(GP)
46:                      break;
47:                    case 16:
48:                      temp |= (0x3 << 5);
9D07639C  34C60060   ORI A2, A2, 96
9D0763A0  30C600FF   ANDI A2, A2, 255
9D0763A4  A3A60010   SB A2, 16(SP)
49:                      __settings_mag_scale = 16;
9D0763A8  A3908014   SB S0, -32748(GP)
50:                      __mRes = 1724.14;
9D0763AC  3C029D08   LUI V0, -25336
9D0763B0  C44091B0   LWC1 F0, -28240(V0)
9D0763B4  E78080A8   SWC1 F0, -32600(GP)
51:                      break;
52:                    default:
53:                      __settings_mag_scale = 4;
9D0762B8  24020004   ADDIU V0, ZERO, 4
9D0762BC  A3828014   SB V0, -32748(GP)
54:                      __mRes = 6896.55;
9D0762C0  3C029D08   LUI V0, -25336
9D0762C4  C44091B4   LWC1 F0, -28236(V0)
9D0762C8  E78080A8   SWC1 F0, -32600(GP)
55:                      break;
56:                    }  
57:                    
58:                    imu_SPIwriteByte(__pinM, CTRL_REG2_M, temp);
9D0762CC  93848098   LBU A0, -32616(GP)
9D0762D0  0F41DF40   JAL imu_SPIwriteByte
9D0762D4  24050021   ADDIU A1, ZERO, 33
9D07631C  93848098   LBU A0, -32616(GP)
9D076320  0F41DF40   JAL imu_SPIwriteByte
9D076324  24050021   ADDIU A1, ZERO, 33
9D07636C  93848098   LBU A0, -32616(GP)
9D076370  0F41DF40   JAL imu_SPIwriteByte
9D076374  24050021   ADDIU A1, ZERO, 33
9D0763B8  93848098   LBU A0, -32616(GP)
9D0763BC  0F41DF40   JAL imu_SPIwriteByte
9D0763C0  24050021   ADDIU A1, ZERO, 33
59:                  }
9D0762D8  8FBF001C   LW RA, 28(SP)
9D0762DC  8FB00018   LW S0, 24(SP)
9D0762E0  03E00008   JR RA
9D0762E4  27BD0020   ADDIU SP, SP, 32
9D076328  8FBF001C   LW RA, 28(SP)
9D07632C  8FB00018   LW S0, 24(SP)
9D076330  03E00008   JR RA
9D076334  27BD0020   ADDIU SP, SP, 32
9D076378  8FBF001C   LW RA, 28(SP)
9D07637C  8FB00018   LW S0, 24(SP)
9D076380  03E00008   JR RA
9D076384  27BD0020   ADDIU SP, SP, 32
9D0763C4  8FBF001C   LW RA, 28(SP)
9D0763C8  8FB00018   LW S0, 24(SP)
9D0763CC  03E00008   JR RA
9D0763D0  27BD0020   ADDIU SP, SP, 32
60:                  
61:                  
62:                  
63:                  /*
64:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
65:                   */
66:                  
67:                  /**
68:                   * TERMS OF USE: MIT License
69:                   *
70:                   * Permission is hereby granted, free of charge, to any person obtaining a
71:                   * copy of this software and associated documentation files (the "Software"),
72:                   * to deal in the Software without restriction, including without limitation
73:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
74:                   * and/or sell copies of the Software, and to permit persons to whom the
75:                   * Software is furnished to do so, subject to the following conditions:
76:                   *
77:                   * The above copyright notice and this permission notice shall be included in
78:                   * all copies or substantial portions of the Software.
79:                   *
80:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
81:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
82:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
83:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
84:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
85:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
86:                   * DEALINGS IN THE SOFTWARE.
87:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_setGyroScale.c
1:                   /**
2:                    * @file LSM9DS1_setGyroScale.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  int __pinAG;
21:                  
22:                  unsigned int  __settings_gyro_scale = 2000;
23:                  float __gRes;
24:                  
25:                  
26:                  void imu_setGyroScale(unsigned int gScl)
27:                  {
9D0773A8  27BDFFE0   ADDIU SP, SP, -32
9D0773AC  AFBF001C   SW RA, 28(SP)
28:                    if ((gScl != 245) && (gScl != 500) && (gScl != 2000)) gScl = 245;
9D0773B0  240300F5   ADDIU V1, ZERO, 245
9D0773B4  10830006   BEQ A0, V1, .LVL1
9D0773B8  00801021   ADDU V0, A0, ZERO
9D0773BC  240301F4   ADDIU V1, ZERO, 500
9D0773C0  10830016   BEQ A0, V1, .LVL4
9D0773C4  240307D0   ADDIU V1, ZERO, 2000
9D0773C8  10830027   BEQ A0, V1, .LVL7
9D0773CC  93848094   LBU A0, -32620(GP)
29:                  
30:                    __settings_gyro_scale = gScl;
9D0773E0  240200F5   ADDIU V0, ZERO, 245
9D0773E4  AF828010   SW V0, -32752(GP)
9D07742C  AF828010   SW V0, -32752(GP)
9D077474  AF828010   SW V0, -32752(GP)
31:                    __gRes = 32768.0 / ((float) gScl);
9D0773E8  3C029D08   LUI V0, -25336
9D0773EC  C44091D8   LWC1 F0, -28200(V0)
9D077430  3C029D08   LUI V0, -25336
9D077434  C44091D0   LWC1 F0, -28208(V0)
9D077478  3C029D08   LUI V0, -25336
9D07747C  C44091D4   LWC1 F0, -28204(V0)
32:                  
33:                    // Read current value of CTRL_REG1_G:
34:                    unsigned char ctrl1RegValue;
35:                    imu_SPIreadBytes(__pinAG, CTRL_REG1_G, &ctrl1RegValue, 1);
9D0773D0  93848094   LBU A0, -32620(GP)
9D0773D4  24050010   ADDIU A1, ZERO, 16
9D0773D8  27A60010   ADDIU A2, SP, 16
9D0773DC  24070001   ADDIU A3, ZERO, 1
9D0773F0  0F41DAF0   JAL imu_SPIreadBytes
9D0773F4  E78080A4   SWC1 F0, -32604(GP)
9D07741C  93848094   LBU A0, -32620(GP)
9D077420  24050010   ADDIU A1, ZERO, 16
9D077424  27A60010   ADDIU A2, SP, 16
9D077428  24070001   ADDIU A3, ZERO, 1
9D077438  0F41DAF0   JAL imu_SPIreadBytes
9D07743C  E78080A4   SWC1 F0, -32604(GP)
9D077468  24050010   ADDIU A1, ZERO, 16
9D07746C  27A60010   ADDIU A2, SP, 16
9D077470  24070001   ADDIU A3, ZERO, 1
9D077480  0F41DAF0   JAL imu_SPIreadBytes
9D077484  E78080A4   SWC1 F0, -32604(GP)
36:                    // Mask out scale bits (3 & 4):
37:                    ctrl1RegValue &= 0xE7;
9D0773F8  93A60010   LBU A2, 16(SP)
9D0773FC  30C600E7   ANDI A2, A2, 231
9D077400  A3A60010   SB A2, 16(SP)
9D077440  93A60010   LBU A2, 16(SP)
9D077488  93A60010   LBU A2, 16(SP)
38:                  
39:                    switch (gScl)
40:                    {
41:                      case 500:
42:                        ctrl1RegValue |= (0x1 << 3);
9D077444  30C600E7   ANDI A2, A2, 231
9D077448  34C60008   ORI A2, A2, 8
9D07744C  A3A60010   SB A2, 16(SP)
43:                        break;
44:                      case 2000:
45:                        ctrl1RegValue |= (0x3 << 3);
9D07748C  34C60018   ORI A2, A2, 24
9D077490  30C600FF   ANDI A2, A2, 255
9D077494  A3A60010   SB A2, 16(SP)
46:                        break;
47:                      default:
48:                        break;
49:                    }
50:                    imu_SPIwriteByte(__pinAG, CTRL_REG1_G, ctrl1RegValue);  
9D077404  93848094   LBU A0, -32620(GP)
9D077408  0F41DF40   JAL imu_SPIwriteByte
9D07740C  24050010   ADDIU A1, ZERO, 16
9D077450  93848094   LBU A0, -32620(GP)
9D077454  0F41DF40   JAL imu_SPIwriteByte
9D077458  24050010   ADDIU A1, ZERO, 16
9D077498  93848094   LBU A0, -32620(GP)
9D07749C  0F41DF40   JAL imu_SPIwriteByte
9D0774A0  24050010   ADDIU A1, ZERO, 16
51:                  }
9D077410  8FBF001C   LW RA, 28(SP)
9D077414  03E00008   JR RA
9D077418  27BD0020   ADDIU SP, SP, 32
9D07745C  8FBF001C   LW RA, 28(SP)
9D077460  03E00008   JR RA
9D077464  27BD0020   ADDIU SP, SP, 32
9D0774A4  8FBF001C   LW RA, 28(SP)
9D0774A8  03E00008   JR RA
9D0774AC  27BD0020   ADDIU SP, SP, 32
52:                  
53:                  
54:                  
55:                  
56:                  /*
57:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
58:                   */
59:                  
60:                  /**
61:                   * TERMS OF USE: MIT License
62:                   *
63:                   * Permission is hereby granted, free of charge, to any person obtaining a
64:                   * copy of this software and associated documentation files (the "Software"),
65:                   * to deal in the Software without restriction, including without limitation
66:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
67:                   * and/or sell copies of the Software, and to permit persons to whom the
68:                   * Software is furnished to do so, subject to the following conditions:
69:                   *
70:                   * The above copyright notice and this permission notice shall be included in
71:                   * all copies or substantial portions of the Software.
72:                   *
73:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
74:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
75:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
76:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
77:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
78:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
79:                   * DEALINGS IN THE SOFTWARE.
80:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_setCalibration.c
1:                   /**
2:                    * @file LSM9DS1_setCalibration.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  #include "imu.h"
19:                  #include "../../eadog.h"
20:                  //#include "simpletools.h"
21:                  
22:                  //i2c *eeBus;                                   // I2C bus ID
23:                  
24:                  
25:                  int __gBiasRaw[3];
26:                  int __aBiasRaw[3];
27:                  int __mBiasRaw[3];
28:                  int __pinM;
29:                  char __autoCalc;
30:                  static char tbuf[] = "LSM9DS1";
31:                  
32:                  void imu_setMagCalibration(int mxBias, int myBias, int mzBias)
33:                  {
9D0760D8  27BDFF28   ADDIU SP, SP, -216
9D0760DC  AFBF00D4   SW RA, 212(SP)
9D0760E0  AFB500D0   SW S5, 208(SP)
9D0760E4  AFB400CC   SW S4, 204(SP)
9D0760E8  AFB300C8   SW S3, 200(SP)
9D0760EC  AFB200C4   SW S2, 196(SP)
9D0760F0  AFB100C0   SW S1, 192(SP)
9D0760F4  AFB000BC   SW S0, 188(SP)
34:                  	int k;
35:                  	char buffer[STR_BUF_SIZE];
36:                  
37:                  	__mBiasRaw[X_AXIS] = mxBias;
9D0760F8  3C148000   LUI S4, -32768
9D076100  AE8401C0   SW A0, 448(S4)
38:                  	__mBiasRaw[Y_AXIS] = myBias;
9D0760FC  269301C0   ADDIU S3, S4, 448
9D076104  AE650004   SW A1, 4(S3)
39:                  	__mBiasRaw[Z_AXIS] = mzBias;
9D076108  AE660008   SW A2, 8(S3)
9D07610C  02609021   ADDU S2, S3, ZERO
9D076110  00808821   ADDU S1, A0, ZERO
9D076114  24100005   ADDIU S0, ZERO, 5
40:                  
41:                  	unsigned char msb, lsb;
42:                  	for (k = 0; k < 3; k++) {
9D076118  2415000B   ADDIU S5, ZERO, 11
9D076148  1215000F   BEQ S0, S5, .LVL11
9D07614C  26520004   ADDIU S2, S2, 4
9D076150  8E510000   LW S1, 0(S2)
9D076180  1615FFF3   BNE S0, S5, .LVL7
9D076184  26520004   ADDIU S2, S2, 4
43:                  		msb = (__mBiasRaw[k] & 0xFF00) >> 8;
44:                  		lsb = __mBiasRaw[k] & 0x00FF;
45:                  		imu_SPIwriteByte(__pinM, OFFSET_X_REG_L_M + (2 * k), lsb);
9D07611C  93848098   LBU A0, -32616(GP)
9D076120  02002821   ADDU A1, S0, ZERO
9D076124  0F41DF40   JAL imu_SPIwriteByte
9D076128  322600FF   ANDI A2, S1, 255
9D076154  93848098   LBU A0, -32616(GP)
9D076158  02002821   ADDU A1, S0, ZERO
9D07615C  0F41DF40   JAL imu_SPIwriteByte
9D076160  322600FF   ANDI A2, S1, 255
46:                  		imu_SPIwriteByte(__pinM, OFFSET_X_REG_H_M + (2 * k), msb);
9D07612C  93848098   LBU A0, -32616(GP)
9D076130  26050001   ADDIU A1, S0, 1
9D076134  7E263A00   EXT A2, S1, 8, 8
9D076138  0F41DF40   JAL imu_SPIwriteByte
9D07613C  30A500FF   ANDI A1, A1, 255
9D076140  26100002   ADDIU S0, S0, 2
9D076144  321000FF   ANDI S0, S0, 255
9D076164  93848098   LBU A0, -32616(GP)
9D076168  26050001   ADDIU A1, S0, 1
9D07616C  7E263A00   EXT A2, S1, 8, 8
9D076170  0F41DF40   JAL imu_SPIwriteByte
9D076174  30A500FF   ANDI A1, A1, 255
9D076178  26100002   ADDIU S0, S0, 2
9D07617C  321000FF   ANDI S0, S0, 255
47:                  	}
48:                  
49:                  	//i2c_out(eeBus, 0b1010000, 63280, 2, "LSM9DS1", 7); 
50:                  	if (set_nvram_str((void*) pmyflash, tbuf)) {
9D076188  8F848040   LW A0, -32704(GP)
9D07618C  0F41E257   JAL set_nvram_str
9D076190  27858018   ADDIU A1, GP, -32744
9D076194  1440001C   BNE V0, ZERO, .LVL18
9D076198  3C039D08   LUI V1, -25336
51:                  		sprintf(buffer, "Mag LSM9DS1 write failed");
9D076208  24628AD0   ADDIU V0, V1, -30000
9D07620C  8C6B8AD0   LW T3, -30000(V1)
9D076210  8C4A0004   LW T2, 4(V0)
9D076214  8C490008   LW T1, 8(V0)
9D076218  8C48000C   LW T0, 12(V0)
9D07621C  8C470010   LW A3, 16(V0)
9D076220  8C430014   LW V1, 20(V0)
9D076224  90420018   LBU V0, 24(V0)
9D076234  AFAB0010   SW T3, 16(SP)
9D076238  AFAA0014   SW T2, 20(SP)
9D07623C  AFA90018   SW T1, 24(SP)
9D076240  AFA8001C   SW T0, 28(SP)
9D076244  AFA70020   SW A3, 32(SP)
9D076248  AFA30024   SW V1, 36(SP)
52:                  		eaDogM_WriteStringAtPos(9, 0, buffer);
9D076228  24040009   ADDIU A0, ZERO, 9
9D07622C  00002821   ADDU A1, ZERO, ZERO
9D076230  27A60010   ADDIU A2, SP, 16
9D07624C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D076250  A3A20028   SB V0, 40(SP)
53:                  		OledUpdate();
9D076254  0F41E23E   JAL OledUpdate
9D076258  00000000   NOP
54:                  	};
55:                  	//while (i2c_busy(eeBus, 0b1010000));
56:                  	char biasBuf[7] = {'m', 0, 0, 0, 0, 0, 0};
9D0761C0  240A006D   ADDIU T2, ZERO, 109
9D0761C4  A3AA00B0   SB T2, 176(SP)
57:                  
58:                  	for (k = 0; k < 3; k++) {
59:                  		biasBuf[k * 2 + 1] = (__mBiasRaw[k] >> 8) & 0xFF;
9D07619C  8E8601C0   LW A2, 448(S4)
9D0761A0  8E630004   LW V1, 4(S3)
9D0761A4  8E620008   LW V0, 8(S3)
9D0761A8  00064A03   SRA T1, A2, 8
9D0761AC  00034203   SRA T0, V1, 8
9D0761B0  00023A03   SRA A3, V0, 8
9D0761C8  A3A900B1   SB T1, 177(SP)
9D0761D0  A3A800B3   SB T0, 179(SP)
9D0761D8  A3A700B5   SB A3, 181(SP)
9D07625C  0B41D868   J 0x9D0761A0
9D076260  8E8601C0   LW A2, 448(S4)
60:                  		biasBuf[k * 2 + 2] = __mBiasRaw[k] & 0xFF;
9D0761CC  A3A600B2   SB A2, 178(SP)
9D0761D4  A3A300B4   SB V1, 180(SP)
61:                  	}
62:                  
63:                  	set_nvram_str((void*) &pmyflash[7], biasBuf);
9D0761B4  8F848040   LW A0, -32704(GP)
9D0761B8  2484001C   ADDIU A0, A0, 28
9D0761BC  27A500B0   ADDIU A1, SP, 176
9D0761DC  0F41E257   JAL set_nvram_str
9D0761E0  A3A200B6   SB V0, 182(SP)
64:                  	//i2c_out(eeBus, 0b1010000, 63287, 2, biasBuf, 7); 
65:                  	//while (i2c_busy(eeBus, 0b1010000)); 
66:                  
67:                  }
9D0761E4  8FBF00D4   LW RA, 212(SP)
9D0761E8  8FB500D0   LW S5, 208(SP)
9D0761EC  8FB400CC   LW S4, 204(SP)
9D0761F0  8FB300C8   LW S3, 200(SP)
9D0761F4  8FB200C4   LW S2, 196(SP)
9D0761F8  8FB100C0   LW S1, 192(SP)
9D0761FC  8FB000BC   LW S0, 188(SP)
9D076200  03E00008   JR RA
9D076204  27BD00D8   ADDIU SP, SP, 216
9D076208  24628AD0   ADDIU V0, V1, -30000
9D07620C  8C6B8AD0   LW T3, -30000(V1)
9D076210  8C4A0004   LW T2, 4(V0)
9D076214  8C490008   LW T1, 8(V0)
9D076218  8C48000C   LW T0, 12(V0)
9D07621C  8C470010   LW A3, 16(V0)
9D076220  8C430014   LW V1, 20(V0)
9D076224  90420018   LBU V0, 24(V0)
9D076228  24040009   ADDIU A0, ZERO, 9
9D07622C  00002821   ADDU A1, ZERO, ZERO
9D076230  27A60010   ADDIU A2, SP, 16
9D076234  AFAB0010   SW T3, 16(SP)
9D076238  AFAA0014   SW T2, 20(SP)
9D07623C  AFA90018   SW T1, 24(SP)
9D076240  AFA8001C   SW T0, 28(SP)
9D076244  AFA70020   SW A3, 32(SP)
9D076248  AFA30024   SW V1, 36(SP)
9D07624C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D076250  A3A20028   SB V0, 40(SP)
9D076254  0F41E23E   JAL OledUpdate
9D076258  00000000   NOP
9D07625C  0B41D868   J 0x9D0761A0
9D076260  8E8601C0   LW A2, 448(S4)
68:                  
69:                  void imu_setAccelCalibration(int axBias, int ayBias, int azBias)
70:                  {
9D0774B0  27BDFF38   ADDIU SP, SP, -200
9D0774B4  AFBF00C4   SW RA, 196(SP)
9D0774B8  AFB100C0   SW S1, 192(SP)
9D0774BC  AFB000BC   SW S0, 188(SP)
71:                  	int k;
72:                  	char buffer[STR_BUF_SIZE];
73:                  
74:                  	__aBiasRaw[X_AXIS] = axBias;
9D0774C0  3C118000   LUI S1, -32768
9D0774C4  AE2401CC   SW A0, 460(S1)
75:                  	__aBiasRaw[Y_AXIS] = ayBias;
9D0774CC  263001CC   ADDIU S0, S1, 460
9D0774D0  AE050004   SW A1, 4(S0)
76:                  	__aBiasRaw[Z_AXIS] = azBias;
77:                  
78:                  	//i2c_out(eeBus, 0b1010000, 63280, 2, "LSM9DS1", 7); 
79:                  	if (set_nvram_str((void*) pmyflash, tbuf)) {
9D0774C8  8F848040   LW A0, -32704(GP)
9D0774D4  27858018   ADDIU A1, GP, -32744
9D0774D8  0F41E257   JAL set_nvram_str
9D0774DC  AE060008   SW A2, 8(S0)
9D0774E0  1440001B   BNE V0, ZERO, .LVL30
9D0774E4  3C039D08   LUI V1, -25336
80:                  		sprintf(buffer, "accel LSM9DS1 write failed");
9D077550  24628AEC   ADDIU V0, V1, -29972
9D077554  8C6C8AEC   LW T4, -29972(V1)
9D077558  8C4B0004   LW T3, 4(V0)
9D07755C  8C4A0008   LW T2, 8(V0)
9D077560  8C49000C   LW T1, 12(V0)
9D077564  8C480010   LW T0, 16(V0)
9D077568  8C470014   LW A3, 20(V0)
9D07756C  94430018   LHU V1, 24(V0)
9D077570  9042001A   LBU V0, 26(V0)
9D077580  AFAC0010   SW T4, 16(SP)
9D077584  AFAB0014   SW T3, 20(SP)
9D077588  AFAA0018   SW T2, 24(SP)
9D07758C  AFA9001C   SW T1, 28(SP)
9D077590  AFA80020   SW T0, 32(SP)
9D077594  AFA70024   SW A3, 36(SP)
9D077598  A7A30028   SH V1, 40(SP)
81:                  		eaDogM_WriteStringAtPos(9, 0, buffer);
9D077574  24040009   ADDIU A0, ZERO, 9
9D077578  00002821   ADDU A1, ZERO, ZERO
9D07757C  27A60010   ADDIU A2, SP, 16
9D07759C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D0775A0  A3A2002A   SB V0, 42(SP)
82:                  		OledUpdate();
9D0775A4  0F41E23E   JAL OledUpdate
9D0775A8  00000000   NOP
83:                  	};
84:                  	//while (i2c_busy(eeBus, 0b1010000));
85:                  	char biasBuf[7] = {'a', 0, 0, 0, 0, 0, 0};
9D07750C  240A0061   ADDIU T2, ZERO, 97
9D077510  A3AA00B0   SB T2, 176(SP)
86:                  
87:                  	for (k = 0; k < 3; k++) {
88:                  		biasBuf[k * 2 + 1] = (__aBiasRaw[k] >> 8) & 0xFF;
9D0774E8  8E2601CC   LW A2, 460(S1)
9D0774EC  8E030004   LW V1, 4(S0)
9D0774F0  8E020008   LW V0, 8(S0)
9D0774F4  00064A03   SRA T1, A2, 8
9D0774F8  00034203   SRA T0, V1, 8
9D0774FC  00023A03   SRA A3, V0, 8
9D077514  A3A900B1   SB T1, 177(SP)
9D07751C  A3A800B3   SB T0, 179(SP)
9D077524  A3A700B5   SB A3, 181(SP)
9D0775AC  0B41DD3B   J 0x9D0774EC
9D0775B0  8E2601CC   LW A2, 460(S1)
89:                  		biasBuf[k * 2 + 2] = __aBiasRaw[k] & 0xFF;
9D077518  A3A600B2   SB A2, 178(SP)
9D077520  A3A300B4   SB V1, 180(SP)
90:                  	}
91:                  
92:                  	set_nvram_str((void*) &pmyflash[14], biasBuf);
9D077500  8F848040   LW A0, -32704(GP)
9D077504  24840038   ADDIU A0, A0, 56
9D077508  27A500B0   ADDIU A1, SP, 176
9D077528  0F41E257   JAL set_nvram_str
9D07752C  A3A200B6   SB V0, 182(SP)
93:                  	//i2c_out(eeBus, 0b1010000, 63294, 2, biasBuf, 7); 
94:                  	//while (i2c_busy(eeBus, 0b1010000)); 
95:                  
96:                  	__autoCalc |= 0b10;
9D077530  9382805C   LBU V0, -32676(GP)
9D077534  34420002   ORI V0, V0, 2
9D077538  A382805C   SB V0, -32676(GP)
97:                  }
9D07753C  8FBF00C4   LW RA, 196(SP)
9D077540  8FB100C0   LW S1, 192(SP)
9D077544  8FB000BC   LW S0, 188(SP)
9D077548  03E00008   JR RA
9D07754C  27BD00C8   ADDIU SP, SP, 200
9D077550  24628AEC   ADDIU V0, V1, -29972
9D077554  8C6C8AEC   LW T4, -29972(V1)
9D077558  8C4B0004   LW T3, 4(V0)
9D07755C  8C4A0008   LW T2, 8(V0)
9D077560  8C49000C   LW T1, 12(V0)
9D077564  8C480010   LW T0, 16(V0)
9D077568  8C470014   LW A3, 20(V0)
9D07756C  94430018   LHU V1, 24(V0)
9D077570  9042001A   LBU V0, 26(V0)
9D077574  24040009   ADDIU A0, ZERO, 9
9D077578  00002821   ADDU A1, ZERO, ZERO
9D07757C  27A60010   ADDIU A2, SP, 16
9D077580  AFAC0010   SW T4, 16(SP)
9D077584  AFAB0014   SW T3, 20(SP)
9D077588  AFAA0018   SW T2, 24(SP)
9D07758C  AFA9001C   SW T1, 28(SP)
9D077590  AFA80020   SW T0, 32(SP)
9D077594  AFA70024   SW A3, 36(SP)
9D077598  A7A30028   SH V1, 40(SP)
9D07759C  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D0775A0  A3A2002A   SB V0, 42(SP)
9D0775A4  0F41E23E   JAL OledUpdate
9D0775A8  00000000   NOP
9D0775AC  0B41DD3B   J 0x9D0774EC
9D0775B0  8E2601CC   LW A2, 460(S1)
98:                  
99:                  void imu_setGyroCalibration(int gxBias, int gyBias, int gzBias)
100:                 {
9D0776B8  27BDFF38   ADDIU SP, SP, -200
9D0776BC  AFBF00C4   SW RA, 196(SP)
9D0776C0  AFB100C0   SW S1, 192(SP)
9D0776C4  AFB000BC   SW S0, 188(SP)
101:                 	int k;
102:                 	char buffer[STR_BUF_SIZE];
103:                 
104:                 	__gBiasRaw[X_AXIS] = gxBias;
9D0776C8  3C118000   LUI S1, -32768
9D0776CC  AE2401B4   SW A0, 436(S1)
105:                 	__gBiasRaw[Y_AXIS] = gyBias;
9D0776D4  263001B4   ADDIU S0, S1, 436
9D0776D8  AE050004   SW A1, 4(S0)
106:                 	__gBiasRaw[Z_AXIS] = gzBias;
107:                 
108:                 	//i2c_out(eeBus, 0b1010000, 63280, 2, "LSM9DS1", 7); 
109:                 	if (set_nvram_str((void*) pmyflash, tbuf)) {
9D0776D0  8F848040   LW A0, -32704(GP)
9D0776DC  27858018   ADDIU A1, GP, -32744
9D0776E0  0F41E257   JAL set_nvram_str
9D0776E4  AE060008   SW A2, 8(S0)
9D0776E8  1440001A   BNE V0, ZERO, .LVL42
9D0776EC  3C039D08   LUI V1, -25336
110:                 		sprintf(buffer, "Gyro LSM9DS1 write failed");
9D077754  24628B08   ADDIU V0, V1, -29944
9D077758  8C6B8B08   LW T3, -29944(V1)
9D07775C  8C4A0004   LW T2, 4(V0)
9D077760  8C490008   LW T1, 8(V0)
9D077764  8C48000C   LW T0, 12(V0)
9D077768  8C470010   LW A3, 16(V0)
9D07776C  8C430014   LW V1, 20(V0)
9D077770  94420018   LHU V0, 24(V0)
9D077780  AFAB0010   SW T3, 16(SP)
9D077784  AFAA0014   SW T2, 20(SP)
9D077788  AFA90018   SW T1, 24(SP)
9D07778C  AFA8001C   SW T0, 28(SP)
9D077790  AFA70020   SW A3, 32(SP)
9D077794  AFA30024   SW V1, 36(SP)
111:                 		eaDogM_WriteStringAtPos(9, 0, buffer);
9D077774  24040009   ADDIU A0, ZERO, 9
9D077778  00002821   ADDU A1, ZERO, ZERO
9D07777C  27A60010   ADDIU A2, SP, 16
9D077798  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D07779C  A7A20028   SH V0, 40(SP)
112:                 		OledUpdate();
9D0777A0  0F41E23E   JAL OledUpdate
9D0777A4  00000000   NOP
113:                 	};
114:                 	//while (i2c_busy(eeBus, 0b1010000));
115:                 	char biasBuf[7] = {'g', 0, 0, 0, 0, 0, 0};
9D077714  240A0067   ADDIU T2, ZERO, 103
9D077718  A3AA00B0   SB T2, 176(SP)
116:                 
117:                 	for (k = 0; k < 3; k++) {
118:                 		biasBuf[k * 2 + 1] = (__gBiasRaw[k] >> 8) & 0xFF;
9D0776F0  8E2601B4   LW A2, 436(S1)
9D0776F4  8E030004   LW V1, 4(S0)
9D0776F8  8E020008   LW V0, 8(S0)
9D0776FC  00064A03   SRA T1, A2, 8
9D077700  00034203   SRA T0, V1, 8
9D077704  00023A03   SRA A3, V0, 8
9D07771C  A3A900B1   SB T1, 177(SP)
9D077724  A3A800B3   SB T0, 179(SP)
9D07772C  A3A700B5   SB A3, 181(SP)
9D0777A8  0B41DDBD   J 0x9D0776F4
9D0777AC  8E2601B4   LW A2, 436(S1)
119:                 		biasBuf[k * 2 + 2] = __gBiasRaw[k] & 0xFF;
9D077720  A3A600B2   SB A2, 178(SP)
9D077728  A3A300B4   SB V1, 180(SP)
120:                 	}
121:                 
122:                 	set_nvram_str((void*) &pmyflash[21], biasBuf);
9D077708  8F848040   LW A0, -32704(GP)
9D07770C  24840054   ADDIU A0, A0, 84
9D077710  27A500B0   ADDIU A1, SP, 176
9D077730  0F41E257   JAL set_nvram_str
9D077734  A3A200B6   SB V0, 182(SP)
123:                 	//i2c_out(eeBus, 0b1010000, 63301, 2, biasBuf, 7); 
124:                 	//while (i2c_busy(eeBus, 0b1010000)); 
125:                 
126:                 	__autoCalc = 0b01;
9D077738  24020001   ADDIU V0, ZERO, 1
9D07773C  A382805C   SB V0, -32676(GP)
127:                 }
9D077740  8FBF00C4   LW RA, 196(SP)
9D077744  8FB100C0   LW S1, 192(SP)
9D077748  8FB000BC   LW S0, 188(SP)
9D07774C  03E00008   JR RA
9D077750  27BD00C8   ADDIU SP, SP, 200
9D077754  24628B08   ADDIU V0, V1, -29944
9D077758  8C6B8B08   LW T3, -29944(V1)
9D07775C  8C4A0004   LW T2, 4(V0)
9D077760  8C490008   LW T1, 8(V0)
9D077764  8C48000C   LW T0, 12(V0)
9D077768  8C470010   LW A3, 16(V0)
9D07776C  8C430014   LW V1, 20(V0)
9D077770  94420018   LHU V0, 24(V0)
9D077774  24040009   ADDIU A0, ZERO, 9
9D077778  00002821   ADDU A1, ZERO, ZERO
9D07777C  27A60010   ADDIU A2, SP, 16
9D077780  AFAB0010   SW T3, 16(SP)
9D077784  AFAA0014   SW T2, 20(SP)
9D077788  AFA90018   SW T1, 24(SP)
9D07778C  AFA8001C   SW T0, 28(SP)
9D077790  AFA70020   SW A3, 32(SP)
9D077794  AFA30024   SW V1, 36(SP)
9D077798  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D07779C  A7A20028   SH V0, 40(SP)
9D0777A0  0F41E23E   JAL OledUpdate
9D0777A4  00000000   NOP
9D0777A8  0B41DDBD   J 0x9D0776F4
9D0777AC  8E2601B4   LW A2, 436(S1)
128:                 
129:                 
130:                 
131:                 /*
132:                  * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
133:                  */
134:                 
135:                 /**
136:                  * TERMS OF USE: MIT License
137:                  *
138:                  * Permission is hereby granted, free of charge, to any person obtaining a
139:                  * copy of this software and associated documentation files (the "Software"),
140:                  * to deal in the Software without restriction, including without limitation
141:                  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
142:                  * and/or sell copies of the Software, and to permit persons to whom the
143:                  * Software is furnished to do so, subject to the following conditions:
144:                  *
145:                  * The above copyright notice and this permission notice shall be included in
146:                  * all copies or substantial portions of the Software.
147:                  *
148:                  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
149:                  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
150:                  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
151:                  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
152:                  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
153:                  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
154:                  * DEALINGS IN THE SOFTWARE.
155:                  */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_setAccelScale.c
1:                   /**
2:                    * @file LSM9DS1_setAccelScale.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  int __pinAG;
21:                  
22:                  unsigned char __settings_accel_scale;
23:                  float __aRes;
24:                  
25:                  
26:                  void imu_setAccelScale(unsigned char aScl)
27:                  {
9D0766A0  27BDFFE0   ADDIU SP, SP, -32
9D0766A4  AFBF001C   SW RA, 28(SP)
28:                    if ((aScl != 2) && (aScl != 4) && (aScl != 8) && (aScl != 16))  aScl = 2;
9D0766A8  24030002   ADDIU V1, ZERO, 2
9D0766AC  10830008   BEQ A0, V1, .LVL1
9D0766B0  00801021   ADDU V0, A0, ZERO
9D0766B4  24030004   ADDIU V1, ZERO, 4
9D0766B8  10830018   BEQ A0, V1, .LVL4
9D0766BC  24030008   ADDIU V1, ZERO, 8
9D0766C0  10830029   BEQ A0, V1, .LVL7
9D0766C4  24030010   ADDIU V1, ZERO, 16
9D0766C8  1083003A   BEQ A0, V1, .LVL10
9D0766CC  93848094   LBU A0, -32620(GP)
29:                  
30:                    __aRes = 32768.0 / ((float) aScl);
9D0766E0  3C029D08   LUI V0, -25336
9D0766E4  C44091A4   LWC1 F0, -28252(V0)
9D0766E8  E78080A0   SWC1 F0, -32608(GP)
9D07672C  3C039D08   LUI V1, -25336
9D076730  C4609198   LWC1 F0, -28264(V1)
9D076734  E78080A0   SWC1 F0, -32608(GP)
9D076778  3C039D08   LUI V1, -25336
9D07677C  C460919C   LWC1 F0, -28260(V1)
9D076780  E78080A0   SWC1 F0, -32608(GP)
9D0767C0  3C039D08   LUI V1, -25336
9D0767C4  C46091A0   LWC1 F0, -28256(V1)
9D0767C8  E78080A0   SWC1 F0, -32608(GP)
31:                    __settings_accel_scale = aScl;
9D0766EC  24020002   ADDIU V0, ZERO, 2
32:                  
33:                    // We need to preserve the other bytes in CTRL_REG6_XL. So, first read it:
34:                    unsigned char tempRegValue;
35:                    imu_SPIreadBytes(__pinAG, CTRL_REG6_XL, &tempRegValue, 1);
9D0766D0  93848094   LBU A0, -32620(GP)
9D0766D4  24050020   ADDIU A1, ZERO, 32
9D0766D8  27A60010   ADDIU A2, SP, 16
9D0766DC  24070001   ADDIU A3, ZERO, 1
9D0766F0  0F41DAF0   JAL imu_SPIreadBytes
9D0766F4  A382809C   SB V0, -32612(GP)
9D07671C  93848094   LBU A0, -32620(GP)
9D076720  24050020   ADDIU A1, ZERO, 32
9D076724  27A60010   ADDIU A2, SP, 16
9D076728  24070001   ADDIU A3, ZERO, 1
9D076738  0F41DAF0   JAL imu_SPIreadBytes
9D07673C  A382809C   SB V0, -32612(GP)
9D076768  93848094   LBU A0, -32620(GP)
9D07676C  24050020   ADDIU A1, ZERO, 32
9D076770  27A60010   ADDIU A2, SP, 16
9D076774  24070001   ADDIU A3, ZERO, 1
9D076784  0F41DAF0   JAL imu_SPIreadBytes
9D076788  A382809C   SB V0, -32612(GP)
9D0767B4  24050020   ADDIU A1, ZERO, 32
9D0767B8  27A60010   ADDIU A2, SP, 16
9D0767BC  24070001   ADDIU A3, ZERO, 1
9D0767CC  0F41DAF0   JAL imu_SPIreadBytes
9D0767D0  A382809C   SB V0, -32612(GP)
36:                    // Mask out accel scale bits:
37:                    tempRegValue &= 0xE7;
9D0766F8  93A60010   LBU A2, 16(SP)
9D0766FC  30C600E7   ANDI A2, A2, 231
9D076700  A3A60010   SB A2, 16(SP)
9D076740  93A60010   LBU A2, 16(SP)
9D07678C  93A60010   LBU A2, 16(SP)
9D0767D4  93A60010   LBU A2, 16(SP)
38:                    
39:                    switch (aScl)
40:                    {
41:                      case 4:
42:                        tempRegValue |= (0x2 << 3);
9D076744  30C600E7   ANDI A2, A2, 231
9D076748  34C60010   ORI A2, A2, 16
9D07674C  A3A60010   SB A2, 16(SP)
43:                        break;
44:                      case 8:
45:                        tempRegValue |= (0x3 << 3);
9D076790  34C60018   ORI A2, A2, 24
9D076794  30C600FF   ANDI A2, A2, 255
9D076798  A3A60010   SB A2, 16(SP)
46:                        break;
47:                      case 16:
48:                        tempRegValue |= (0x1 << 3);
9D0767D8  30C600E7   ANDI A2, A2, 231
9D0767DC  34C60008   ORI A2, A2, 8
9D0767E0  A3A60010   SB A2, 16(SP)
49:                        break;
50:                      default:
51:                        break;
52:                    }
53:                    
54:                    imu_SPIwriteByte(__pinAG, CTRL_REG6_XL, tempRegValue);
9D076704  93848094   LBU A0, -32620(GP)
9D076708  0F41DF40   JAL imu_SPIwriteByte
9D07670C  24050020   ADDIU A1, ZERO, 32
9D076750  93848094   LBU A0, -32620(GP)
9D076754  0F41DF40   JAL imu_SPIwriteByte
9D076758  24050020   ADDIU A1, ZERO, 32
9D07679C  93848094   LBU A0, -32620(GP)
9D0767A0  0F41DF40   JAL imu_SPIwriteByte
9D0767A4  24050020   ADDIU A1, ZERO, 32
9D0767E4  93848094   LBU A0, -32620(GP)
9D0767E8  0F41DF40   JAL imu_SPIwriteByte
9D0767EC  24050020   ADDIU A1, ZERO, 32
55:                  }
9D076710  8FBF001C   LW RA, 28(SP)
9D076714  03E00008   JR RA
9D076718  27BD0020   ADDIU SP, SP, 32
9D07675C  8FBF001C   LW RA, 28(SP)
9D076760  03E00008   JR RA
9D076764  27BD0020   ADDIU SP, SP, 32
9D0767A8  8FBF001C   LW RA, 28(SP)
9D0767AC  03E00008   JR RA
9D0767B0  27BD0020   ADDIU SP, SP, 32
9D0767F0  8FBF001C   LW RA, 28(SP)
9D0767F4  03E00008   JR RA
9D0767F8  27BD0020   ADDIU SP, SP, 32
56:                  
57:                  
58:                  /*
59:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
60:                   */
61:                  
62:                  /**
63:                   * TERMS OF USE: MIT License
64:                   *
65:                   * Permission is hereby granted, free of charge, to any person obtaining a
66:                   * copy of this software and associated documentation files (the "Software"),
67:                   * to deal in the Software without restriction, including without limitation
68:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
69:                   * and/or sell copies of the Software, and to permit persons to whom the
70:                   * Software is furnished to do so, subject to the following conditions:
71:                   *
72:                   * The above copyright notice and this permission notice shall be included in
73:                   * all copies or substantial portions of the Software.
74:                   *
75:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
76:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
77:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
78:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
79:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
80:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
81:                   * DEALINGS IN THE SOFTWARE.
82:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_readTemp.c
1:                   /**
2:                    * @file LSM9DS1_readTemp.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  int __pinAG;
20:                  
21:                  void imu_readTemp(int *temperature)
22:                  {
00000000  00000000   NOP
0000000C  00000000   NOP
23:                    unsigned char temp[2]; // We'll read two bytes from the temperature sensor into temp  
24:                    short tempT;
25:                  
26:                    imu_SPIreadBytes(__pinAG, OUT_TEMP_L, temp, 2); // Read 2 bytes, beginning at OUT_TEMP_L
00000010  00000000   NOP
27:                    tempT = (temp[1] << 8) | temp[0];
00000024  00000000   NOP
28:                  
29:                    *temperature = (int) tempT;
00000034  00000000   NOP
30:                  }
0000003C  00000000   NOP
31:                  
32:                  void imu_readTempCalculated(float *temperature, char tempUnit)
33:                  {
00000000  00000000   NOP
00000010  00000000   NOP
34:                    int tempTemp;
35:                    imu_readTemp(&tempTemp);
00000014  00000000   NOP
36:                    if(tempUnit == FAHRENHEIT)  *temperature = (((float) tempTemp / 16) + 25.0) * 1.8 + 32.0;
00000020  00000000   NOP
00000078  00000000   NOP
37:                    else                        *temperature = ((float) tempTemp / 16) + 25.0;
0000002C  00000000   NOP
38:                    if(tempUnit == KELVIN)      *temperature += 273.15;
00000040  00000000   NOP
39:                  }  
00000064  00000000   NOP
000000B4  00000000   NOP
40:                  
41:                  
42:                  /*
43:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
44:                   */
45:                  
46:                  /**
47:                   * TERMS OF USE: MIT License
48:                   *
49:                   * Permission is hereby granted, free of charge, to any person obtaining a
50:                   * copy of this software and associated documentation files (the "Software"),
51:                   * to deal in the Software without restriction, including without limitation
52:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
53:                   * and/or sell copies of the Software, and to permit persons to whom the
54:                   * Software is furnished to do so, subject to the following conditions:
55:                   *
56:                   * The above copyright notice and this permission notice shall be included in
57:                   * all copies or substantial portions of the Software.
58:                   *
59:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
60:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
61:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
62:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
63:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
64:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
65:                   * DEALINGS IN THE SOFTWARE.
66:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_readMag.c
1:                   /**
2:                    * @file LSM9DS1_readMag.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  int __pinM;
21:                  float __mRes;
22:                  
23:                  
24:                  void imu_readMag(int *mx, int *my, int *mz)
25:                  {
9D0781C4  27BDFFD8   ADDIU SP, SP, -40
9D0781C8  AFBF0024   SW RA, 36(SP)
9D0781CC  AFB20020   SW S2, 32(SP)
9D0781D0  AFB1001C   SW S1, 28(SP)
9D0781D4  AFB00018   SW S0, 24(SP)
9D0781D8  00809021   ADDU S2, A0, ZERO
9D0781E0  00A08821   ADDU S1, A1, ZERO
9D0781E4  00C08021   ADDU S0, A2, ZERO
26:                    unsigned char temp[6]; // We'll read six bytes from the mag into temp  
27:                    short tempX, tempY, tempZ;
28:                    
29:                    imu_SPIreadBytes(__pinM, OUT_X_L_M, temp, 6); // Read 6 bytes, beginning at OUT_X_L_M
9D0781DC  93848098   LBU A0, -32616(GP)
9D0781E8  24050028   ADDIU A1, ZERO, 40
9D0781EC  27A60010   ADDIU A2, SP, 16
9D0781F0  0F41DAF0   JAL imu_SPIreadBytes
9D0781F4  24070006   ADDIU A3, ZERO, 6
30:                    tempX = (temp[1] << 8) | temp[0]; // Store x-axis values into gx
9D078200  93A40011   LBU A0, 17(SP)
9D07820C  93A50010   LBU A1, 16(SP)
9D078218  00042200   SLL A0, A0, 8
9D078224  00852025   OR A0, A0, A1
31:                    tempY = (temp[3] << 8) | temp[2]; // Store y-axis values into gy
9D0781F8  93A30013   LBU V1, 19(SP)
9D078204  93A70012   LBU A3, 18(SP)
9D078210  00031A00   SLL V1, V1, 8
9D07821C  00671825   OR V1, V1, A3
9D078228  7C031E20   SEH V1, V1
32:                    tempZ = (temp[5] << 8) | temp[4]; // Store z-axis values into gz
9D0781FC  93A20015   LBU V0, 21(SP)
9D078208  93A60014   LBU A2, 20(SP)
9D078214  00021200   SLL V0, V0, 8
9D078220  00461025   OR V0, V0, A2
9D07822C  7C021620   SEH V0, V0
33:                    
34:                    *mx = (int) tempX;
9D078230  7C042620   SEH A0, A0
9D078234  AE440000   SW A0, 0(S2)
35:                    *my = (int) tempY;
9D078238  AE230000   SW V1, 0(S1)
36:                    *mz = (int) tempZ;
9D07823C  AE020000   SW V0, 0(S0)
37:                  }
9D078240  8FBF0024   LW RA, 36(SP)
9D078244  8FB20020   LW S2, 32(SP)
9D078248  8FB1001C   LW S1, 28(SP)
9D07824C  8FB00018   LW S0, 24(SP)
9D078250  03E00008   JR RA
9D078254  27BD0028   ADDIU SP, SP, 40
38:                  
39:                  
40:                  void imu_readMagCalculated(float *mx, float *my, float *mz)
41:                  {
00000000  00000000   NOP
00000014  00000000   NOP
42:                    // Return the mag raw reading times our pre-calculated Gs / (ADC tick):
43:                    int tempX, tempY, tempZ;
44:                  
45:                    imu_readMag(&tempX, &tempY, &tempZ);
00000020  00000000   NOP
46:                  
47:                    *mx = ((float) tempX) / __mRes;
00000030  00000000   NOP
00000050  00000000   NOP
48:                    *my = ((float) tempY) / __mRes;
00000040  00000000   NOP
00000054  00000000   NOP
49:                    *mz = ((float) tempZ) / __mRes;
00000048  00000000   NOP
00000060  00000000   NOP
50:                  }
0000006C  00000000   NOP
51:                  
52:                  
53:                  /*
54:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
55:                   */
56:                  
57:                  /**
58:                   * TERMS OF USE: MIT License
59:                   *
60:                   * Permission is hereby granted, free of charge, to any person obtaining a
61:                   * copy of this software and associated documentation files (the "Software"),
62:                   * to deal in the Software without restriction, including without limitation
63:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
64:                   * and/or sell copies of the Software, and to permit persons to whom the
65:                   * Software is furnished to do so, subject to the following conditions:
66:                   *
67:                   * The above copyright notice and this permission notice shall be included in
68:                   * all copies or substantial portions of the Software.
69:                   *
70:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
71:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
72:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
73:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
74:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
75:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
76:                   * DEALINGS IN THE SOFTWARE.
77:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_readGyro.c
1:                   /**
2:                    * @file LSM9DS1_readGyro.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  int __pinAG;
20:                  
21:                  float __gRes;
22:                  int __gBiasRaw[3];
23:                  char __autoCalc;
24:                  
25:                  
26:                  void imu_readGyro(int *gx, int *gy, int *gz)
27:                  {
9D077C28  27BDFFD8   ADDIU SP, SP, -40
9D077C2C  AFBF0024   SW RA, 36(SP)
9D077C30  AFB20020   SW S2, 32(SP)
9D077C34  AFB1001C   SW S1, 28(SP)
9D077C38  AFB00018   SW S0, 24(SP)
9D077C3C  00809021   ADDU S2, A0, ZERO
9D077C44  00A08821   ADDU S1, A1, ZERO
9D077C48  00C08021   ADDU S0, A2, ZERO
28:                    unsigned char temp[6]; // We'll read six bytes from the gyro into temp
29:                    short tempX, tempY, tempZ;
30:                    
31:                    imu_SPIreadBytes(__pinAG, OUT_X_L_G, temp, 6); // Read 6 bytes, beginning at OUT_X_L_G
9D077C40  93848094   LBU A0, -32620(GP)
9D077C4C  24050018   ADDIU A1, ZERO, 24
9D077C50  27A60010   ADDIU A2, SP, 16
9D077C54  0F41DAF0   JAL imu_SPIreadBytes
9D077C58  24070006   ADDIU A3, ZERO, 6
32:                    tempX = (temp[1] << 8) | temp[0]; // Store x-axis values into gx
9D077C64  93A40011   LBU A0, 17(SP)
9D077C70  93A50010   LBU A1, 16(SP)
9D077C7C  00042200   SLL A0, A0, 8
9D077C88  00852025   OR A0, A0, A1
33:                    tempY = (temp[3] << 8) | temp[2]; // Store y-axis values into gy
9D077C5C  93A30013   LBU V1, 19(SP)
9D077C68  93A70012   LBU A3, 18(SP)
9D077C74  00031A00   SLL V1, V1, 8
9D077C80  00671825   OR V1, V1, A3
9D077C8C  7C031E20   SEH V1, V1
34:                    tempZ = (temp[5] << 8) | temp[4]; // Store z-axis values into gz
9D077C60  93A20015   LBU V0, 21(SP)
9D077C6C  93A60014   LBU A2, 20(SP)
9D077C78  00021200   SLL V0, V0, 8
9D077C84  00461025   OR V0, V0, A2
9D077C90  7C021620   SEH V0, V0
35:                    
36:                    *gx = (int) tempX;
9D077C94  7C042620   SEH A0, A0
9D077C98  AE440000   SW A0, 0(S2)
37:                    *gy = (int) tempY;
9D077C9C  AE230000   SW V1, 0(S1)
38:                    *gz = (int) tempZ;
9D077CA0  AE020000   SW V0, 0(S0)
39:                    
40:                    if (__autoCalc & 0b01)
9D077CA4  9382805C   LBU V0, -32676(GP)
9D077CA8  30420001   ANDI V0, V0, 1
9D077CAC  1040000E   BEQ V0, ZERO, 0x9D077CE8
9D077CB0  3C028000   LUI V0, -32768
41:                    {
42:                      *gx -= __gBiasRaw[X_AXIS];
9D077CB4  8E440000   LW A0, 0(S2)
9D077CB8  8C4301B4   LW V1, 436(V0)
9D077CC0  00831823   SUBU V1, A0, V1
9D077CC4  AE430000   SW V1, 0(S2)
43:                      *gy -= __gBiasRaw[Y_AXIS];
9D077CBC  244201B4   ADDIU V0, V0, 436
9D077CC8  8E240000   LW A0, 0(S1)
9D077CCC  8C430004   LW V1, 4(V0)
9D077CD0  00831823   SUBU V1, A0, V1
9D077CD4  AE230000   SW V1, 0(S1)
44:                      *gz -= __gBiasRaw[Z_AXIS];
9D077CD8  8E030000   LW V1, 0(S0)
9D077CDC  8C420008   LW V0, 8(V0)
9D077CE0  00621023   SUBU V0, V1, V0
9D077CE4  AE020000   SW V0, 0(S0)
45:                    }
46:                  }
9D077CE8  8FBF0024   LW RA, 36(SP)
9D077CEC  8FB20020   LW S2, 32(SP)
9D077CF0  8FB1001C   LW S1, 28(SP)
9D077CF4  8FB00018   LW S0, 24(SP)
9D077CF8  03E00008   JR RA
9D077CFC  27BD0028   ADDIU SP, SP, 40
47:                  
48:                  void imu_readGyroCalculated(float *gx, float *gy, float *gz)
49:                  {
00000000  00000000   NOP
00000014  00000000   NOP
50:                    // Return the gyro raw reading times our pre-calculated DPS / (ADC tick):
51:                    int tempX, tempY, tempZ;
52:                  
53:                    imu_readGyro(&tempX, &tempY, &tempZ);
00000020  00000000   NOP
54:                  
55:                    *gx = ((float) tempX) / __gRes;
00000030  00000000   NOP
00000050  00000000   NOP
56:                    *gy = ((float) tempY) / __gRes;
00000040  00000000   NOP
00000054  00000000   NOP
57:                    *gz = ((float) tempZ) / __gRes;
00000048  00000000   NOP
00000060  00000000   NOP
58:                  }
0000006C  00000000   NOP
59:                  
60:                  
61:                  
62:                  /*
63:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
64:                   */
65:                  
66:                  /**
67:                   * TERMS OF USE: MIT License
68:                   *
69:                   * Permission is hereby granted, free of charge, to any person obtaining a
70:                   * copy of this software and associated documentation files (the "Software"),
71:                   * to deal in the Software without restriction, including without limitation
72:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
73:                   * and/or sell copies of the Software, and to permit persons to whom the
74:                   * Software is furnished to do so, subject to the following conditions:
75:                   *
76:                   * The above copyright notice and this permission notice shall be included in
77:                   * all copies or substantial portions of the Software.
78:                   *
79:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
80:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
81:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
82:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
83:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
84:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
85:                   * DEALINGS IN THE SOFTWARE.
86:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_readAccel.c
1:                   /**
2:                    * @file LSM9DS1_readAccel.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  int __pinAG;
21:                  
22:                  float __aRes;
23:                  int __aBiasRaw[3];
24:                  char __autoCalc;
25:                  
26:                  
27:                  void imu_readAccel(int *ax, int *ay, int *az)
28:                  {
9D077B50  27BDFFD8   ADDIU SP, SP, -40
9D077B54  AFBF0024   SW RA, 36(SP)
9D077B58  AFB20020   SW S2, 32(SP)
9D077B5C  AFB1001C   SW S1, 28(SP)
9D077B60  AFB00018   SW S0, 24(SP)
9D077B64  00809021   ADDU S2, A0, ZERO
9D077B6C  00A08821   ADDU S1, A1, ZERO
9D077B70  00C08021   ADDU S0, A2, ZERO
29:                    unsigned char temp[6]; // We'll read six bytes from the accelerometer into temp  
30:                    short tempX, tempY, tempZ;
31:                    
32:                    imu_SPIreadBytes(__pinAG, OUT_X_L_XL, temp, 6); // Read 6 bytes, beginning at OUT_X_L_XL
9D077B68  93848094   LBU A0, -32620(GP)
9D077B74  24050028   ADDIU A1, ZERO, 40
9D077B78  27A60010   ADDIU A2, SP, 16
9D077B7C  0F41DAF0   JAL imu_SPIreadBytes
9D077B80  24070006   ADDIU A3, ZERO, 6
33:                    tempX = (temp[1] << 8) | temp[0]; // Store x-axis values into ax
9D077B8C  93A40011   LBU A0, 17(SP)
9D077B98  93A50010   LBU A1, 16(SP)
9D077BA4  00042200   SLL A0, A0, 8
9D077BB0  00852025   OR A0, A0, A1
34:                    tempY = (temp[3] << 8) | temp[2]; // Store y-axis values into ay
9D077B84  93A30013   LBU V1, 19(SP)
9D077B90  93A70012   LBU A3, 18(SP)
9D077B9C  00031A00   SLL V1, V1, 8
9D077BA8  00671825   OR V1, V1, A3
9D077BB4  7C031E20   SEH V1, V1
35:                    tempZ = (temp[5] << 8) | temp[4]; // Store z-axis values into az
9D077B88  93A20015   LBU V0, 21(SP)
9D077B94  93A60014   LBU A2, 20(SP)
9D077BA0  00021200   SLL V0, V0, 8
9D077BAC  00461025   OR V0, V0, A2
9D077BB8  7C021620   SEH V0, V0
36:                    
37:                    *ax = (int) tempX;
9D077BBC  7C042620   SEH A0, A0
9D077BC0  AE440000   SW A0, 0(S2)
38:                    *ay = (int) tempY;
9D077BC4  AE230000   SW V1, 0(S1)
39:                    *az = (int) tempZ;
9D077BC8  AE020000   SW V0, 0(S0)
40:                  
41:                    if (__autoCalc & 0b10)
9D077BCC  9382805C   LBU V0, -32676(GP)
9D077BD0  30420002   ANDI V0, V0, 2
9D077BD4  1040000E   BEQ V0, ZERO, 0x9D077C10
9D077BD8  3C028000   LUI V0, -32768
42:                    {
43:                      *ax -= __aBiasRaw[X_AXIS];
9D077BDC  8E440000   LW A0, 0(S2)
9D077BE0  8C4301CC   LW V1, 460(V0)
9D077BE8  00831823   SUBU V1, A0, V1
9D077BEC  AE430000   SW V1, 0(S2)
44:                      *ay -= __aBiasRaw[Y_AXIS];
9D077BE4  244201CC   ADDIU V0, V0, 460
9D077BF0  8E240000   LW A0, 0(S1)
9D077BF4  8C430004   LW V1, 4(V0)
9D077BF8  00831823   SUBU V1, A0, V1
9D077BFC  AE230000   SW V1, 0(S1)
45:                      *az -= __aBiasRaw[Z_AXIS];
9D077C00  8E030000   LW V1, 0(S0)
9D077C04  8C420008   LW V0, 8(V0)
9D077C08  00621023   SUBU V0, V1, V0
9D077C0C  AE020000   SW V0, 0(S0)
46:                    }
47:                  }
9D077C10  8FBF0024   LW RA, 36(SP)
9D077C14  8FB20020   LW S2, 32(SP)
9D077C18  8FB1001C   LW S1, 28(SP)
9D077C1C  8FB00018   LW S0, 24(SP)
9D077C20  03E00008   JR RA
9D077C24  27BD0028   ADDIU SP, SP, 40
48:                  
49:                  void imu_readAccelCalculated(float *ax, float *ay, float *az)
50:                  {
00000000  00000000   NOP
00000014  00000000   NOP
51:                    // Return the accel raw reading times our pre-calculated g's / (ADC tick):
52:                    int tempX, tempY, tempZ;
53:                  
54:                    imu_readAccel(&tempX, &tempY, &tempZ);
00000020  00000000   NOP
55:                  
56:                    *ax = ((float) tempX) / __aRes;
00000030  00000000   NOP
00000050  00000000   NOP
57:                    *ay = ((float) tempY) / __aRes;
00000040  00000000   NOP
00000054  00000000   NOP
58:                    *az = ((float) tempZ) / __aRes;
00000048  00000000   NOP
00000060  00000000   NOP
59:                  }
0000006C  00000000   NOP
60:                  
61:                  
62:                  /*
63:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
64:                   */
65:                  
66:                  /**
67:                   * TERMS OF USE: MIT License
68:                   *
69:                   * Permission is hereby granted, free of charge, to any person obtaining a
70:                   * copy of this software and associated documentation files (the "Software"),
71:                   * to deal in the Software without restriction, including without limitation
72:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
73:                   * and/or sell copies of the Software, and to permit persons to whom the
74:                   * Software is furnished to do so, subject to the following conditions:
75:                   *
76:                   * The above copyright notice and this permission notice shall be included in
77:                   * all copies or substantial portions of the Software.
78:                   *
79:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
80:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
81:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
82:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
83:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
84:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
85:                   * DEALINGS IN THE SOFTWARE.
86:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_magAvailable.c
1:                   /**
2:                    * @file LSM9DS1_magAvailable.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  int __pinM;
21:                  
22:                  
23:                  unsigned char imu_magAvailable()
24:                  {
9D078F58  27BDFFE0   ADDIU SP, SP, -32
9D078F5C  AFBF001C   SW RA, 28(SP)
25:                    unsigned char status;
26:                    imu_SPIreadBytes(__pinM, STATUS_REG_M, &status, 1);
9D078F60  93848098   LBU A0, -32616(GP)
9D078F64  24050027   ADDIU A1, ZERO, 39
9D078F68  27A60010   ADDIU A2, SP, 16
9D078F6C  0F41DAF0   JAL imu_SPIreadBytes
9D078F70  24070001   ADDIU A3, ZERO, 1
27:                    return ((status & (1 << 3)) >> 3);
9D078F74  93A20010   LBU V0, 16(SP)
28:                  }
9D078F78  7C4200C0   EXT V0, V0, 3, 1
9D078F7C  8FBF001C   LW RA, 28(SP)
9D078F80  03E00008   JR RA
9D078F84  27BD0020   ADDIU SP, SP, 32
29:                  
30:                  
31:                  
32:                  /*
33:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
34:                   */
35:                  
36:                  /**
37:                   * TERMS OF USE: MIT License
38:                   *
39:                   * Permission is hereby granted, free of charge, to any person obtaining a
40:                   * copy of this software and associated documentation files (the "Software"),
41:                   * to deal in the Software without restriction, including without limitation
42:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
43:                   * and/or sell copies of the Software, and to permit persons to whom the
44:                   * Software is furnished to do so, subject to the following conditions:
45:                   *
46:                   * The above copyright notice and this permission notice shall be included in
47:                   * all copies or substantial portions of the Software.
48:                   *
49:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
50:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
51:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
52:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
53:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
54:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
55:                   * DEALINGS IN THE SOFTWARE.
56:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_init.c
1:                   /**
2:                    * @file imu_init.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  #include "definitions.h"                // SYS function prototypes
17:                  #include "../../Utility/libsimpletools/simpletools.h"
18:                  #include "lsm9ds1.h"
19:                  #include "imu.h"
20:                  #include "../../eadog.h"
21:                  
22:                  //i2c *eeBus;                                   // I2C bus ID
23:                  
24:                  int __pinAG, __pinM, __pinSDIO, __pinSCL;
25:                  char __autoCalc = 0;
26:                  
27:                  int imu_init(int pinSCL, int pinSDIO, int pinAG, int pinM)
28:                  {
9D073DD4  27BDFF20   ADDIU SP, SP, -224
9D073DD8  AFBF00DC   SW RA, 220(SP)
9D073DE4  00C04021   ADDU T0, A2, ZERO
29:                  	char buffer[STR_BUF_SIZE];
30:                  
31:                  	__pinAG = pinAG;
9D073E08  AF888094   SW T0, -32620(GP)
32:                  	__pinM = pinM;
9D073E04  AF878098   SW A3, -32616(GP)
33:                  	__pinSDIO = pinSDIO;
9D073DE8  AF858090   SW A1, -32624(GP)
34:                  	__pinSCL = pinSCL;
9D073DEC  AF84808C   SW A0, -32628(GP)
35:                  
36:                  	// Set both the Accel/Gyro and Mag to 3-wire SPI mode
37:                  	/*
38:                  	 * We don't use SPI bit-banging for 3-wire because it's possible to setup a hardware 3-wire mode on the PIC32 module
39:                  	 * on the pic32mk hardware SPI module jumper mosi to miso for half-duplex 3-wire mode and config for SPI MODE 3
40:                  	 * set the TRIS mode on the SPI TX port pin for input so we can turn-off the transmitter voltage during SPI receive 
41:                  	 * on the bidirectional SPI line
42:                  	 * 
43:                  	 * SPIxCON: SPI CONTROL REGISTER
44:                  	 * bit 12 DISSDO: Disable SDOx pin bit(4)
45:                  	 * 1 = SDOx pin is not used by the module. Pin is controlled by associated PORT register
46:                  	 * 0 = SDOx pin is controlled by the module
47:                  	 */
48:                  	TRISCbits.TRISC7 = 1; // SPI2 TX port set to port control as a input so we don't affect received data when in port mode
9D073DDC  3C02BF86   LUI V0, -16506
9D073DE0  94430210   LHU V1, 528(V0)
9D073DF0  24040001   ADDIU A0, ZERO, 1
9D073DF4  7C8339C4   INS V1, A0, 7, 1
9D073E0C  A4430210   SH V1, 528(V0)
49:                  	imu_SPIwriteByte(__pinAG, CTRL_REG8, 0b00001100);
9D073DF8  30C400FF   ANDI A0, A2, 255
9D073DFC  24050022   ADDIU A1, ZERO, 34
9D073E00  2406000C   ADDIU A2, ZERO, 12
9D073E10  0F41DF40   JAL imu_SPIwriteByte
9D073E14  00000000   NOP
50:                  	imu_SPIwriteByte(__pinM, CTRL_REG3_M, 0b10000100);
9D073E18  93848098   LBU A0, -32616(GP)
9D073E1C  24050022   ADDIU A1, ZERO, 34
9D073E20  0F41DF40   JAL imu_SPIwriteByte
9D073E24  24060084   ADDIU A2, ZERO, 132
51:                  
52:                  	// To verify communication, we can read from the WHO_AM_I register of
53:                  	// each device. Store those in a variable so we can return them.
54:                  	char xgTest = 0, mTest = 0;
9D073E38  A3A000D1   SB ZERO, 209(SP)
55:                  	imu_SPIreadBytes(__pinM, WHO_AM_I_M, (unsigned char *) &mTest, 1); // Read the gyro WHO_AM_I
9D073E28  93848098   LBU A0, -32616(GP)
9D073E2C  2405000F   ADDIU A1, ZERO, 15
9D073E30  27A600D0   ADDIU A2, SP, 208
9D073E34  24070001   ADDIU A3, ZERO, 1
9D073E3C  0F41DAF0   JAL imu_SPIreadBytes
9D073E40  A3A000D0   SB ZERO, 208(SP)
56:                  	imu_SPIreadBytes(__pinAG, WHO_AM_I_XG, (unsigned char *) &xgTest, 1); // Read the accel/mag WHO_AM_I
9D073E44  93848094   LBU A0, -32620(GP)
9D073E48  2405000F   ADDIU A1, ZERO, 15
9D073E4C  27A600D1   ADDIU A2, SP, 209
9D073E50  0F41DAF0   JAL imu_SPIreadBytes
9D073E54  24070001   ADDIU A3, ZERO, 1
57:                  	int whoAmICombined = (xgTest << 8) | mTest;
9D073E58  83A400D1   LB A0, 209(SP)
9D073E5C  83A200D0   LB V0, 208(SP)
9D073E60  00042200   SLL A0, A0, 8
9D073E64  00822025   OR A0, A0, V0
58:                  
59:                  	if (whoAmICombined != ((WHO_AM_I_AG_RSP << 8) | WHO_AM_I_M_RSP)) return 0;
9D073E68  2403683D   ADDIU V1, ZERO, 26685
9D073E6C  10830004   BEQ A0, V1, .LVL9
9D073E70  00001021   ADDU V0, ZERO, ZERO
60:                  
61:                  	//Init Gyro
62:                  	imu_SPIwriteByte(__pinAG, CTRL_REG1_G, 0xC0);
9D073E80  93848094   LBU A0, -32620(GP)
9D073E84  24050010   ADDIU A1, ZERO, 16
9D073E88  0F41DF40   JAL imu_SPIwriteByte
9D073E8C  240600C0   ADDIU A2, ZERO, 192
63:                  	imu_SPIwriteByte(__pinAG, CTRL_REG2_G, 0x00);
9D073E90  93848094   LBU A0, -32620(GP)
9D073E94  24050011   ADDIU A1, ZERO, 17
9D073E98  0F41DF40   JAL imu_SPIwriteByte
9D073E9C  00003021   ADDU A2, ZERO, ZERO
64:                  	imu_SPIwriteByte(__pinAG, CTRL_REG3_G, 0x00);
9D073EA0  93848094   LBU A0, -32620(GP)
9D073EA4  24050012   ADDIU A1, ZERO, 18
9D073EA8  0F41DF40   JAL imu_SPIwriteByte
9D073EAC  00003021   ADDU A2, ZERO, ZERO
65:                  	imu_SPIwriteByte(__pinAG, CTRL_REG4, 0x38);
9D073EB0  93848094   LBU A0, -32620(GP)
9D073EB4  2405001E   ADDIU A1, ZERO, 30
9D073EB8  0F41DF40   JAL imu_SPIwriteByte
9D073EBC  24060038   ADDIU A2, ZERO, 56
66:                  	imu_SPIwriteByte(__pinAG, ORIENT_CFG_G, 0x00);
9D073EC0  93848094   LBU A0, -32620(GP)
9D073EC4  24050013   ADDIU A1, ZERO, 19
9D073EC8  0F41DF40   JAL imu_SPIwriteByte
9D073ECC  00003021   ADDU A2, ZERO, ZERO
67:                  
68:                  	//Init Accel
69:                  	imu_SPIwriteByte(__pinAG, CTRL_REG5_XL, 0x38);
9D073ED0  93848094   LBU A0, -32620(GP)
9D073ED4  2405001F   ADDIU A1, ZERO, 31
9D073ED8  0F41DF40   JAL imu_SPIwriteByte
9D073EDC  24060038   ADDIU A2, ZERO, 56
70:                  	imu_SPIwriteByte(__pinAG, CTRL_REG6_XL, 0xC0);
9D073EE0  93848094   LBU A0, -32620(GP)
9D073EE4  24050020   ADDIU A1, ZERO, 32
9D073EE8  0F41DF40   JAL imu_SPIwriteByte
9D073EEC  240600C0   ADDIU A2, ZERO, 192
71:                  	imu_SPIwriteByte(__pinAG, CTRL_REG7_XL, 0x00);
9D073EF0  93848094   LBU A0, -32620(GP)
9D073EF4  24050021   ADDIU A1, ZERO, 33
9D073EF8  0F41DF40   JAL imu_SPIwriteByte
9D073EFC  00003021   ADDU A2, ZERO, ZERO
72:                  
73:                  	//Init Mag
74:                  	imu_SPIwriteByte(__pinM, CTRL_REG2_M, 0x00);
9D073F00  93848098   LBU A0, -32616(GP)
9D073F04  24050021   ADDIU A1, ZERO, 33
9D073F08  0F41DF40   JAL imu_SPIwriteByte
9D073F0C  00003021   ADDU A2, ZERO, ZERO
75:                  	imu_SPIwriteByte(__pinM, CTRL_REG4_M, 0x0C);
9D073F10  93848098   LBU A0, -32616(GP)
9D073F14  24050023   ADDIU A1, ZERO, 35
9D073F18  0F41DF40   JAL imu_SPIwriteByte
9D073F1C  2406000C   ADDIU A2, ZERO, 12
76:                  	imu_SPIwriteByte(__pinM, CTRL_REG5_M, 0x00);
9D073F20  93848098   LBU A0, -32616(GP)
9D073F24  00003021   ADDU A2, ZERO, ZERO
9D073F28  0F41DF40   JAL imu_SPIwriteByte
9D073F2C  24050024   ADDIU A1, ZERO, 36
77:                  
78:                  	//Set Scales
79:                  	imu_setGyroScale(500);
9D073F30  0F41DCEA   JAL imu_setGyroScale
9D073F34  240401F4   ADDIU A0, ZERO, 500
80:                  	imu_setAccelScale(8);
9D073F38  0F41D9A8   JAL imu_setAccelScale
9D073F3C  24040008   ADDIU A0, ZERO, 8
81:                  	imu_setMagScale(12);
9D073F40  0F41D899   JAL imu_setMagScale
9D073F44  2404000C   ADDIU A0, ZERO, 12
82:                  
83:                  	//Look for calibrations in EEPROM
84:                  	char biasStamp[8] = {0};
9D073F50  AFA000C8   SW ZERO, 200(SP)
9D073F54  AFA000CC   SW ZERO, 204(SP)
85:                  	char mBiasStored[8] = {0};
9D073F58  AFA000C0   SW ZERO, 192(SP)
9D073F5C  AFA000C4   SW ZERO, 196(SP)
86:                  	char aBiasStored[8] = {0};
9D073F60  AFA000B8   SW ZERO, 184(SP)
9D073F64  AFA000BC   SW ZERO, 188(SP)
87:                  	char gBiasStored[8] = {0};
9D073F68  AFA000B0   SW ZERO, 176(SP)
88:                  	//  i2c_in(eeBus, 0b1010000, 63280, 2, biasStamp, 7);
89:                  	get_nvram_str(0, biasStamp);
9D073F48  00002021   ADDU A0, ZERO, ZERO
9D073F4C  27A500C8   ADDIU A1, SP, 200
9D073F6C  0F41E394   JAL get_nvram_str
9D073F70  AFA000B4   SW ZERO, 180(SP)
90:                  	get_nvram_str(7, mBiasStored);
9D073F74  24040007   ADDIU A0, ZERO, 7
9D073F78  0F41E394   JAL get_nvram_str
9D073F7C  27A500C0   ADDIU A1, SP, 192
91:                  	get_nvram_str(14, aBiasStored);
9D073F80  2404000E   ADDIU A0, ZERO, 14
9D073F84  0F41E394   JAL get_nvram_str
9D073F88  27A500B8   ADDIU A1, SP, 184
92:                  	get_nvram_str(21, gBiasStored);
9D073F8C  27A500B0   ADDIU A1, SP, 176
9D073F90  0F41E394   JAL get_nvram_str
9D073F94  24040015   ADDIU A0, ZERO, 21
93:                  	//  i2c_in(eeBus, 0b1010000, 63287, 2, mBiasStored, 7);
94:                  	//  i2c_in(eeBus, 0b1010000, 63294, 2, aBiasStored, 7);
95:                  	//  i2c_in(eeBus, 0b1010000, 63301, 2, gBiasStored, 7);
96:                  
97:                  	if (strncmp(biasStamp, "LSM9DS1", 7) == 0) {
9D073F98  27A400C8   ADDIU A0, SP, 200
9D073F9C  3C059D08   LUI A1, -25336
9D073FA0  24A58E18   ADDIU A1, A1, -29160
9D073FA4  0F400064   JAL strncmp
9D073FA8  24060007   ADDIU A2, ZERO, 7
9D073FAC  14400044   BNE V0, ZERO, 0x9D0740C0
9D073FB0  27A40010   ADDIU A0, SP, 16
98:                  		sprintf(buffer, "LSM9DS1 header found");
9D073FB4  3C039D08   LUI V1, -25336
9D073FB8  24628E20   ADDIU V0, V1, -29152
9D073FBC  8C6A8E20   LW T2, -29152(V1)
9D073FC0  8C490004   LW T1, 4(V0)
9D073FC4  8C480008   LW T0, 8(V0)
9D073FC8  8C47000C   LW A3, 12(V0)
9D073FCC  8C430010   LW V1, 16(V0)
9D073FD0  90420014   LBU V0, 20(V0)
9D073FE0  AFAA0010   SW T2, 16(SP)
9D073FE4  AFA90014   SW T1, 20(SP)
9D073FE8  AFA80018   SW T0, 24(SP)
9D073FEC  AFA7001C   SW A3, 28(SP)
9D073FF0  AFA30020   SW V1, 32(SP)
99:                  		eaDogM_WriteStringAtPos(8, 0, buffer);
9D073FD4  24040008   ADDIU A0, ZERO, 8
9D073FD8  00002821   ADDU A1, ZERO, ZERO
9D073FDC  27A60010   ADDIU A2, SP, 16
9D073FF4  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D073FF8  A3A20024   SB V0, 36(SP)
100:                 		OledUpdate();
9D073FFC  0F41E23E   JAL OledUpdate
9D074000  00000000   NOP
101:                 		if ((mBiasStored[0] = 'm')) {
9D074034  2402006D   ADDIU V0, ZERO, 109
102:                 			int mxB = (mBiasStored[1] << 8) | mBiasStored[2];
9D074004  83A700C1   LB A3, 193(SP)
9D074010  83A400C2   LB A0, 194(SP)
9D07401C  00073A00   SLL A3, A3, 8
103:                 			int myB = (mBiasStored[3] << 8) | mBiasStored[4];
9D074008  83A500C3   LB A1, 195(SP)
9D074014  83A300C4   LB V1, 196(SP)
9D074020  00052A00   SLL A1, A1, 8
104:                 			int mzB = (mBiasStored[5] << 8) | mBiasStored[6];
9D07400C  83A600C5   LB A2, 197(SP)
9D074018  83A200C6   LB V0, 198(SP)
9D074024  00063200   SLL A2, A2, 8
105:                 
106:                 			imu_setMagCalibration(mxB, myB, mzB);
9D074028  00E42025   OR A0, A3, A0
9D07402C  00A32825   OR A1, A1, V1
9D074030  00C23025   OR A2, A2, V0
9D074038  0F41D836   JAL imu_setMagCalibration
9D07403C  A3A200C0   SB V0, 192(SP)
107:                 		}
108:                 
109:                 		if ((aBiasStored[0] = 'a')) {
9D074070  24020061   ADDIU V0, ZERO, 97
110:                 			int axB = (aBiasStored[1] << 8) | aBiasStored[2];
9D074040  83A700B9   LB A3, 185(SP)
9D07404C  83A400BA   LB A0, 186(SP)
9D074058  00073A00   SLL A3, A3, 8
111:                 			int ayB = (aBiasStored[3] << 8) | aBiasStored[4];
9D074044  83A500BB   LB A1, 187(SP)
9D074050  83A300BC   LB V1, 188(SP)
9D07405C  00052A00   SLL A1, A1, 8
112:                 			int azB = (aBiasStored[5] << 8) | aBiasStored[6];
9D074048  83A600BD   LB A2, 189(SP)
9D074054  83A200BE   LB V0, 190(SP)
9D074060  00063200   SLL A2, A2, 8
113:                 
114:                 			imu_setAccelCalibration(axB, ayB, azB);
9D074064  00E42025   OR A0, A3, A0
9D074068  00A32825   OR A1, A1, V1
9D07406C  00C23025   OR A2, A2, V0
9D074074  0F41DD2C   JAL imu_setAccelCalibration
9D074078  A3A200B8   SB V0, 184(SP)
115:                 		}
116:                 
117:                 		if ((gBiasStored[0] = 'g')) {
9D0740AC  24020067   ADDIU V0, ZERO, 103
118:                 			int gxB = (gBiasStored[1] << 8) | gBiasStored[2];
9D07407C  83A700B1   LB A3, 177(SP)
9D074088  83A400B2   LB A0, 178(SP)
9D074094  00073A00   SLL A3, A3, 8
119:                 			int gyB = (gBiasStored[3] << 8) | gBiasStored[4];
9D074080  83A500B3   LB A1, 179(SP)
9D07408C  83A300B4   LB V1, 180(SP)
9D074098  00052A00   SLL A1, A1, 8
120:                 			int gzB = (gBiasStored[5] << 8) | gBiasStored[6];
9D074084  83A600B5   LB A2, 181(SP)
9D074090  83A200B6   LB V0, 182(SP)
9D07409C  00063200   SLL A2, A2, 8
121:                 
122:                 			imu_setGyroCalibration(gxB, gyB, gzB);
9D0740A0  00E42025   OR A0, A3, A0
9D0740A4  00A32825   OR A1, A1, V1
9D0740A8  00C23025   OR A2, A2, V0
9D0740B0  0F41DDAE   JAL imu_setGyroCalibration
9D0740B4  A3A200B0   SB V0, 176(SP)
9D0740B8  0B41CF9D   J .LVL8
9D0740BC  2402683D   ADDIU V0, ZERO, 26685
123:                 		}
124:                 	} else {
125:                 		sprintf(buffer, "No LSM9DS1 header %s", biasStamp);
9D0740C0  3C059D08   LUI A1, -25336
9D0740C4  24A58E38   ADDIU A1, A1, -29128
9D0740C8  0F41E224   JAL _sprintf_cdfFnopsuxX
9D0740CC  27A600C8   ADDIU A2, SP, 200
126:                 		eaDogM_WriteStringAtPos(8, 0, buffer);
9D0740D0  24040008   ADDIU A0, ZERO, 8
9D0740D4  00002821   ADDU A1, ZERO, ZERO
9D0740D8  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D0740DC  27A60010   ADDIU A2, SP, 16
127:                 		OledUpdate();
9D0740E0  0F41E23E   JAL OledUpdate
9D0740E4  00000000   NOP
9D0740E8  0B41CF9D   J .LVL8
9D0740EC  2402683D   ADDIU V0, ZERO, 26685
128:                 	}
129:                 
130:                 
131:                 
132:                 	// Once everything is initialized, return the WHO_AM_I registers we read:
133:                 	return whoAmICombined;
134:                 }
9D073E74  8FBF00DC   LW RA, 220(SP)
9D073E78  03E00008   JR RA
9D073E7C  27BD00E0   ADDIU SP, SP, 224
9D073E80  93848094   LBU A0, -32620(GP)
9D073E84  24050010   ADDIU A1, ZERO, 16
9D073E88  0F41DF40   JAL imu_SPIwriteByte
9D073E8C  240600C0   ADDIU A2, ZERO, 192
9D073E90  93848094   LBU A0, -32620(GP)
9D073E94  24050011   ADDIU A1, ZERO, 17
9D073E98  0F41DF40   JAL imu_SPIwriteByte
9D073E9C  00003021   ADDU A2, ZERO, ZERO
9D073EA0  93848094   LBU A0, -32620(GP)
9D073EA4  24050012   ADDIU A1, ZERO, 18
9D073EA8  0F41DF40   JAL imu_SPIwriteByte
9D073EAC  00003021   ADDU A2, ZERO, ZERO
9D073EB0  93848094   LBU A0, -32620(GP)
9D073EB4  2405001E   ADDIU A1, ZERO, 30
9D073EB8  0F41DF40   JAL imu_SPIwriteByte
9D073EBC  24060038   ADDIU A2, ZERO, 56
9D073EC0  93848094   LBU A0, -32620(GP)
9D073EC4  24050013   ADDIU A1, ZERO, 19
9D073EC8  0F41DF40   JAL imu_SPIwriteByte
9D073ECC  00003021   ADDU A2, ZERO, ZERO
9D073ED0  93848094   LBU A0, -32620(GP)
9D073ED4  2405001F   ADDIU A1, ZERO, 31
9D073ED8  0F41DF40   JAL imu_SPIwriteByte
9D073EDC  24060038   ADDIU A2, ZERO, 56
9D073EE0  93848094   LBU A0, -32620(GP)
9D073EE4  24050020   ADDIU A1, ZERO, 32
9D073EE8  0F41DF40   JAL imu_SPIwriteByte
9D073EEC  240600C0   ADDIU A2, ZERO, 192
9D073EF0  93848094   LBU A0, -32620(GP)
9D073EF4  24050021   ADDIU A1, ZERO, 33
9D073EF8  0F41DF40   JAL imu_SPIwriteByte
9D073EFC  00003021   ADDU A2, ZERO, ZERO
9D073F00  93848098   LBU A0, -32616(GP)
9D073F04  24050021   ADDIU A1, ZERO, 33
9D073F08  0F41DF40   JAL imu_SPIwriteByte
9D073F0C  00003021   ADDU A2, ZERO, ZERO
9D073F10  93848098   LBU A0, -32616(GP)
9D073F14  24050023   ADDIU A1, ZERO, 35
9D073F18  0F41DF40   JAL imu_SPIwriteByte
9D073F1C  2406000C   ADDIU A2, ZERO, 12
9D073F20  93848098   LBU A0, -32616(GP)
9D073F24  00003021   ADDU A2, ZERO, ZERO
9D073F28  0F41DF40   JAL imu_SPIwriteByte
9D073F2C  24050024   ADDIU A1, ZERO, 36
9D073F30  0F41DCEA   JAL imu_setGyroScale
9D073F34  240401F4   ADDIU A0, ZERO, 500
9D073F38  0F41D9A8   JAL imu_setAccelScale
9D073F3C  24040008   ADDIU A0, ZERO, 8
9D073F40  0F41D899   JAL imu_setMagScale
9D073F44  2404000C   ADDIU A0, ZERO, 12
9D073F48  00002021   ADDU A0, ZERO, ZERO
9D073F4C  27A500C8   ADDIU A1, SP, 200
9D073F50  AFA000C8   SW ZERO, 200(SP)
9D073F54  AFA000CC   SW ZERO, 204(SP)
9D073F58  AFA000C0   SW ZERO, 192(SP)
9D073F5C  AFA000C4   SW ZERO, 196(SP)
9D073F60  AFA000B8   SW ZERO, 184(SP)
9D073F64  AFA000BC   SW ZERO, 188(SP)
9D073F68  AFA000B0   SW ZERO, 176(SP)
9D073F6C  0F41E394   JAL get_nvram_str
9D073F70  AFA000B4   SW ZERO, 180(SP)
9D073F74  24040007   ADDIU A0, ZERO, 7
9D073F78  0F41E394   JAL get_nvram_str
9D073F7C  27A500C0   ADDIU A1, SP, 192
9D073F80  2404000E   ADDIU A0, ZERO, 14
9D073F84  0F41E394   JAL get_nvram_str
9D073F88  27A500B8   ADDIU A1, SP, 184
9D073F8C  27A500B0   ADDIU A1, SP, 176
9D073F90  0F41E394   JAL get_nvram_str
9D073F94  24040015   ADDIU A0, ZERO, 21
9D073F98  27A400C8   ADDIU A0, SP, 200
9D073F9C  3C059D08   LUI A1, -25336
9D073FA0  24A58E18   ADDIU A1, A1, -29160
9D073FA4  0F400064   JAL strncmp
9D073FA8  24060007   ADDIU A2, ZERO, 7
9D073FAC  14400044   BNE V0, ZERO, 0x9D0740C0
9D073FB0  27A40010   ADDIU A0, SP, 16
9D073FB4  3C039D08   LUI V1, -25336
9D073FB8  24628E20   ADDIU V0, V1, -29152
9D073FBC  8C6A8E20   LW T2, -29152(V1)
9D073FC0  8C490004   LW T1, 4(V0)
9D073FC4  8C480008   LW T0, 8(V0)
9D073FC8  8C47000C   LW A3, 12(V0)
9D073FCC  8C430010   LW V1, 16(V0)
9D073FD0  90420014   LBU V0, 20(V0)
9D073FD4  24040008   ADDIU A0, ZERO, 8
9D073FD8  00002821   ADDU A1, ZERO, ZERO
9D073FDC  27A60010   ADDIU A2, SP, 16
9D073FE0  AFAA0010   SW T2, 16(SP)
9D073FE4  AFA90014   SW T1, 20(SP)
9D073FE8  AFA80018   SW T0, 24(SP)
9D073FEC  AFA7001C   SW A3, 28(SP)
9D073FF0  AFA30020   SW V1, 32(SP)
9D073FF4  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D073FF8  A3A20024   SB V0, 36(SP)
9D073FFC  0F41E23E   JAL OledUpdate
9D074000  00000000   NOP
9D074004  83A700C1   LB A3, 193(SP)
9D074008  83A500C3   LB A1, 195(SP)
9D07400C  83A600C5   LB A2, 197(SP)
9D074010  83A400C2   LB A0, 194(SP)
9D074014  83A300C4   LB V1, 196(SP)
9D074018  83A200C6   LB V0, 198(SP)
9D07401C  00073A00   SLL A3, A3, 8
9D074020  00052A00   SLL A1, A1, 8
9D074024  00063200   SLL A2, A2, 8
9D074028  00E42025   OR A0, A3, A0
9D07402C  00A32825   OR A1, A1, V1
9D074030  00C23025   OR A2, A2, V0
9D074034  2402006D   ADDIU V0, ZERO, 109
9D074038  0F41D836   JAL imu_setMagCalibration
9D07403C  A3A200C0   SB V0, 192(SP)
9D074040  83A700B9   LB A3, 185(SP)
9D074044  83A500BB   LB A1, 187(SP)
9D074048  83A600BD   LB A2, 189(SP)
9D07404C  83A400BA   LB A0, 186(SP)
9D074050  83A300BC   LB V1, 188(SP)
9D074054  83A200BE   LB V0, 190(SP)
9D074058  00073A00   SLL A3, A3, 8
9D07405C  00052A00   SLL A1, A1, 8
9D074060  00063200   SLL A2, A2, 8
9D074064  00E42025   OR A0, A3, A0
9D074068  00A32825   OR A1, A1, V1
9D07406C  00C23025   OR A2, A2, V0
9D074070  24020061   ADDIU V0, ZERO, 97
9D074074  0F41DD2C   JAL imu_setAccelCalibration
9D074078  A3A200B8   SB V0, 184(SP)
9D07407C  83A700B1   LB A3, 177(SP)
9D074080  83A500B3   LB A1, 179(SP)
9D074084  83A600B5   LB A2, 181(SP)
9D074088  83A400B2   LB A0, 178(SP)
9D07408C  83A300B4   LB V1, 180(SP)
9D074090  83A200B6   LB V0, 182(SP)
9D074094  00073A00   SLL A3, A3, 8
9D074098  00052A00   SLL A1, A1, 8
9D07409C  00063200   SLL A2, A2, 8
9D0740A0  00E42025   OR A0, A3, A0
9D0740A4  00A32825   OR A1, A1, V1
9D0740A8  00C23025   OR A2, A2, V0
9D0740AC  24020067   ADDIU V0, ZERO, 103
9D0740B0  0F41DDAE   JAL imu_setGyroCalibration
9D0740B4  A3A200B0   SB V0, 176(SP)
9D0740B8  0B41CF9D   J .LVL8
9D0740BC  2402683D   ADDIU V0, ZERO, 26685
9D0740C0  3C059D08   LUI A1, -25336
9D0740C4  24A58E38   ADDIU A1, A1, -29128
9D0740C8  0F41E224   JAL _sprintf_cdfFnopsuxX
9D0740CC  27A600C8   ADDIU A2, SP, 200
9D0740D0  24040008   ADDIU A0, ZERO, 8
9D0740D4  00002821   ADDU A1, ZERO, ZERO
9D0740D8  0F41E3B0   JAL eaDogM_WriteStringAtPos
9D0740DC  27A60010   ADDIU A2, SP, 16
9D0740E0  0F41E23E   JAL OledUpdate
9D0740E4  00000000   NOP
9D0740E8  0B41CF9D   J .LVL8
9D0740EC  2402683D   ADDIU V0, ZERO, 26685
135:                 
136:                 
137:                 /*
138:                  * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
139:                  */
140:                 
141:                 /**
142:                  * TERMS OF USE: MIT License
143:                  *
144:                  * Permission is hereby granted, free of charge, to any person obtaining a
145:                  * copy of this software and associated documentation files (the "Software"),
146:                  * to deal in the Software without restriction, including without limitation
147:                  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
148:                  * and/or sell copies of the Software, and to permit persons to whom the
149:                  * Software is furnished to do so, subject to the following conditions:
150:                  *
151:                  * The above copyright notice and this permission notice shall be included in
152:                  * all copies or substantial portions of the Software.
153:                  *
154:                  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
155:                  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
156:                  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
157:                  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
158:                  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
159:                  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
160:                  * DEALINGS IN THE SOFTWARE.
161:                  */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_gryoAvailable.c
1:                   /**
2:                    * @file LSM9DS1_gyroAvailable.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  int __pinAG;
21:                  
22:                  unsigned char imu_gyroAvailable()
23:                  {
9D078F88  27BDFFE0   ADDIU SP, SP, -32
9D078F8C  AFBF001C   SW RA, 28(SP)
24:                    unsigned char status;
25:                    imu_SPIreadBytes(__pinAG, STATUS_REG_1, &status, 1);
9D078F90  93848094   LBU A0, -32620(GP)
9D078F94  24050027   ADDIU A1, ZERO, 39
9D078F98  27A60010   ADDIU A2, SP, 16
9D078F9C  0F41DAF0   JAL imu_SPIreadBytes
9D078FA0  24070001   ADDIU A3, ZERO, 1
26:                    return ((status & (1<<1)) >> 1);
9D078FA4  93A20010   LBU V0, 16(SP)
27:                  }
9D078FA8  7C420040   EXT V0, V0, 1, 1
9D078FAC  8FBF001C   LW RA, 28(SP)
9D078FB0  03E00008   JR RA
9D078FB4  27BD0020   ADDIU SP, SP, 32
28:                  
29:                  
30:                  
31:                  
32:                  /*
33:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
34:                   */
35:                  
36:                  /**
37:                   * TERMS OF USE: MIT License
38:                   *
39:                   * Permission is hereby granted, free of charge, to any person obtaining a
40:                   * copy of this software and associated documentation files (the "Software"),
41:                   * to deal in the Software without restriction, including without limitation
42:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
43:                   * and/or sell copies of the Software, and to permit persons to whom the
44:                   * Software is furnished to do so, subject to the following conditions:
45:                   *
46:                   * The above copyright notice and this permission notice shall be included in
47:                   * all copies or substantial portions of the Software.
48:                   *
49:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
50:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
51:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
52:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
53:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
54:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
55:                   * DEALINGS IN THE SOFTWARE.
56:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_getScale.c
1:                   /**
2:                    * @file LSM9DS1_getScale.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  unsigned int  __settings_gyro_scale;
20:                  unsigned char __settings_accel_scale;
21:                  unsigned char __settings_mag_scale;
22:                  
23:                  
24:                  int imu_getGyroScale() 
25:                  {
26:                    return __settings_gyro_scale;
27:                  }
28:                    
29:                  int imu_getAccelScale() 
30:                  {
31:                    return __settings_accel_scale;
32:                  }
33:                    
34:                  int imu_getMagScale() 
35:                  {
36:                    return __settings_mag_scale;
37:                  }  
00000000  00000000   NOP
38:                  
39:                  
40:                  
41:                  
42:                  /*
43:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
44:                   */
45:                  
46:                  /**
47:                   * TERMS OF USE: MIT License
48:                   *
49:                   * Permission is hereby granted, free of charge, to any person obtaining a
50:                   * copy of this software and associated documentation files (the "Software"),
51:                   * to deal in the Software without restriction, including without limitation
52:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
53:                   * and/or sell copies of the Software, and to permit persons to whom the
54:                   * Software is furnished to do so, subject to the following conditions:
55:                   *
56:                   * The above copyright notice and this permission notice shall be included in
57:                   * all copies or substantial portions of the Software.
58:                   *
59:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
60:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
61:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
62:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
63:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
64:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
65:                   * DEALINGS IN THE SOFTWARE.
66:                   */
1:                   /**
2:                    * @file LSM9DS1_getCalibration.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  int __gBiasRaw[3];
20:                  int __aBiasRaw[3];
21:                  int __mBiasRaw[3];
22:                  
23:                  void imu_getMagCalibration(int *mxBias, int *myBias, int *mzBias)
24:                  {
25:                    *mxBias = __mBiasRaw[X_AXIS];
00000000  00000000   NOP
0000000C  00000000   NOP
26:                    *myBias = __mBiasRaw[Y_AXIS];
00000008  00000000   NOP
00000010  00000000   NOP
27:                    *mzBias = __mBiasRaw[Z_AXIS];
00000018  00000000   NOP
28:                  }  
29:                  
30:                  void imu_getAccelCalibration(int *axBias, int *ayBias, int *azBias)
31:                  {
32:                    *axBias = __aBiasRaw[X_AXIS];
00000000  00000000   NOP
0000000C  00000000   NOP
33:                    *ayBias = __aBiasRaw[Y_AXIS];
00000008  00000000   NOP
00000010  00000000   NOP
34:                    *azBias = __aBiasRaw[Z_AXIS];  
00000018  00000000   NOP
35:                  }  
36:                  
37:                  void imu_getGyroCalibration(int *gxBias, int *gyBias, int *gzBias)
38:                  {
39:                    *gxBias = __gBiasRaw[X_AXIS];
00000000  00000000   NOP
0000000C  00000000   NOP
40:                    *gyBias = __gBiasRaw[Y_AXIS];
00000008  00000000   NOP
00000010  00000000   NOP
41:                    *gzBias = __gBiasRaw[Z_AXIS];  
00000018  00000000   NOP
42:                  }
43:                  
44:                  
45:                  
46:                  /*
47:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
48:                   */
49:                  
50:                  /**
51:                   * TERMS OF USE: MIT License
52:                   *
53:                   * Permission is hereby granted, free of charge, to any person obtaining a
54:                   * copy of this software and associated documentation files (the "Software"),
55:                   * to deal in the Software without restriction, including without limitation
56:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
57:                   * and/or sell copies of the Software, and to permit persons to whom the
58:                   * Software is furnished to do so, subject to the following conditions:
59:                   *
60:                   * The above copyright notice and this permission notice shall be included in
61:                   * all copies or substantial portions of the Software.
62:                   *
63:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
64:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
65:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
66:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
67:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
68:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
69:                   * DEALINGS IN THE SOFTWARE.
70:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_calibrateMag.c
1:                   /**
2:                    * @file LSM9DS1_calibrateMag.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  #include "lsm9ds1.h"
18:                  
19:                  
20:                  void imu_calibrateMag()
21:                  {
00000000  00000000   NOP
22:                  
23:                    int i = 0, j, mx, my, mz;
24:                    int magMin[3] = {0, 0, 0};
00000010  00000000   NOP
25:                    int magMax[3] = {0, 0, 0};
0000001C  00000000   NOP
26:                    
27:                    while(i < 1200)  // ~40 samples/second = ~30 seconds
000000C0  00000000   NOP
28:                    {
29:                  
30:                      while (!imu_magAvailable());
00000030  00000000   NOP
31:                      imu_readMag(&mx, &my, &mz);
00000040  00000000   NOP
32:                      int magTemp[3] = {0, 0, 0};
33:                      magTemp[0] = mx;
0000004C  00000000   NOP
34:                      magTemp[1] = my;
00000054  00000000   NOP
35:                      magTemp[2] = mz;
0000005C  00000000   NOP
36:                      
37:                      for (j = 0; j < 3; j++)
00000098  00000000   NOP
38:                      {
39:                        if (magTemp[j] > magMax[j]) magMax[j] = magTemp[j];   // finds the smallest and largest values
00000070  00000000   NOP
000000A4  00000000   NOP
40:                        if (magTemp[j] < magMin[j]) magMin[j] = magTemp[j];
00000084  00000000   NOP
41:                      }
42:                      
43:                      i++;
44:                    }
45:                  
46:                    mx = (magMax[0] + magMin[0]) / 2;   // sets the Bias as the average of the high and low values
000000C8  00000000   NOP
000000E8  00000000   NOP
000000F4  00000000   NOP
00000100  00000000   NOP
00000118  00000000   NOP
47:                    my = (magMax[1] + magMin[1]) / 2;
000000D0  00000000   NOP
000000EC  00000000   NOP
000000F8  00000000   NOP
00000104  00000000   NOP
0000011C  00000000   NOP
48:                    mz = (magMax[2] + magMin[2]) / 2;
000000DC  00000000   NOP
000000F0  00000000   NOP
000000FC  00000000   NOP
00000108  00000000   NOP
49:                    
50:                    imu_setMagCalibration(mx, my, mz);
0000010C  00000000   NOP
00000120  00000000   NOP
51:                  }
00000128  00000000   NOP
52:                  
53:                  
54:                  
55:                  /*
56:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
57:                   */
58:                  
59:                  /**
60:                   * TERMS OF USE: MIT License
61:                   *
62:                   * Permission is hereby granted, free of charge, to any person obtaining a
63:                   * copy of this software and associated documentation files (the "Software"),
64:                   * to deal in the Software without restriction, including without limitation
65:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
66:                   * and/or sell copies of the Software, and to permit persons to whom the
67:                   * Software is furnished to do so, subject to the following conditions:
68:                   *
69:                   * The above copyright notice and this permission notice shall be included in
70:                   * all copies or substantial portions of the Software.
71:                   *
72:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
73:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
74:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
75:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
76:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
77:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
78:                   * DEALINGS IN THE SOFTWARE.
79:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_calibrateAG.c
1:                   /**
2:                    * @file LSM9DS1_calibrateAG.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  //#include <propeller.h>
18:                  #include "lsm9ds1.h"
19:                  
20:                  
21:                  int __pinAG;
22:                  float __gRes, __aRes;
23:                  char __autoCalc;
24:                  
25:                  
26:                  void imu_calibrateAG()
27:                  {  
9D0743F0  27BDFF90   ADDIU SP, SP, -112
9D0743F4  AFBF006C   SW RA, 108(SP)
9D0743F8  AFB70068   SW S7, 104(SP)
9D0743FC  AFB60064   SW S6, 100(SP)
9D074400  AFB50060   SW S5, 96(SP)
9D074404  AFB4005C   SW S4, 92(SP)
9D074408  AFB30058   SW S3, 88(SP)
9D07440C  AFB20054   SW S2, 84(SP)
9D074410  AFB10050   SW S1, 80(SP)
9D074414  AFB0004C   SW S0, 76(SP)
28:                  //  unsigned char data[6] = {0, 0, 0, 0, 0, 0};
29:                    unsigned char samples = 0;
30:                    int ii;
31:                    int ax, ay, az, gx, gy, gz;
32:                    int aBiasRawTemp[3]   = {0, 0, 0};
9D074428  AFA0001C   SW ZERO, 28(SP)
9D07442C  AFA00020   SW ZERO, 32(SP)
9D074430  AFA00024   SW ZERO, 36(SP)
33:                    int gBiasRawTemp[3]   = {0, 0, 0};
9D074434  AFA00010   SW ZERO, 16(SP)
9D074438  AFA00014   SW ZERO, 20(SP)
34:                    
35:                    // Turn on FIFO and set threshold to 32 samples
36:                    unsigned char tempF;
37:                    imu_SPIreadBytes(__pinAG, CTRL_REG9, &tempF, 1);
9D074418  93848094   LBU A0, -32620(GP)
9D07441C  24070001   ADDIU A3, ZERO, 1
9D074420  24050023   ADDIU A1, ZERO, 35
9D074424  27A60040   ADDIU A2, SP, 64
9D07443C  0F41DAF0   JAL imu_SPIreadBytes
9D074440  AFA00018   SW ZERO, 24(SP)
38:                    tempF |= (1<<1);
9D074444  93A20040   LBU V0, 64(SP)
9D074450  34420002   ORI V0, V0, 2
9D074454  304200FF   ANDI V0, V0, 255
39:                    imu_SPIwriteByte(__pinAG, CTRL_REG9, tempF);
9D074448  93848094   LBU A0, -32620(GP)
9D07444C  24050023   ADDIU A1, ZERO, 35
9D074458  00403021   ADDU A2, V0, ZERO
9D07445C  0F41DF40   JAL imu_SPIwriteByte
9D074460  A3A20040   SB V0, 64(SP)
40:                    imu_SPIwriteByte(__pinAG, FIFO_CTRL, (((FIFO_THS & 0x7) << 5) | 0x1F));
9D074464  93848094   LBU A0, -32620(GP)
9D074468  2405002E   ADDIU A1, ZERO, 46
9D07446C  0F41DF40   JAL imu_SPIwriteByte
9D074470  2406003F   ADDIU A2, ZERO, 63
41:                  
42:                    
43:                    while (samples < 0x1F)
9D074490  2E02001F   SLTIU V0, S0, 31
9D074494  1440FFF8   BNE V0, ZERO, 0x9D074478
9D074498  93848094   LBU A0, -32620(GP)
44:                    {
45:                      unsigned char tempS;
46:                      imu_SPIreadBytes(__pinAG, FIFO_SRC, &tempS, 1);       // Read number of stored samples
9D074474  93848094   LBU A0, -32620(GP)
9D074478  2405002F   ADDIU A1, ZERO, 47
9D07447C  27A60028   ADDIU A2, SP, 40
9D074480  0F41DAF0   JAL imu_SPIreadBytes
9D074484  24070001   ADDIU A3, ZERO, 1
47:                      samples = tempS & 0x3F;
9D074488  93B00028   LBU S0, 40(SP)
9D07448C  3210003F   ANDI S0, S0, 63
48:                    }
49:                  
50:                    for(ii = 0; ii < samples ; ii++) 
9D07449C  0000B821   ADDU S7, ZERO, ZERO
9D0744A0  0000B021   ADDU S6, ZERO, ZERO
9D0744A4  00009021   ADDU S2, ZERO, ZERO
9D0744A8  0000A021   ADDU S4, ZERO, ZERO
9D0744AC  00009821   ADDU S3, ZERO, ZERO
9D0744B0  00008821   ADDU S1, ZERO, ZERO
9D0744B4  0000A821   ADDU S5, ZERO, ZERO
9D074510  26B50001   ADDIU S5, S5, 1
9D074528  02B0102A   SLT V0, S5, S0
9D074534  1440FFE0   BNE V0, ZERO, .LVL7
9D074538  AFB70024   SW S7, 36(SP)
9D07453C  27A3001C   ADDIU V1, SP, 28
9D074540  27A20010   ADDIU V0, SP, 16
9D074544  00602021   ADDU A0, V1, ZERO
51:                    { 
52:                      // Read the gyro data stored in the FIFO
53:                      imu_readGyro(&gx, &gy, &gz);
9D0744B8  27A40030   ADDIU A0, SP, 48
9D0744BC  27A5002C   ADDIU A1, SP, 44
9D0744C0  0F41DF0A   JAL imu_readGyro
9D0744C4  27A60028   ADDIU A2, SP, 40
54:                      gBiasRawTemp[0] += gx;
9D0744C8  8FA20030   LW V0, 48(SP)
9D0744CC  02228821   ADDU S1, S1, V0
9D0744EC  AFB10010   SW S1, 16(SP)
55:                      gBiasRawTemp[1] += gy;
9D0744D0  8FA2002C   LW V0, 44(SP)
9D0744D4  02629821   ADDU S3, S3, V0
9D0744F0  AFB30014   SW S3, 20(SP)
56:                      gBiasRawTemp[2] += gz;
9D0744D8  8FA20028   LW V0, 40(SP)
9D0744DC  0282A021   ADDU S4, S4, V0
57:                      imu_readAccel(&ax, &ay, &az);
9D0744E0  27A4003C   ADDIU A0, SP, 60
9D0744E4  27A50038   ADDIU A1, SP, 56
9D0744E8  27A60034   ADDIU A2, SP, 52
9D0744F4  0F41DED4   JAL imu_readAccel
9D0744F8  AFB40018   SW S4, 24(SP)
58:                      aBiasRawTemp[0] += ax;
9D074514  8FA3003C   LW V1, 60(SP)
9D074518  02439021   ADDU S2, S2, V1
9D07452C  AFB2001C   SW S2, 28(SP)
59:                      aBiasRawTemp[1] += ay;
9D07451C  8FA30038   LW V1, 56(SP)
9D074520  02C3B021   ADDU S6, S6, V1
9D074530  AFB60020   SW S6, 32(SP)
60:                      aBiasRawTemp[2] += az - ((int) __aRes);    // Assumes sensor facing up!
9D0744FC  C78080A0   LWC1 F0, -32608(GP)
9D074500  4600000D   TRUNC.W.S F0, F0
9D074504  44020000   MFC1 V0, F0
9D074508  8FA30034   LW V1, 52(SP)
9D07450C  00621023   SUBU V0, V1, V0
9D074524  02E2B821   ADDU S7, S7, V0
61:                    }  
62:                  
63:                    for (ii = 0; ii < 3; ii++)
9D07456C  1044000E   BEQ V0, A0, 0x9D0745A8
9D074570  AC72FFFC   SW S2, -4(V1)
9D074574  8C510000   LW S1, 0(V0)
9D074578  8C720000   LW S2, 0(V1)
9D0745A0  1444FFF4   BNE V0, A0, 0x9D074574
9D0745A4  AC72FFFC   SW S2, -4(V1)
64:                    {
65:                      gBiasRawTemp[ii] = gBiasRawTemp[ii] / samples;
9D074548  0230001A   DIV S1, S0
9D07454C  020001F4   TEQ S0, ZERO
9D074550  00008812   MFLO S1
9D074554  24420004   ADDIU V0, V0, 4
9D074558  24630004   ADDIU V1, V1, 4
9D074568  AC51FFFC   SW S1, -4(V0)
9D07457C  0230001A   DIV S1, S0
9D074580  020001F4   TEQ S0, ZERO
9D074584  00008812   MFLO S1
9D074588  24420004   ADDIU V0, V0, 4
9D07458C  24630004   ADDIU V1, V1, 4
9D07459C  AC51FFFC   SW S1, -4(V0)
66:                      aBiasRawTemp[ii] = aBiasRawTemp[ii] / samples;
9D07455C  0250001A   DIV S2, S0
9D074560  020001F4   TEQ S0, ZERO
9D074564  00009012   MFLO S2
9D074590  0250001A   DIV S2, S0
9D074594  020001F4   TEQ S0, ZERO
9D074598  00009012   MFLO S2
67:                    }
68:                    
69:                    imu_setGyroCalibration(gBiasRawTemp[0], gBiasRawTemp[1], gBiasRawTemp[2]);
9D0745A8  8FA40010   LW A0, 16(SP)
9D0745AC  8FA50014   LW A1, 20(SP)
9D0745B0  0F41DDAE   JAL imu_setGyroCalibration
9D0745B4  8FA60018   LW A2, 24(SP)
70:                    imu_setAccelCalibration(aBiasRawTemp[0], aBiasRawTemp[1], aBiasRawTemp[2]);
9D0745B8  8FA4001C   LW A0, 28(SP)
9D0745BC  8FA50020   LW A1, 32(SP)
9D0745C0  0F41DD2C   JAL imu_setAccelCalibration
9D0745C4  8FA60024   LW A2, 36(SP)
71:                   
72:                    __autoCalc = 0b11; 
9D0745D8  24020003   ADDIU V0, ZERO, 3
73:                    
74:                    //Disable FIFO
75:                    imu_SPIreadBytes(__pinAG, CTRL_REG9, &tempF, 1);
9D0745C8  93848094   LBU A0, -32620(GP)
9D0745CC  24050023   ADDIU A1, ZERO, 35
9D0745D0  27A60040   ADDIU A2, SP, 64
9D0745D4  24070001   ADDIU A3, ZERO, 1
9D0745DC  0F41DAF0   JAL imu_SPIreadBytes
9D0745E0  A382805C   SB V0, -32676(GP)
76:                    tempF &= ~(1<<1);
9D0745E4  93A20040   LBU V0, 64(SP)
9D0745F0  304200FD   ANDI V0, V0, 253
77:                    imu_SPIwriteByte(__pinAG, CTRL_REG9, tempF);  
9D0745E8  93848094   LBU A0, -32620(GP)
9D0745EC  24050023   ADDIU A1, ZERO, 35
9D0745F4  00403021   ADDU A2, V0, ZERO
9D0745F8  0F41DF40   JAL imu_SPIwriteByte
9D0745FC  A3A20040   SB V0, 64(SP)
78:                    imu_SPIwriteByte(__pinAG, FIFO_CTRL, ((FIFO_OFF & 0x7) << 5));
9D074600  93848094   LBU A0, -32620(GP)
9D074604  2405002E   ADDIU A1, ZERO, 46
9D074608  0F41DF40   JAL imu_SPIwriteByte
9D07460C  00003021   ADDU A2, ZERO, ZERO
79:                  
80:                  }
9D074610  8FBF006C   LW RA, 108(SP)
9D074614  8FB70068   LW S7, 104(SP)
9D074618  8FB60064   LW S6, 100(SP)
9D07461C  8FB50060   LW S5, 96(SP)
9D074620  8FB4005C   LW S4, 92(SP)
9D074624  8FB30058   LW S3, 88(SP)
9D074628  8FB20054   LW S2, 84(SP)
9D07462C  8FB10050   LW S1, 80(SP)
9D074630  8FB0004C   LW S0, 76(SP)
9D074634  03E00008   JR RA
9D074638  27BD0070   ADDIU SP, SP, 112
81:                  
82:                  
83:                  
84:                  /*
85:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
86:                   */
87:                  
88:                  /**
89:                   * TERMS OF USE: MIT License
90:                   *
91:                   * Permission is hereby granted, free of charge, to any person obtaining a
92:                   * copy of this software and associated documentation files (the "Software"),
93:                   * to deal in the Software without restriction, including without limitation
94:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
95:                   * and/or sell copies of the Software, and to permit persons to whom the
96:                   * Software is furnished to do so, subject to the following conditions:
97:                   *
98:                   * The above copyright notice and this permission notice shall be included in
99:                   * all copies or substantial portions of the Software.
100:                  *
101:                  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
102:                  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
103:                  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
104:                  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
105:                  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
106:                  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
107:                  * DEALINGS IN THE SOFTWARE.
108:                  */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_accelAvailable.c
1:                   /**
2:                    * @file LSM9DS1_accelAvailable.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  #include "lsm9ds1.h"
17:                  
18:                  
19:                  int __pinAG;
20:                  
21:                  unsigned char imu_accelAvailable(void)
22:                  {
9D078F28  27BDFFE0   ADDIU SP, SP, -32
9D078F2C  AFBF001C   SW RA, 28(SP)
23:                    unsigned char status;
24:                    imu_SPIreadBytes(__pinAG, STATUS_REG_1, &status, 1);
9D078F30  93848094   LBU A0, -32620(GP)
9D078F34  24050027   ADDIU A1, ZERO, 39
9D078F38  27A60010   ADDIU A2, SP, 16
9D078F3C  0F41DAF0   JAL imu_SPIreadBytes
9D078F40  24070001   ADDIU A3, ZERO, 1
25:                    return (status & (1<<0));
9D078F44  93A20010   LBU V0, 16(SP)
26:                  }
9D078F48  30420001   ANDI V0, V0, 1
9D078F4C  8FBF001C   LW RA, 28(SP)
9D078F50  03E00008   JR RA
9D078F54  27BD0020   ADDIU SP, SP, 32
27:                  
28:                  
29:                  /*
30:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
31:                   */
32:                  
33:                  /**
34:                   * TERMS OF USE: MIT License
35:                   *
36:                   * Permission is hereby granted, free of charge, to any person obtaining a
37:                   * copy of this software and associated documentation files (the "Software"),
38:                   * to deal in the Software without restriction, including without limitation
39:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
40:                   * and/or sell copies of the Software, and to permit persons to whom the
41:                   * Software is furnished to do so, subject to the following conditions:
42:                   *
43:                   * The above copyright notice and this permission notice shall be included in
44:                   * all copies or substantial portions of the Software.
45:                   *
46:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
47:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
48:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
49:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
50:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
51:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
52:                   * DEALINGS IN THE SOFTWARE.
53:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_SPIwrite.c
1:                   /**
2:                    * @file LSM9DS1_SPIwrite.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  
17:                  //#include "simpletools.h"
18:                  #include "lsm9ds1.h"
19:                  #include "config/pic32mk_mcj_curiosity_pro/peripheral/gpio/plib_gpio.h"
20:                  #include "config/pic32mk_mcj_curiosity_pro/peripheral/spi/spi_master/plib_spi2_master.h"
21:                  
22:                  extern int __pinM, __pinSDIO, __pinSCL;
23:                  
24:                  /*
25:                   * PIC32: changed to use hardware SPI module and plib_gpio pin functions
26:                   */
27:                  void imu_SPIwriteByte(unsigned char csPin, unsigned char subAddress, unsigned char data)
28:                  {
9D077D00  27BDFFD8   ADDIU SP, SP, -40
9D077D04  AFBF0024   SW RA, 36(SP)
9D077D08  AFB10020   SW S1, 32(SP)
9D077D0C  AFB0001C   SW S0, 28(SP)
9D077D20  00808021   ADDU S0, A0, ZERO
9D077D24  A3A60030   SB A2, 48(SP)
29:                  	uint8_t tmp = subAddress & 0x3F;
9D077D18  30A5003F   ANDI A1, A1, 63
9D077D28  A3A50010   SB A1, 16(SP)
30:                  
31:                  	SPI2CONbits.DISSDO = 0; // half-duplex switching, SPI TX ON, PORT pin mode OFF
9D077D10  3C02BF82   LUI V0, -16510
9D077D14  8C437200   LW V1, 29184(V0)
9D077D1C  7C036304   INS V1, ZERO, 12, 1
9D077D2C  AC437200   SW V1, 29184(V0)
32:                  	if (csPin == __pinM)
9D077D30  8F828098   LW V0, -32616(GP)
9D077D34  10820013   BEQ A0, V0, .LVL7
9D077D38  3C11BF86   LUI S1, -16506
33:                  		csPin_m_Clear();
9D077D84  34028000   ORI V0, ZERO, -32768
9D077D88  AE220434   SW V0, 1076(S1)
34:                  	else
35:                  		csPin_ag_Clear();
9D077D3C  24020002   ADDIU V0, ZERO, 2
9D077D40  AE220434   SW V0, 1076(S1)
36:                  	
37:                  	SPI2_Write(&tmp, 1);
9D077D44  27A40010   ADDIU A0, SP, 16
9D077D48  0F41E46E   JAL SPI2_Write
9D077D4C  24050001   ADDIU A1, ZERO, 1
9D077D8C  27A40010   ADDIU A0, SP, 16
9D077D90  0F41E46E   JAL SPI2_Write
9D077D94  24050001   ADDIU A1, ZERO, 1
38:                  	SPI2_Write(&data, 1);
9D077D50  27A40030   ADDIU A0, SP, 48
9D077D54  0F41E46E   JAL SPI2_Write
9D077D58  24050001   ADDIU A1, ZERO, 1
9D077D98  27A40030   ADDIU A0, SP, 48
9D077D9C  0F41E46E   JAL SPI2_Write
9D077DA0  24050001   ADDIU A1, ZERO, 1
39:                  	if (csPin == __pinM) 
9D077D5C  8F828098   LW V0, -32616(GP)
9D077D60  12020014   BEQ S0, V0, 0x9D077DB4
9D077D64  34028000   ORI V0, ZERO, -32768
9D077DA4  8F828098   LW V0, -32616(GP)
9D077DA8  1602FFF0   BNE S0, V0, 0x9D077D6C
9D077DAC  24020002   ADDIU V0, ZERO, 2
40:                  		csPin_m_Set();
9D077DB0  34028000   ORI V0, ZERO, -32768
9D077DB4  AE220438   SW V0, 1080(S1)
41:                  	else
42:                  		csPin_ag_Set();
9D077D68  24020002   ADDIU V0, ZERO, 2
9D077D6C  AE220438   SW V0, 1080(S1)
43:                  	
44:                  }
9D077D70  8FBF0024   LW RA, 36(SP)
9D077D74  8FB10020   LW S1, 32(SP)
9D077D78  8FB0001C   LW S0, 28(SP)
9D077D7C  03E00008   JR RA
9D077D80  27BD0028   ADDIU SP, SP, 40
9D077DB8  8FBF0024   LW RA, 36(SP)
9D077DBC  8FB10020   LW S1, 32(SP)
9D077DC0  8FB0001C   LW S0, 28(SP)
9D077DC4  03E00008   JR RA
9D077DC8  27BD0028   ADDIU SP, SP, 40
45:                  
46:                  
47:                  /*
48:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
49:                   */
50:                  
51:                  /**
52:                   * TERMS OF USE: MIT License
53:                   *
54:                   * Permission is hereby granted, free of charge, to any person obtaining a
55:                   * copy of this software and associated documentation files (the "Software"),
56:                   * to deal in the Software without restriction, including without limitation
57:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
58:                   * and/or sell copies of the Software, and to permit persons to whom the
59:                   * Software is furnished to do so, subject to the following conditions:
60:                   *
61:                   * The above copyright notice and this permission notice shall be included in
62:                   * all copies or substantial portions of the Software.
63:                   *
64:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
65:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
66:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
67:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
68:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
69:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
70:                   * DEALINGS IN THE SOFTWARE.
71:                   */
---  /root/vcan/imu/pic32mk/Learn-Folder-Updated-2020.03.02/Learn/Simple Libraries/Sensor/liblsm9ds1/imu_SPIread.c
1:                   /**
2:                    * @file LSM9DS1_SPIread.c
3:                    *
4:                    * @author Matthew Matz
5:                    *
6:                    * @version 0.5
7:                    *
8:                    * @copyright
9:                    * Copyright (C) Parallax, Inc. 2016. All Rights MIT Licensed.
10:                   *
11:                   * @brief This Propeller C library was created for the Parallax 9-axis IMU Sensor, based
12:                   * on the STMicroelectronics LSM9DS1 inertial motion sensor chip.
13:                   */
14:                  
15:                  
16:                  //#include "simpletools.h"
17:                  #include "lsm9ds1.h"
18:                  #include "config/pic32mk_mcj_curiosity_pro/peripheral/gpio/plib_gpio.h"
19:                  #include "config/pic32mk_mcj_curiosity_pro/peripheral/spi/spi_master/plib_spi2_master.h"
20:                  
21:                  extern int __pinM, __pinSDIO, __pinSCL;
22:                  
23:                  /*
24:                   * PIC32: changed to use hardware SPI module and plib_gpio pin functions
25:                   * IMU SPI is half-duplex so we short pic32 SPI TX to RX signals and toggle TX pin state to PORT pin mode input during SPI receive
26:                   */
27:                  void imu_SPIreadBytes(unsigned char csPin, unsigned char subAddress, unsigned char *dest, unsigned char count)
28:                  {
9D076BC0  27BDFFC8   ADDIU SP, SP, -56
9D076BC4  AFBF0034   SW RA, 52(SP)
9D076BC8  AFB50030   SW S5, 48(SP)
9D076BCC  AFB4002C   SW S4, 44(SP)
9D076BD0  AFB30028   SW S3, 40(SP)
9D076BD4  AFB20024   SW S2, 36(SP)
9D076BD8  AFB10020   SW S1, 32(SP)
9D076BDC  AFB0001C   SW S0, 28(SP)
9D076BE8  0080A021   ADDU S4, A0, ZERO
9D076BEC  00C09021   ADDU S2, A2, ZERO
29:                  	int i;
30:                  
31:                  	// To indicate a read, set bit 0 (msb) of first byte to 1
32:                  	unsigned char rAddress = 0x80 | (subAddress & 0x3F);
9D076BE0  30A5003F   ANDI A1, A1, 63
9D076BE4  34A20080   ORI V0, A1, 128
9D076BF0  A3A20010   SB V0, 16(SP)
33:                  
34:                  	// Mag SPI port is different. If we're reading multiple bytes, 
35:                  	// set bit 1 to 1. The remaining six bytes are the address to be read
36:                  	if ((csPin == __pinM) && count > 1) rAddress |= 0x40;
9D076BF4  8F838098   LW V1, -32616(GP)
9D076BF8  10830026   BEQ A0, V1, .LVL10
9D076BFC  00E08821   ADDU S1, A3, ZERO
9D076C94  2CE30002   SLTIU V1, A3, 2
9D076C98  14600002   BNE V1, ZERO, 0x9D076CA4
9D076C9C  34420040   ORI V0, V0, 64
9D076CA0  A3A20010   SB V0, 16(SP)
37:                  
38:                  	SPI2CONbits.DISSDO = 0; // half-duplex switching, SPI TX ON
9D076C00  3C13BF82   LUI S3, -16510
9D076C04  8E627200   LW V0, 29184(S3)
9D076C0C  7C026304   INS V0, ZERO, 12, 1
9D076C10  AE627200   SW V0, 29184(S3)
9D076CA4  3C13BF82   LUI S3, -16510
9D076CA8  8E627200   LW V0, 29184(S3)
9D076CB0  7C026304   INS V0, ZERO, 12, 1
9D076CB4  AE627200   SW V0, 29184(S3)
39:                  	if (csPin == __pinM)
40:                  		csPin_m_Clear();
9D076CAC  3C15BF86   LUI S5, -16506
9D076CB8  34028000   ORI V0, ZERO, -32768
9D076CBC  AEA20434   SW V0, 1076(S5)
9D076CC0  0B41DB08   J .LVL2
9D076CC4  27A40010   ADDIU A0, SP, 16
41:                  	else
42:                  		csPin_ag_Clear();
9D076C08  3C15BF86   LUI S5, -16506
9D076C14  24020002   ADDIU V0, ZERO, 2
9D076C18  AEA20434   SW V0, 1076(S5)
43:                  
44:                  	SPI2_Write(&rAddress, 1);
9D076C1C  27A40010   ADDIU A0, SP, 16
9D076C20  0F41E46E   JAL SPI2_Write
9D076C24  24050001   ADDIU A1, ZERO, 1
45:                  	SPI2CONbits.DISSDO = 1;
9D076C28  8E627200   LW V0, 29184(S3)
9D076C30  24030001   ADDIU V1, ZERO, 1
9D076C34  7C626304   INS V0, V1, 12, 1
9D076C38  AE627200   SW V0, 29184(S3)
46:                  	for (i = 0; i < count; i++) {
9D076C2C  00008021   ADDU S0, ZERO, ZERO
9D076C3C  12200009   BEQ S1, ZERO, 0x9D076C64
9D076C40  8F828098   LW V0, -32616(GP)
9D076C54  0211102A   SLT V0, S0, S1
9D076C58  1440FFFB   BNE V0, ZERO, 0x9D076C48
9D076C5C  02502021   ADDU A0, S2, S0
47:                  		SPI2_Read(&dest[i], 1); // half-duplex switching, SPI TX OFF, PORT pin mode input
9D076C44  02502021   ADDU A0, S2, S0
9D076C48  24050001   ADDIU A1, ZERO, 1
9D076C4C  0F41E444   JAL SPI2_Read
9D076C50  26100001   ADDIU S0, S0, 1
48:                  	}
49:                  	if (csPin == __pinM)
9D076C60  8F828098   LW V0, -32616(GP)
9D076C64  12820018   BEQ S4, V0, .LVL11
9D076C68  24020002   ADDIU V0, ZERO, 2
50:                  		csPin_m_Set();
9D076CC8  34028000   ORI V0, ZERO, -32768
9D076CCC  AEA20438   SW V0, 1080(S5)
51:                  	else
52:                  		csPin_ag_Set();
9D076C6C  AEA20438   SW V0, 1080(S5)
53:                  
54:                  }
9D076C70  8FBF0034   LW RA, 52(SP)
9D076C74  8FB50030   LW S5, 48(SP)
9D076C78  8FB4002C   LW S4, 44(SP)
9D076C7C  8FB30028   LW S3, 40(SP)
9D076C80  8FB20024   LW S2, 36(SP)
9D076C84  8FB10020   LW S1, 32(SP)
9D076C88  8FB0001C   LW S0, 28(SP)
9D076C8C  03E00008   JR RA
9D076C90  27BD0038   ADDIU SP, SP, 56
9D076CD0  8FBF0034   LW RA, 52(SP)
9D076CD4  8FB50030   LW S5, 48(SP)
9D076CD8  8FB4002C   LW S4, 44(SP)
9D076CDC  8FB30028   LW S3, 40(SP)
9D076CE0  8FB20024   LW S2, 36(SP)
9D076CE4  8FB10020   LW S1, 32(SP)
9D076CE8  8FB0001C   LW S0, 28(SP)
9D076CEC  03E00008   JR RA
9D076CF0  27BD0038   ADDIU SP, SP, 56
55:                  
56:                  
57:                  /*
58:                   * Based on the Arduino Library for the LSM9SD1 by Jim Lindblom of Sparkfun Electronics
59:                   */
60:                  
61:                  /**
62:                   * TERMS OF USE: MIT License
63:                   *
64:                   * Permission is hereby granted, free of charge, to any person obtaining a
65:                   * copy of this software and associated documentation files (the "Software"),
66:                   * to deal in the Software without restriction, including without limitation
67:                   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
68:                   * and/or sell copies of the Software, and to permit persons to whom the
69:                   * Software is furnished to do so, subject to the following conditions:
70:                   *
71:                   * The above copyright notice and this permission notice shall be included in
72:                   * all copies or substantial portions of the Software.
73:                   *
74:                   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
75:                   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
76:                   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
77:                   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
78:                   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
79:                   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
80:                   * DEALINGS IN THE SOFTWARE.
81:                   */
---  /opt/microchip/xc32/v2.50/pic32mx/include/fdlmath.h  -----------------------------------------------
1:                   /*-------------------------------------------------------------------------
2:                    * MPLAB XC Compiler - fdlmath.h
3:                    *
4:                    * Copyright (c) 2015, Microchip Technology Inc. and its subsidiaries ("Microchip")
5:                    * All rights reserved.
6:                    *
7:                    * This software is developed by Microchip Technology Inc. and its
8:                    * subsidiaries ("Microchip").
9:                    *
10:                   * Redistribution and use in source and binary forms, with or without
11:                   * modification, are permitted provided that the following conditions are
12:                   * met:
13:                   *
14:                   * 1.      Redistributions of source code must retain the above copyright
15:                   *         notice, this list of conditions and the following disclaimer.
16:                   * 2.      Redistributions in binary form must reproduce the above
17:                   *         copyright notice, this list of conditions and the following
18:                   *         disclaimer in the documentation and/or other materials provided
19:                   *         with the distribution.
20:                   * 3.      Microchip's name may not be used to endorse or promote products
21:                   *         derived from this software without specific prior written
22:                   *         permission.
23:                   *
24:                   * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
25:                   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
26:                   * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED. IN NO EVENT
27:                   * SHALL MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
28:                   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
29:                   * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
30:                   * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
31:                   * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
32:                   * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
33:                   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
34:                   *
35:                   */
36:                  
37:                  #pragma once
38:                  
39:                  #ifndef __FDLMATH_H
40:                  #define __FDLMATH_H
41:                  
42:                  /* "f", "l", and "" (double) math.h function routing */
43:                  #if defined(__FDLMATH_SHORT_DOUBLE) || defined(SHORT_DOUBLE)
44:                  #define __FDLMATH_XDOUBLE long double
45:                  #else
46:                  #define __FDLMATH_XDOUBLE double
47:                  #endif
48:                  
49:                  extern __FDLMATH_XDOUBLE _acosx(__FDLMATH_XDOUBLE x);
50:                  extern __FDLMATH_XDOUBLE _asinx(__FDLMATH_XDOUBLE x);
51:                  extern __FDLMATH_XDOUBLE _atanx(__FDLMATH_XDOUBLE x);
52:                  extern __FDLMATH_XDOUBLE _atan2x(__FDLMATH_XDOUBLE y, __FDLMATH_XDOUBLE x);
53:                  extern __FDLMATH_XDOUBLE _ceilx(__FDLMATH_XDOUBLE x);
54:                  extern __FDLMATH_XDOUBLE _cosx(__FDLMATH_XDOUBLE x);
55:                  extern __FDLMATH_XDOUBLE _coshx(__FDLMATH_XDOUBLE x);
56:                  extern __FDLMATH_XDOUBLE _expx(__FDLMATH_XDOUBLE x);
57:                  extern __FDLMATH_XDOUBLE _fabsx(__FDLMATH_XDOUBLE x);
58:                  extern __FDLMATH_XDOUBLE _floorx(__FDLMATH_XDOUBLE x);
59:                  extern __FDLMATH_XDOUBLE _fmodx(__FDLMATH_XDOUBLE x, __FDLMATH_XDOUBLE y);
60:                  extern __FDLMATH_XDOUBLE _frexpx(__FDLMATH_XDOUBLE x, int *pexp);
61:                  extern __FDLMATH_XDOUBLE _ldexpx(__FDLMATH_XDOUBLE x, int exp);
62:                  extern __FDLMATH_XDOUBLE _logx(__FDLMATH_XDOUBLE x);
63:                  extern __FDLMATH_XDOUBLE _log10x(__FDLMATH_XDOUBLE x);
64:                  extern __FDLMATH_XDOUBLE _modfx(__FDLMATH_XDOUBLE y, __FDLMATH_XDOUBLE *pint);
65:                  extern __FDLMATH_XDOUBLE _powx(__FDLMATH_XDOUBLE x, __FDLMATH_XDOUBLE y);
66:                  extern __FDLMATH_XDOUBLE _sinx(__FDLMATH_XDOUBLE x);
67:                  extern __FDLMATH_XDOUBLE _sinhx(__FDLMATH_XDOUBLE x);
68:                  extern __FDLMATH_XDOUBLE _sqrtx(__FDLMATH_XDOUBLE x);
69:                  extern __FDLMATH_XDOUBLE _tanx(__FDLMATH_XDOUBLE x);
70:                  extern __FDLMATH_XDOUBLE _tanhx(__FDLMATH_XDOUBLE x);
71:                  
72:                  #define __FDLMATH_INLINE static inline __attribute__((always_inline))
73:                  
74:                  /* "f" SP routines are adaptors to "x" DP code */
75:                  __FDLMATH_INLINE float acosf(float x)
76:                  {
77:                      return (float)_acosx((__FDLMATH_XDOUBLE)x);
78:                  }
79:                  __FDLMATH_INLINE float asinf(float x)
80:                  {
81:                      return (float)_asinx((__FDLMATH_XDOUBLE)x);
000000A0  00000000   NOP
000000B8  00000000   NOP
82:                  }
83:                  __FDLMATH_INLINE float atanf(float x)
84:                  {
85:                      return (float)_atanx((__FDLMATH_XDOUBLE)x);
86:                  }
87:                  __FDLMATH_INLINE float atan2f(float y, float x)
88:                  {
89:                      return (float)_atan2x((__FDLMATH_XDOUBLE)y, (__FDLMATH_XDOUBLE)x);
00000074  00000000   NOP
000000D0  00000000   NOP
90:                  }
91:                  __FDLMATH_INLINE float ceilf(float x)
92:                  {
93:                      return (float)_ceilx((__FDLMATH_XDOUBLE)x);
94:                  }
95:                  __FDLMATH_INLINE float cosf(float x)
96:                  {
97:                      return (float)_cosx((__FDLMATH_XDOUBLE)x);
98:                  }
99:                  __FDLMATH_INLINE float coshf(float x)
100:                 {
101:                     return (float)_coshx((__FDLMATH_XDOUBLE)x);
102:                 }
103:                 __FDLMATH_INLINE float expf(float x)
104:                 {
105:                     return (float)_expx((__FDLMATH_XDOUBLE)x);
106:                 }
107:                 __FDLMATH_INLINE float fabsf(float x)
108:                 {
109:                     return (float)_fabsx((__FDLMATH_XDOUBLE)x);
110:                 }
111:                 __FDLMATH_INLINE float floorf(float x)
112:                 {
113:                     return (float)_floorx((__FDLMATH_XDOUBLE)x);
114:                 }
115:                 __FDLMATH_INLINE float fmodf(float x, float y)
116:                 {
117:                     return (float)_fmodx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
118:                 }
119:                 __FDLMATH_INLINE float frexpf(float x, int *pexp)
120:                 {
121:                     return (float)_frexpx((__FDLMATH_XDOUBLE)x, pexp);
122:                 }
123:                 __FDLMATH_INLINE float ldexpf(float x, int exp)
124:                 {
125:                     return (float)_ldexpx((__FDLMATH_XDOUBLE)x, exp);
126:                 }
127:                 __FDLMATH_INLINE float logf(float x)
128:                 {
129:                     return (float)_logx((__FDLMATH_XDOUBLE)x);
130:                 }
131:                 __FDLMATH_INLINE float log10f(float x)
132:                 {
133:                     return (float)_log10x((__FDLMATH_XDOUBLE)x);
134:                 }
135:                 __FDLMATH_INLINE float modff(float x, float *pint)
136:                 {
137:                     __FDLMATH_XDOUBLE dpint;
138:                     float r;
139:                 
140:                     r = (float)_modfx((__FDLMATH_XDOUBLE)x, &dpint);
141:                     *pint = (float)dpint;
142:                 
143:                     return r;
144:                 }
145:                 __FDLMATH_INLINE float powf(float x, float y)
146:                 {
147:                     return (float)_powx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
148:                 }
149:                 __FDLMATH_INLINE float sinf(float x)
150:                 {
151:                     return (float)_sinx((__FDLMATH_XDOUBLE)x);
152:                 }
153:                 __FDLMATH_INLINE float sinhf(float x)
154:                 {
155:                     return (float)_sinhx((__FDLMATH_XDOUBLE)x);
156:                 }
157:                 __FDLMATH_INLINE float sqrtf(float x)
158:                 {
159:                     return (float)_sqrtx((__FDLMATH_XDOUBLE)x);
160:                 }
161:                 __FDLMATH_INLINE float tanf(float x)
162:                 {
163:                     return (float)_tanx((__FDLMATH_XDOUBLE)x);
164:                 }
165:                 __FDLMATH_INLINE float tanhf(float x)
166:                 {
167:                     return (float)_tanhx((__FDLMATH_XDOUBLE)x);
168:                 }
169:                 
170:                 /* "l" DP routines are adaptors to "x" DP code */
171:                 __FDLMATH_INLINE long double acosl(long double x)
172:                 {
173:                     return (long double)_acosx((__FDLMATH_XDOUBLE)x);
174:                 }
175:                 __FDLMATH_INLINE long double asinl(long double x)
176:                 {
177:                     return (long double)_asinx((__FDLMATH_XDOUBLE)x);
178:                 }
179:                 __FDLMATH_INLINE long double atanl(long double x)
180:                 {
181:                     return (long double)_atanx((__FDLMATH_XDOUBLE)x);
182:                 }
183:                 __FDLMATH_INLINE long double atan2l(long double y, long double x)
184:                 {
185:                     return (long double)_atan2x((__FDLMATH_XDOUBLE)y, (__FDLMATH_XDOUBLE)x);
186:                 }
187:                 __FDLMATH_INLINE long double ceill(long double x)
188:                 {
189:                     return (long double)_ceilx((__FDLMATH_XDOUBLE)x);
190:                 }
191:                 __FDLMATH_INLINE long double cosl(long double x)
192:                 {
193:                     return (long double)_cosx((__FDLMATH_XDOUBLE)x);
194:                 }
195:                 __FDLMATH_INLINE long double coshl(long double x)
196:                 {
197:                     return (long double)_coshx((__FDLMATH_XDOUBLE)x);
198:                 }
199:                 __FDLMATH_INLINE long double expl(long double x)
200:                 {
201:                     return (long double)_expx((__FDLMATH_XDOUBLE)x);
202:                 }
203:                 __FDLMATH_INLINE long double fabsl(long double x)
204:                 {
205:                     return (long double)_fabsx((__FDLMATH_XDOUBLE)x);
206:                 }
207:                 __FDLMATH_INLINE long double floorl(long double x)
208:                 {
209:                     return (long double)_floorx((__FDLMATH_XDOUBLE)x);
210:                 }
211:                 __FDLMATH_INLINE long double fmodl(long double x, long double y)
212:                 {
213:                     return (long double)_fmodx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
214:                 }
215:                 __FDLMATH_INLINE long double frexpl(long double x, int *pexp)
216:                 {
217:                     return (long double)_frexpx((__FDLMATH_XDOUBLE)x, pexp);
218:                 }
219:                 __FDLMATH_INLINE long double ldexpl(long double x, int exp)
220:                 {
221:                     return (long double)_ldexpx((__FDLMATH_XDOUBLE)x, exp);
222:                 }
223:                 __FDLMATH_INLINE long double logl(long double x)
224:                 {
225:                     return (long double)_logx((__FDLMATH_XDOUBLE)x);
226:                 }
227:                 __FDLMATH_INLINE long double log10l(long double x)
228:                 {
229:                     return (long double)_log10x((__FDLMATH_XDOUBLE)x);
230:                 }
231:                 __FDLMATH_INLINE long double modfl(long double x, long double *pint)
232:                 {
233:                     __FDLMATH_XDOUBLE dpint;
234:                     long double r;
235:                 
236:                     r = (long double)_modfx((__FDLMATH_XDOUBLE)x, &dpint);
237:                     *pint = (long double)dpint;
238:                 
239:                     return r;
240:                 }
241:                 __FDLMATH_INLINE long double powl(long double x, long double y)
242:                 {
243:                     return (long double)_powx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
244:                 }
245:                 __FDLMATH_INLINE long double sinl(long double x)
246:                 {
247:                     return (long double)_sinx((__FDLMATH_XDOUBLE)x);
248:                 }
249:                 __FDLMATH_INLINE long double sinhl(long double x)
250:                 {
251:                     return (long double)_sinhx((__FDLMATH_XDOUBLE)x);
252:                 }
253:                 __FDLMATH_INLINE long double sqrtl(long double x)
254:                 {
255:                     return (long double)_sqrtx((__FDLMATH_XDOUBLE)x);
256:                 }
257:                 __FDLMATH_INLINE long double tanl(long double x)
258:                 {
259:                     return (long double)_tanx((__FDLMATH_XDOUBLE)x);
260:                 }
261:                 __FDLMATH_INLINE long double tanhl(long double x)
262:                 {
263:                     return (long double)_tanhx((__FDLMATH_XDOUBLE)x);
264:                 }
265:                 
266:                 /* "" double routines are adaptors to x DP code */
267:                 __FDLMATH_INLINE double acos(double x)
268:                 {
269:                     return (double)_acosx((__FDLMATH_XDOUBLE)x);
270:                 }
271:                 __FDLMATH_INLINE double asin(double x)
272:                 {
273:                     return (double)_asinx((__FDLMATH_XDOUBLE)x);
274:                 }
275:                 __FDLMATH_INLINE double atan(double x)
276:                 {
277:                     return (double)_atanx((__FDLMATH_XDOUBLE)x);
278:                 }
279:                 __FDLMATH_INLINE double atan2(double y, double x)
280:                 {
281:                     return (double)_atan2x((__FDLMATH_XDOUBLE)y, (__FDLMATH_XDOUBLE)x);
282:                 }
283:                 __FDLMATH_INLINE double ceil(double x)
284:                 {
285:                     return (double)_ceilx((__FDLMATH_XDOUBLE)x);
286:                 }
287:                 __FDLMATH_INLINE double cos(double x)
288:                 {
289:                     return (double)_cosx((__FDLMATH_XDOUBLE)x);
00000070  00000000   NOP
290:                 }
291:                 __FDLMATH_INLINE double cosh(double x)
292:                 {
293:                     return (double)_coshx((__FDLMATH_XDOUBLE)x);
294:                 }
295:                 __FDLMATH_INLINE double exp(double x)
296:                 {
297:                     return (double)_expx((__FDLMATH_XDOUBLE)x);
298:                 }
299:                 __FDLMATH_INLINE double fabs(double x)
300:                 {
301:                     return (double)_fabsx((__FDLMATH_XDOUBLE)x);
302:                 }
303:                 __FDLMATH_INLINE double floor(double x)
304:                 {
305:                     return (double)_floorx((__FDLMATH_XDOUBLE)x);
306:                 }
307:                 __FDLMATH_INLINE double fmod(double x, double y)
308:                 {
309:                     return (double)_fmodx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
0000000C  00000000   NOP
00000058  00000000   NOP
00000094  00000000   NOP
310:                 }
311:                 __FDLMATH_INLINE double frexp(double x, int *pexp)
312:                 {
313:                     return (double)_frexpx((__FDLMATH_XDOUBLE)x, pexp);
314:                 }
315:                 __FDLMATH_INLINE double ldexp(double x, int exp)
316:                 {
317:                     return (double)_ldexpx((__FDLMATH_XDOUBLE)x, exp);
318:                 }
319:                 __FDLMATH_INLINE double log(double x)
320:                 {
321:                     return (double)_logx((__FDLMATH_XDOUBLE)x);
322:                 }
323:                 __FDLMATH_INLINE double log10(double x)
324:                 {
325:                     return (double)_log10x((__FDLMATH_XDOUBLE)x);
326:                 }
327:                 __FDLMATH_INLINE double modf(double x, double *pint)
328:                 {
329:                     __FDLMATH_XDOUBLE dpint;
330:                     double r;
331:                 
332:                     r = (double)_modfx((__FDLMATH_XDOUBLE)x, &dpint);
333:                     *pint = (double)dpint;
334:                 
335:                     return r;
336:                 }
337:                 __FDLMATH_INLINE double pow(double x, double y)
338:                 {
339:                     return (double)_powx((__FDLMATH_XDOUBLE)x, (__FDLMATH_XDOUBLE)y);
340:                 }
341:                 __FDLMATH_INLINE double sin(double x)
342:                 {
343:                     return (double)_sinx((__FDLMATH_XDOUBLE)x);
00000034  00000000   NOP
344:                 }
345:                 __FDLMATH_INLINE double sinh(double x)
346:                 {
347:                     return (double)_sinhx((__FDLMATH_XDOUBLE)x);
348:                 }
349:                 __FDLMATH_INLINE double sqrt(double x)
350:                 {
351:                     return (double)_sqrtx((__FDLMATH_XDOUBLE)x);
9D071D04  46006321   CVT.D.S F12, F12
9D0785D8  0F41E432   JAL _sqrtx
000001F8  00000000   NOP
352:                 }
353:                 __FDLMATH_INLINE double tan(double x)
354:                 {
355:                     return (double)_tanx((__FDLMATH_XDOUBLE)x);
356:                 }
357:                 __FDLMATH_INLINE double tanh(double x)
358:                 {
359:                     return (double)_tanhx((__FDLMATH_XDOUBLE)x);
360:                 }
361:                 
362:                 #undef __FDLMATH_XDOUBLE
363:                 #undef __FDLMATH_INLINE
364:                 
365:                 #endif /* __FDLMATH_H */
---  /data01/build/bamboo/xml-data/build-dir/M32DEV-PT37-JOB1/src/pic32m-gcc/gcc/libgcc/libgcc2.c  ------
9D072E7C  00C04021   ADDU T0, A2, ZERO
9D0732E0  00C04021   ADDU T0, A2, ZERO
9D072E80  00804821   ADDU T1, A0, ZERO
9D0732E4  00801021   ADDU V0, A0, ZERO
9D072E84  14E0003B   BNE A3, ZERO, 0x9D072F74
9D072E88  00A01821   ADDU V1, A1, ZERO
9D0732E8  14E0003F   BNE A3, ZERO, 0x9D0733E8
9D0732EC  00A04821   ADDU T1, A1, ZERO
9D072E8C  00A6102B   SLTU V0, A1, A2
9D072E90  10400048   BEQ V0, ZERO, 0x9D072FB4
9D072E94  70C21020   CLZ V0, A2
9D0732F0  00A6182B   SLTU V1, A1, A2
9D0732F4  10600047   BEQ V1, ZERO, 0x9D073414
9D0732F8  70C31820   CLZ V1, A2
9D072E98  50400008   BEQL V0, ZERO, 0x9D072EBC
9D072E9C  00083402   SRL A2, T0, 16
9D0732FC  50600008   BEQL V1, ZERO, 0x9D073320
9D073300  00081C02   SRL V1, T0, 16
9D072EAC  00464004   SLLV T0, A2, V0
9D073310  00664004   SLLV T0, A2, V1
9D072EA0  00021823   SUBU V1, ZERO, V0
9D072EA4  00452804   SLLV A1, A1, V0
9D072EA8  00641806   SRLV V1, A0, V1
9D072EB0  00651825   OR V1, V1, A1
9D073304  00034823   SUBU T1, ZERO, V1
9D073308  00652804   SLLV A1, A1, V1
9D07330C  01244806   SRLV T1, A0, T1
9D073314  01254825   OR T1, T1, A1
9D072EB4  00444804   SLLV T1, A0, V0
9D073318  00641004   SLLV V0, A0, V1
9D072EB8  00083402   SRL A2, T0, 16
9D072EBC  0066001B   DIVU V1, A2
9D072EC0  00C001F4   TEQ A2, ZERO
9D072EC4  00002010   MFHI A0
9D072EC8  00005812   MFLO T3
9D072ECC  310CFFFF   ANDI T4, T0, -1
9D072ED0  00095402   SRL T2, T1, 16
9D072ED4  716C5802   MUL T3, T3, T4
9D072ED8  00042400   SLL A0, A0, 16
9D072EDC  008A5025   OR T2, A0, T2
9D072EE0  014B682B   SLTU T5, T2, T3
9D072EE4  0066001B   DIVU V1, A2
9D072EE8  00C001F4   TEQ A2, ZERO
9D072EEC  51A00009   BEQL T5, ZERO, 0x9D072F14
9D072EF0  014B5023   SUBU T2, T2, T3
9D072EF4  01485021   ADDU T2, T2, T0
9D072EF8  0148182B   SLTU V1, T2, T0
9D072EFC  54600005   BNEL V1, ZERO, 0x9D072F14
9D072F00  014B5023   SUBU T2, T2, T3
9D072F04  014B202B   SLTU A0, T2, T3
9D072F08  01481821   ADDU V1, T2, T0
9D072F0C  0064500B   MOVN T2, V1, A0
9D072F10  014B5023   SUBU T2, T2, T3
9D072F14  3123FFFF   ANDI V1, T1, -1
9D072F18  0146001B   DIVU T2, A2
9D072F1C  00C001F4   TEQ A2, ZERO
9D072F20  00004810   MFHI T1
9D072F24  00002012   MFLO A0
9D072F28  708C2002   MUL A0, A0, T4
9D072F2C  00094C00   SLL T1, T1, 16
9D072F30  01234825   OR T1, T1, V1
9D072F34  0124182B   SLTU V1, T1, A0
9D072F38  0146001B   DIVU T2, A2
9D072F3C  00C001F4   TEQ A2, ZERO
9D072F40  50600009   BEQL V1, ZERO, .LBE15
9D072F44  01244823   SUBU T1, T1, A0
9D072F48  01284821   ADDU T1, T1, T0
9D072F4C  0128182B   SLTU V1, T1, T0
9D072F50  54600005   BNEL V1, ZERO, .LBE15
9D072F54  01244823   SUBU T1, T1, A0
9D072F58  0124182B   SLTU V1, T1, A0
9D072F5C  01284021   ADDU T0, T1, T0
9D072F60  0103480B   MOVN T1, T0, V1
9D072F64  01244823   SUBU T1, T1, A0
9D07331C  00081C02   SRL V1, T0, 16
9D073320  0123001B   DIVU T1, V1
9D073324  006001F4   TEQ V1, ZERO
9D073328  00006010   MFHI T4
9D07332C  00005812   MFLO T3
9D073330  310AFFFF   ANDI T2, T0, -1
9D073334  00022402   SRL A0, V0, 16
9D073338  00003012   MFLO A2
9D07333C  716A3802   MUL A3, T3, T2
9D073340  000C6400   SLL T4, T4, 16
9D073344  01842025   OR A0, T4, A0
9D073348  0087602B   SLTU T4, A0, A3
9D07334C  0123001B   DIVU T1, V1
9D073350  006001F4   TEQ V1, ZERO
9D073354  1180000B   BEQ T4, ZERO, 0x9D073384
9D073358  00872823   SUBU A1, A0, A3
9D07335C  00882021   ADDU A0, A0, T0
9D073360  0088282B   SLTU A1, A0, T0
9D073364  14A00006   BNE A1, ZERO, 0x9D073380
9D073368  2566FFFF   ADDIU A2, T3, -1
9D07336C  0087282B   SLTU A1, A0, A3
9D073370  10A00004   BEQ A1, ZERO, 0x9D073384
9D073374  00872823   SUBU A1, A0, A3
9D073378  2566FFFE   ADDIU A2, T3, -2
9D07337C  00882021   ADDU A0, A0, T0
9D073380  00872823   SUBU A1, A0, A3
9D073384  3042FFFF   ANDI V0, V0, -1
9D073388  00A3001B   DIVU A1, V1
9D07338C  006001F4   TEQ V1, ZERO
9D073390  00004810   MFHI T1
9D073394  00003812   MFLO A3
9D073398  00002012   MFLO A0
9D07339C  70EA5002   MUL T2, A3, T2
9D0733A0  00094C00   SLL T1, T1, 16
9D0733A4  01221025   OR V0, T1, V0
9D0733A8  004A482B   SLTU T1, V0, T2
9D0733AC  00A3001B   DIVU A1, V1
9D0733B0  006001F4   TEQ V1, ZERO
9D0733B4  51200009   BEQL T1, ZERO, 0x9D0733DC
9D0733B8  00061400   SLL V0, A2, 16
9D0733BC  00481021   ADDU V0, V0, T0
9D0733C0  0048402B   SLTU T0, V0, T0
9D0733C4  15000004   BNE T0, ZERO, 0x9D0733D8
9D0733C8  24E4FFFF   ADDIU A0, A3, -1
9D0733CC  004A502B   SLTU T2, V0, T2
9D0733D0  24E7FFFE   ADDIU A3, A3, -2
9D0733D4  00EA200B   MOVN A0, A3, T2
9D0733D8  00061400   SLL V0, A2, 16
9D0733DC  00821025   OR V0, A0, V0
9D0733E0  03E00008   JR RA
9D0733E4  00001821   ADDU V1, ZERO, ZERO
9D072FB4  14C00006   BNE A2, ZERO, 0x9D072FD0
9D072FB8  71021020   CLZ V0, T0
9D073414  14C00006   BNE A2, ZERO, 0x9D073430
9D073418  71031820   CLZ V1, T0
9D072FBC  24020001   ADDIU V0, ZERO, 1
9D072FC0  0046001B   DIVU V0, A2
9D072FC4  00C001F4   TEQ A2, ZERO
9D072FC8  00004012   MFLO T0
9D07341C  24030001   ADDIU V1, ZERO, 1
9D073420  0066001B   DIVU V1, A2
9D073424  00C001F4   TEQ A2, ZERO
9D073428  00004012   MFLO T0
9D072FCC  71021020   CLZ V0, T0
9D07342C  71031820   CLZ V1, T0
9D072FD0  5440007D   BNEL V0, ZERO, 0x9D0731C8
9D072FD4  00484004   SLLV T0, T0, V0
9D073430  5460007B   BNEL V1, ZERO, 0x9D073620
9D073434  00684004   SLLV T0, T0, V1
9D072FD8  00A82823   SUBU A1, A1, T0
9D072FDC  00081C02   SRL V1, T0, 16
9D072FE0  3107FFFF   ANDI A3, T0, -1
9D073438  00A82023   SUBU A0, A1, T0
9D07343C  00083C02   SRL A3, T0, 16
9D073440  310BFFFF   ANDI T3, T0, -1
9D073444  24030001   ADDIU V1, ZERO, 1
9D0731C8  24090020   ADDIU T1, ZERO, 32
9D0731CC  01224823   SUBU T1, T1, V0
9D073620  24020020   ADDIU V0, ZERO, 32
9D073624  00431023   SUBU V0, V0, V1
9D0731D0  01255006   SRLV T2, A1, T1
9D073628  00454806   SRLV T1, A1, V0
9D0731EC  00452804   SLLV A1, A1, V0
9D0731F0  01244806   SRLV T1, A0, T1
9D0731F4  01252825   OR A1, T1, A1
9D073644  00652804   SLLV A1, A1, V1
9D073648  00441006   SRLV V0, A0, V0
9D07364C  00452825   OR A1, V0, A1
9D0731FC  00444804   SLLV T1, A0, V0
9D073654  00641004   SLLV V0, A0, V1
9D0731D4  00081C02   SRL V1, T0, 16
9D0731D8  0143001B   DIVU T2, V1
9D0731DC  006001F4   TEQ V1, ZERO
9D0731E0  00003010   MFHI A2
9D0731E4  00005812   MFLO T3
9D0731E8  3107FFFF   ANDI A3, T0, -1
9D0731F8  00056402   SRL T4, A1, 16
9D073200  71675802   MUL T3, T3, A3
9D073204  00063400   SLL A2, A2, 16
9D073208  01863025   OR A2, T4, A2
9D07320C  00CB202B   SLTU A0, A2, T3
9D073210  0143001B   DIVU T2, V1
9D073214  006001F4   TEQ V1, ZERO
9D073218  50800006   BEQL A0, ZERO, 0x9D073234
9D07321C  00CB3023   SUBU A2, A2, T3
9D073220  00C83021   ADDU A2, A2, T0
9D073224  00C8202B   SLTU A0, A2, T0
9D073228  10800024   BEQ A0, ZERO, 0x9D0732BC
9D07322C  00CB502B   SLTU T2, A2, T3
9D073230  00CB3023   SUBU A2, A2, T3
9D073234  30AAFFFF   ANDI T2, A1, -1
9D073238  00C3001B   DIVU A2, V1
9D07323C  006001F4   TEQ V1, ZERO
9D073240  00002010   MFHI A0
9D073244  00002812   MFLO A1
9D073248  70A72802   MUL A1, A1, A3
9D07324C  00042400   SLL A0, A0, 16
9D073250  008A2025   OR A0, A0, T2
9D073254  0085502B   SLTU T2, A0, A1
9D073258  00C3001B   DIVU A2, V1
9D07325C  006001F4   TEQ V1, ZERO
9D073260  5140FF60   BEQL T2, ZERO, .LBB17
9D073264  00852823   SUBU A1, A0, A1
9D073268  00882021   ADDU A0, A0, T0
9D07326C  0088302B   SLTU A2, A0, T0
9D073270  54C0FF5C   BNEL A2, ZERO, .LBB17
9D073274  00852823   SUBU A1, A0, A1
9D073278  0085502B   SLTU T2, A0, A1
9D07327C  00883021   ADDU A2, A0, T0
9D073280  00CA200B   MOVN A0, A2, T2
9D073284  0B41CBF9   J .LBB17
9D073288  00852823   SUBU A1, A0, A1
9D0732BC  00C82021   ADDU A0, A2, T0
9D0732C0  0B41CC8C   J 0x9D073230
9D0732C4  008A300B   MOVN A2, A0, T2
9D07362C  00083C02   SRL A3, T0, 16
9D073630  0127001B   DIVU T1, A3
9D073634  00E001F4   TEQ A3, ZERO
9D073638  00003010   MFHI A2
9D07363C  00006012   MFLO T4
9D073640  310BFFFF   ANDI T3, T0, -1
9D073650  00056C02   SRL T5, A1, 16
9D073658  00001812   MFLO V1
9D07365C  718B5002   MUL T2, T4, T3
9D073660  00063400   SLL A2, A2, 16
9D073664  01A63025   OR A2, T5, A2
9D073668  00CA202B   SLTU A0, A2, T2
9D07366C  0127001B   DIVU T1, A3
9D073670  00E001F4   TEQ A3, ZERO
9D073674  5080000B   BEQL A0, ZERO, 0x9D0736A4
9D073678  00CA3023   SUBU A2, A2, T2
9D07367C  00C83021   ADDU A2, A2, T0
9D073680  00C8202B   SLTU A0, A2, T0
9D073684  14800006   BNE A0, ZERO, 0x9D0736A0
9D073688  2583FFFF   ADDIU V1, T4, -1
9D07368C  00CA202B   SLTU A0, A2, T2
9D073690  50800004   BEQL A0, ZERO, 0x9D0736A4
9D073694  00CA3023   SUBU A2, A2, T2
9D073698  2583FFFE   ADDIU V1, T4, -2
9D07369C  00C83021   ADDU A2, A2, T0
9D0736A0  00CA3023   SUBU A2, A2, T2
9D0736A4  30ACFFFF   ANDI T4, A1, -1
9D0736A8  00C7001B   DIVU A2, A3
9D0736AC  00E001F4   TEQ A3, ZERO
9D0736B0  00002010   MFHI A0
9D0736B4  00005012   MFLO T2
9D0736B8  00004812   MFLO T1
9D0736BC  714B2802   MUL A1, T2, T3
9D0736C0  00042400   SLL A0, A0, 16
9D0736C4  008C2025   OR A0, A0, T4
9D0736C8  0085602B   SLTU T4, A0, A1
9D0736CC  00C7001B   DIVU A2, A3
9D0736D0  00E001F4   TEQ A3, ZERO
9D0736D4  5180000B   BEQL T4, ZERO, 0x9D073704
9D0736D8  00031C00   SLL V1, V1, 16
9D0736DC  00882021   ADDU A0, A0, T0
9D0736E0  0088302B   SLTU A2, A0, T0
9D0736E4  14C00006   BNE A2, ZERO, 0x9D073700
9D0736E8  2549FFFF   ADDIU T1, T2, -1
9D0736EC  0085302B   SLTU A2, A0, A1
9D0736F0  50C00004   BEQL A2, ZERO, 0x9D073704
9D0736F4  00031C00   SLL V1, V1, 16
9D0736F8  2549FFFE   ADDIU T1, T2, -2
9D0736FC  00882021   ADDU A0, A0, T0
9D073700  00031C00   SLL V1, V1, 16
9D073704  00852023   SUBU A0, A0, A1
9D073708  0B41CD12   J .LBB16
9D07370C  01231825   OR V1, T1, V1
9D072FE4  00092402   SRL A0, T1, 16
9D072FE8  00A3001B   DIVU A1, V1
9D072FEC  006001F4   TEQ V1, ZERO
9D072FF0  00005010   MFHI T2
9D072FF4  00003012   MFLO A2
9D072FF8  70C73002   MUL A2, A2, A3
9D072FFC  000A5400   SLL T2, T2, 16
9D073000  01442025   OR A0, T2, A0
9D073004  0086502B   SLTU T2, A0, A2
9D073008  00A3001B   DIVU A1, V1
9D07300C  006001F4   TEQ V1, ZERO
9D073010  51400009   BEQL T2, ZERO, 0x9D073038
9D073014  00862023   SUBU A0, A0, A2
9D073018  00882021   ADDU A0, A0, T0
9D07301C  0088282B   SLTU A1, A0, T0
9D073020  54A00005   BNEL A1, ZERO, 0x9D073038
9D073024  00862023   SUBU A0, A0, A2
9D073028  0086502B   SLTU T2, A0, A2
9D07302C  00882821   ADDU A1, A0, T0
9D073030  00AA200B   MOVN A0, A1, T2
9D073034  00862023   SUBU A0, A0, A2
9D073038  3126FFFF   ANDI A2, T1, -1
9D07303C  0083001B   DIVU A0, V1
9D073040  006001F4   TEQ V1, ZERO
9D073044  00004810   MFHI T1
9D073048  00002812   MFLO A1
9D07304C  70A72802   MUL A1, A1, A3
9D073050  00094C00   SLL T1, T1, 16
9D073054  01264825   OR T1, T1, A2
9D073058  0125302B   SLTU A2, T1, A1
9D07305C  0083001B   DIVU A0, V1
9D073060  006001F4   TEQ V1, ZERO
9D073064  50C00009   BEQL A2, ZERO, .LBE17
9D073068  01254823   SUBU T1, T1, A1
9D07306C  01284821   ADDU T1, T1, T0
9D073070  0128182B   SLTU V1, T1, T0
9D073074  54600005   BNEL V1, ZERO, .LBE17
9D073078  01254823   SUBU T1, T1, A1
9D07307C  0125182B   SLTU V1, T1, A1
9D073080  01284021   ADDU T0, T1, T0
9D073084  0103480B   MOVN T1, T0, V1
9D073088  01254823   SUBU T1, T1, A1
9D073448  00023402   SRL A2, V0, 16
9D07344C  0087001B   DIVU A0, A3
9D073450  00E001F4   TEQ A3, ZERO
9D073454  00006810   MFHI T5
9D073458  00006012   MFLO T4
9D07345C  00004812   MFLO T1
9D073460  718B5002   MUL T2, T4, T3
9D073464  000D6C00   SLL T5, T5, 16
9D073468  01A63025   OR A2, T5, A2
9D07346C  00CA682B   SLTU T5, A2, T2
9D073470  0087001B   DIVU A0, A3
9D073474  00E001F4   TEQ A3, ZERO
9D073478  11A00009   BEQ T5, ZERO, 0x9D0734A0
9D07347C  00CA2823   SUBU A1, A2, T2
9D073480  00C83021   ADDU A2, A2, T0
9D073484  00C8202B   SLTU A0, A2, T0
9D073488  14800004   BNE A0, ZERO, 0x9D07349C
9D07348C  2589FFFF   ADDIU T1, T4, -1
9D073490  00CA202B   SLTU A0, A2, T2
9D073494  548000A6   BNEL A0, ZERO, 0x9D073730
9D073498  2589FFFE   ADDIU T1, T4, -2
9D07349C  00CA2823   SUBU A1, A2, T2
9D0734A0  3042FFFF   ANDI V0, V0, -1
9D0734A4  00A7001B   DIVU A1, A3
9D0734A8  00E001F4   TEQ A3, ZERO
9D0734AC  00005010   MFHI T2
9D0734B0  00003012   MFLO A2
9D0734B4  00002012   MFLO A0
9D0734B8  70CB5802   MUL T3, A2, T3
9D0734BC  000A5400   SLL T2, T2, 16
9D0734C0  01421025   OR V0, T2, V0
9D0734C4  004B502B   SLTU T2, V0, T3
9D0734C8  00A7001B   DIVU A1, A3
9D0734CC  00E001F4   TEQ A3, ZERO
9D0734D0  51400009   BEQL T2, ZERO, .LBE16
9D0734D4  00091400   SLL V0, T1, 16
9D0734D8  00481021   ADDU V0, V0, T0
9D0734DC  0048402B   SLTU T0, V0, T0
9D0734E0  15000004   BNE T0, ZERO, 0x9D0734F4
9D0734E4  24C4FFFF   ADDIU A0, A2, -1
9D0734E8  004B582B   SLTU T3, V0, T3
9D0734EC  24C6FFFE   ADDIU A2, A2, -2
9D0734F0  00CB200B   MOVN A0, A2, T3
9D0734F4  00091400   SLL V0, T1, 16
9D0734F8  03E00008   JR RA
9D0734FC  00821025   OR V0, A0, V0
9D073730  0B41CD27   J 0x9D07349C
9D073734  00C83021   ADDU A2, A2, T0
9D072F68  00491006   SRLV V0, T1, V0
9D07308C  00491006   SRLV V0, T1, V0
9D072F6C  03E00008   JR RA
9D072F70  00001821   ADDU V1, ZERO, ZERO
9D073090  03E00008   JR RA
9D073094  00001821   ADDU V1, ZERO, ZERO
9D072F74  00A7102B   SLTU V0, A1, A3
9D072F78  14400047   BNE V0, ZERO, 0x9D073098
9D072F7C  70EA5020   CLZ T2, A3
9D0733E8  00A7102B   SLTU V0, A1, A3
9D0733EC  14400044   BNE V0, ZERO, 0x9D073500
9D0733F0  70E84020   CLZ T0, A3
9D073500  00001821   ADDU V1, ZERO, ZERO
9D073504  03E00008   JR RA
9D073508  00001021   ADDU V0, ZERO, ZERO
9D073098  00801021   ADDU V0, A0, ZERO
9D07309C  03E00008   JR RA
9D0730A0  00A01821   ADDU V1, A1, ZERO
9D072F80  15400048   BNE T2, ZERO, 0x9D0730A4
9D072F84  240B0020   ADDIU T3, ZERO, 32
9D0733F4  55000045   BNEL T0, ZERO, 0x9D07350C
9D0733F8  24020020   ADDIU V0, ZERO, 32
9D072F88  00E5102B   SLTU V0, A3, A1
9D072F8C  14400005   BNE V0, ZERO, 0x9D072FA4
9D072F90  00861023   SUBU V0, A0, A2
9D072F94  0086402B   SLTU T0, A0, A2
9D072F98  15000089   BNE T0, ZERO, 0x9D0731C0
9D072F9C  00801021   ADDU V0, A0, ZERO
9D0733FC  00E5282B   SLTU A1, A3, A1
9D073400  14A000C8   BNE A1, ZERO, 0x9D073724
9D073404  0086302B   SLTU A2, A0, A2
9D073408  38C20001   XORI V0, A2, 1
9D07340C  03E00008   JR RA
9D073410  00001821   ADDU V1, ZERO, ZERO
9D073724  00001821   ADDU V1, ZERO, ZERO
9D072FA0  00861023   SUBU V0, A0, A2
9D072FA4  00A72823   SUBU A1, A1, A3
9D072FA8  0082202B   SLTU A0, A0, V0
9D072FAC  03E00008   JR RA
9D072FB0  00A41823   SUBU V1, A1, A0
9D0730A4  016A5823   SUBU T3, T3, T2
9D07350C  00481023   SUBU V0, V0, T0
9D0730A8  01473804   SLLV A3, A3, T2
9D0730AC  01661006   SRLV V0, A2, T3
9D0730B0  00473825   OR A3, V0, A3
9D073510  01073804   SLLV A3, A3, T0
9D073514  00461806   SRLV V1, A2, V0
9D073518  00673825   OR A3, V1, A3
9D0730E0  01463004   SLLV A2, A2, T2
9D0730B4  01656806   SRLV T5, A1, T3
9D07351C  00455006   SRLV T2, A1, V0
9D0730D0  01452804   SLLV A1, A1, T2
9D0730D4  01641006   SRLV V0, A0, T3
9D0730D8  00451025   OR V0, V0, A1
9D073538  01052804   SLLV A1, A1, T0
9D07353C  00441006   SRLV V0, A0, V0
9D073540  00452825   OR A1, V0, A1
9D0730B8  00074C02   SRL T1, A3, 16
9D0730BC  01A9001B   DIVU T5, T1
9D0730C0  012001F4   TEQ T1, ZERO
9D0730C4  00006010   MFHI T4
9D0730C8  00001812   MFLO V1
9D0730CC  30EEFFFF   ANDI T6, A3, -1
9D0730DC  00022C02   SRL A1, V0, 16
9D0730E4  00004012   MFLO T0
9D0730E8  706E7802   MUL T7, V1, T6
9D0730EC  000C6400   SLL T4, T4, 16
9D0730F0  01856025   OR T4, T4, A1
9D0730F4  018F282B   SLTU A1, T4, T7
9D0730F8  01A9001B   DIVU T5, T1
9D0730FC  012001F4   TEQ T1, ZERO
9D073100  10A0000A   BEQ A1, ZERO, 0x9D07312C
9D073104  01442004   SLLV A0, A0, T2
9D073108  01876021   ADDU T4, T4, A3
9D07310C  0187282B   SLTU A1, T4, A3
9D073110  14A00006   BNE A1, ZERO, 0x9D07312C
9D073114  2468FFFF   ADDIU T0, V1, -1
9D073118  018F282B   SLTU A1, T4, T7
9D07311C  50A00004   BEQL A1, ZERO, 0x9D073130
9D073120  018F6023   SUBU T4, T4, T7
9D073124  2468FFFE   ADDIU T0, V1, -2
9D073128  01876021   ADDU T4, T4, A3
9D07312C  018F6023   SUBU T4, T4, T7
9D073130  3042FFFF   ANDI V0, V0, -1
9D073134  0189001B   DIVU T4, T1
9D073138  012001F4   TEQ T1, ZERO
9D07313C  00002810   MFHI A1
9D073140  00001812   MFLO V1
9D073144  00006812   MFLO T5
9D073148  706E7002   MUL T6, V1, T6
9D07314C  00052C00   SLL A1, A1, 16
9D073150  00A21025   OR V0, A1, V0
9D073154  004E282B   SLTU A1, V0, T6
9D073158  0189001B   DIVU T4, T1
9D07315C  012001F4   TEQ T1, ZERO
9D073160  50A00006   BEQL A1, ZERO, 0x9D07317C
9D073164  00084400   SLL T0, T0, 16
9D073168  00471021   ADDU V0, V0, A3
9D07316C  0047282B   SLTU A1, V0, A3
9D073170  10A0004C   BEQ A1, ZERO, .LBE25
9D073174  246DFFFF   ADDIU T5, V1, -1
9D073178  00084400   SLL T0, T0, 16
9D07317C  01A84025   OR T0, T5, T0
9D073180  004E1023   SUBU V0, V0, T6
9D0732A4  004E282B   SLTU A1, V0, T6
9D0732A8  50A0FFB4   BEQL A1, ZERO, 0x9D07317C
9D0732AC  00084400   SLL T0, T0, 16
9D0732B0  246DFFFE   ADDIU T5, V1, -2
9D0732B4  0B41CC5E   J 0x9D073178
9D0732B8  00471021   ADDU V0, V0, A3
9D073520  00071C02   SRL V1, A3, 16
9D073524  0143001B   DIVU T2, V1
9D073528  006001F4   TEQ V1, ZERO
9D07352C  00004810   MFHI T1
9D073530  00006812   MFLO T5
9D073534  30EBFFFF   ANDI T3, A3, -1
9D073544  00057402   SRL T6, A1, 16
9D073548  00001012   MFLO V0
9D07354C  71AB6002   MUL T4, T5, T3
9D073550  00094C00   SLL T1, T1, 16
9D073554  012E4825   OR T1, T1, T6
9D073558  012C702B   SLTU T6, T1, T4
9D07355C  0143001B   DIVU T2, V1
9D073560  006001F4   TEQ V1, ZERO
9D073564  11C0000A   BEQ T6, ZERO, 0x9D073590
9D073568  01063004   SLLV A2, A2, T0
9D07356C  01274821   ADDU T1, T1, A3
9D073570  0127502B   SLTU T2, T1, A3
9D073574  15400006   BNE T2, ZERO, 0x9D073590
9D073578  25A2FFFF   ADDIU V0, T5, -1
9D07357C  012C502B   SLTU T2, T1, T4
9D073580  51400004   BEQL T2, ZERO, 0x9D073594
9D073584  012C4823   SUBU T1, T1, T4
9D073588  25A2FFFE   ADDIU V0, T5, -2
9D07358C  01274821   ADDU T1, T1, A3
9D073590  012C4823   SUBU T1, T1, T4
9D073594  30A5FFFF   ANDI A1, A1, -1
9D073598  0123001B   DIVU T1, V1
9D07359C  006001F4   TEQ V1, ZERO
9D0735A0  00006810   MFHI T5
9D0735A4  00006012   MFLO T4
9D0735A8  00005012   MFLO T2
9D0735AC  718B5802   MUL T3, T4, T3
9D0735B0  000D6C00   SLL T5, T5, 16
9D0735B4  01A52825   OR A1, T5, A1
9D0735B8  00AB682B   SLTU T5, A1, T3
9D0735BC  0123001B   DIVU T1, V1
9D0735C0  006001F4   TEQ V1, ZERO
9D0735C4  51A0000B   BEQL T5, ZERO, 0x9D0735F4
9D0735C8  00021400   SLL V0, V0, 16
9D0735CC  00A72821   ADDU A1, A1, A3
9D0735D0  00A7182B   SLTU V1, A1, A3
9D0735D4  14600006   BNE V1, ZERO, 0x9D0735F0
9D0735D8  258AFFFF   ADDIU T2, T4, -1
9D0735DC  00AB182B   SLTU V1, A1, T3
9D0735E0  50600004   BEQL V1, ZERO, 0x9D0735F4
9D0735E4  00021400   SLL V0, V0, 16
9D0735E8  258AFFFE   ADDIU T2, T4, -2
9D0735EC  00A72821   ADDU A1, A1, A3
9D0735F0  00021400   SLL V0, V0, 16
9D0735F4  01421025   OR V0, T2, V0
9D0735F8  00AB2823   SUBU A1, A1, T3
9D073184  01060019   MULTU 0, T0, A2
9D073188  00004810   MFHI T1
9D0731A0  00003012   MFLO A2
9D0735FC  00460019   MULTU 0, V0, A2
9D073600  00003810   MFHI A3
9D07318C  0049182B   SLTU V1, V0, T1
9D073190  1460003E   BNE V1, ZERO, .LBB25
9D073194  00004012   MFLO T0
9D073198  1049004B   BEQ V0, T1, 0x9D0732C8
9D07319C  00491823   SUBU V1, V0, T1
9D0732C8  0088182B   SLTU V1, A0, T0
9D0732CC  5460FFF0   BNEL V1, ZERO, 0x9D073290
9D0732D0  01063023   SUBU A2, T0, A2
9D0732D4  00003012   MFLO A2
9D0732D8  0B41CC69   J .LBB24
9D0732DC  00001821   ADDU V1, ZERO, ZERO
9D073604  00A7182B   SLTU V1, A1, A3
9D073608  14600044   BNE V1, ZERO, 0x9D07371C
9D07360C  00003012   MFLO A2
9D073610  10A7003F   BEQ A1, A3, 0x9D073710
9D073614  01042004   SLLV A0, A0, T0
9D073710  0086302B   SLTU A2, A0, A2
9D073714  10C0FFC0   BEQ A2, ZERO, 0x9D073618
9D073718  00000000   NOP
9D073618  03E00008   JR RA
9D07361C  00001821   ADDU V1, ZERO, ZERO
9D07371C  0B41CD86   J 0x9D073618
9D073720  2442FFFF   ADDIU V0, V0, -1
9D07328C  01063023   SUBU A2, T0, A2
9D073290  01271823   SUBU V1, T1, A3
9D073294  0106402B   SLTU T0, T0, A2
9D073298  00681823   SUBU V1, V1, T0
9D07329C  0B41CC69   J .LBB24
9D0732A0  00431823   SUBU V1, V0, V1
9D0731A4  00863023   SUBU A2, A0, A2
9D0731A8  0086202B   SLTU A0, A0, A2
9D0731AC  00641823   SUBU V1, V1, A0
9D0731B0  01631004   SLLV V0, V1, T3
9D0731B4  01463006   SRLV A2, A2, T2
9D0731B8  00461025   OR V0, V0, A2
9D0731BC  01431806   SRLV V1, V1, T2
9D0731C0  03E00008   JR RA
9D0731C4  00000000   NOP
9D0731C8  24090020   ADDIU T1, ZERO, 32
9D0731CC  01224823   SUBU T1, T1, V0
9D0731D0  01255006   SRLV T2, A1, T1
9D0731D4  00081C02   SRL V1, T0, 16
9D0731D8  0143001B   DIVU T2, V1
9D0731DC  006001F4   TEQ V1, ZERO
9D0731E0  00003010   MFHI A2
9D0731E4  00005812   MFLO T3
9D0731E8  3107FFFF   ANDI A3, T0, -1
9D0731EC  00452804   SLLV A1, A1, V0
9D0731F0  01244806   SRLV T1, A0, T1
9D0731F4  01252825   OR A1, T1, A1
9D0731F8  00056402   SRL T4, A1, 16
9D0731FC  00444804   SLLV T1, A0, V0
9D073200  71675802   MUL T3, T3, A3
9D073204  00063400   SLL A2, A2, 16
9D073208  01863025   OR A2, T4, A2
9D07320C  00CB202B   SLTU A0, A2, T3
9D073210  0143001B   DIVU T2, V1
9D073214  006001F4   TEQ V1, ZERO
9D073218  50800006   BEQL A0, ZERO, 0x9D073234
9D07321C  00CB3023   SUBU A2, A2, T3
9D073220  00C83021   ADDU A2, A2, T0
9D073224  00C8202B   SLTU A0, A2, T0
9D073228  10800024   BEQ A0, ZERO, 0x9D0732BC
9D07322C  00CB502B   SLTU T2, A2, T3
9D073230  00CB3023   SUBU A2, A2, T3
9D073234  30AAFFFF   ANDI T2, A1, -1
9D073238  00C3001B   DIVU A2, V1
9D07323C  006001F4   TEQ V1, ZERO
9D073240  00002010   MFHI A0
9D073244  00002812   MFLO A1
9D073248  70A72802   MUL A1, A1, A3
9D07324C  00042400   SLL A0, A0, 16
9D073250  008A2025   OR A0, A0, T2
9D073254  0085502B   SLTU T2, A0, A1
9D073258  00C3001B   DIVU A2, V1
9D07325C  006001F4   TEQ V1, ZERO
9D073260  5140FF60   BEQL T2, ZERO, .LBB17
9D073264  00852823   SUBU A1, A0, A1
9D073268  00882021   ADDU A0, A0, T0
9D07326C  0088302B   SLTU A2, A0, T0
9D073270  54C0FF5C   BNEL A2, ZERO, .LBB17
9D073274  00852823   SUBU A1, A0, A1
9D073278  0085502B   SLTU T2, A0, A1
9D07327C  00883021   ADDU A2, A0, T0
9D073280  00CA200B   MOVN A0, A2, T2
9D073284  0B41CBF9   J .LBB17
9D073288  00852823   SUBU A1, A0, A1
9D07328C  01063023   SUBU A2, T0, A2
9D073290  01271823   SUBU V1, T1, A3
9D073294  0106402B   SLTU T0, T0, A2
9D073298  00681823   SUBU V1, V1, T0
9D07329C  0B41CC69   J .LBB24
9D0732A0  00431823   SUBU V1, V0, V1
9D0732A4  004E282B   SLTU A1, V0, T6
9D0732A8  50A0FFB4   BEQL A1, ZERO, 0x9D07317C
9D0732AC  00084400   SLL T0, T0, 16
9D0732B0  246DFFFE   ADDIU T5, V1, -2
9D0732B4  0B41CC5E   J 0x9D073178
9D0732B8  00471021   ADDU V0, V0, A3
9D0732BC  00C82021   ADDU A0, A2, T0
9D0732C0  0B41CC8C   J 0x9D073230
9D0732C4  008A300B   MOVN A2, A0, T2
9D0732C8  0088182B   SLTU V1, A0, T0
9D0732CC  5460FFF0   BNEL V1, ZERO, 0x9D073290
9D0732D0  01063023   SUBU A2, T0, A2
9D0732D4  00003012   MFLO A2
9D0732D8  0B41CC69   J .LBB24
9D0732DC  00001821   ADDU V1, ZERO, ZERO
9D073728  03E00008   JR RA
9D07372C  24020001   ADDIU V0, ZERO, 1
9D073730  0B41CD27   J 0x9D07349C
9D073734  00C83021   ADDU A2, A2, T0
9D078D60  00A7182A   SLT V1, A1, A3
9D078D64  14600004   BNE V1, ZERO, 0x9D078D78
9D078D68  00001021   ADDU V0, ZERO, ZERO
9D078D6C  00E5282A   SLT A1, A3, A1
9D078D70  10A00003   BEQ A1, ZERO, 0x9D078D80
9D078D74  24020002   ADDIU V0, ZERO, 2
9D078D90  24020002   ADDIU V0, ZERO, 2
9D078D94  24030001   ADDIU V1, ZERO, 1
9D078D80  0086182B   SLTU V1, A0, A2
9D078D84  1460FFFC   BNE V1, ZERO, 0x9D078D78
9D078D88  00001021   ADDU V0, ZERO, ZERO
9D078D8C  00C4202B   SLTU A0, A2, A0
9D078D78  03E00008   JR RA
9D078D7C  00000000   NOP
9D078D98  03E00008   JR RA
9D078D9C  0064100A   MOVZ V0, V1, A0
